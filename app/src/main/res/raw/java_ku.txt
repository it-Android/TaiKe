{
"entityList":[
{
"id":1,
"title":"Java语言的类型是______。",
"optionA":"面向对象语言 ",
"optionB":"面向过程语言 ",
"optionC":"汇编语言 ",
"optionD":"形式语言 ",
"answer":"Ａ",
"explain":"    本题考的是Java语言的特点。\n    过去的高级语言大多数是面向过程的语言，它的缺点是问题的解决与程序是一对一的关系，问题如有任何一点变更，程序也随之要修改。\n    而面向对象的语言将客观世界看成由各种对象组成，对象客观实体可定义成大的结构-类(class)，每个类有自己的特性（属性）和操作（方法）。面向对象技术使复杂的问题可以分解化，大大提高了软件的重用性。与其他面向对象语言相比，Java利用面向对象技术更彻底。它把所有的Java应用和Applet都看做对象，按类封装，其封装性实现了模块化和信息隐藏，继承性实现了代码重用，让用户可以自由地定义数据类型，建立自己的类库。\n    故本题答案为A。",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":2,
"title":"编译Java  Application 源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为______。",
"optionA":".java ",
"optionB":".class ",
"optionC":".html ",
"optionD":".exe ",
"answer":"Ｂ",
"explain":"    本题考查的是应用程序的扩展名。\n    1、Java的源程序代码的扩展名为.java。\n    2、Java的编译器和解释器的扩展名为.exe，他们分别是javac.exe、java.exe。\n    3、通过Java编译器编译生成的是二进制字节码文件，其扩展名为.class。\n    4、调用applet小程序的HTML文件的扩展名为.html或.htm。",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":3,
"title":"下列特点中，______是Java虚拟机执行的特点之一。",
"optionA":"字节代码",
"optionB":"多进程 ",
"optionC":"静态链接 ",
"optionD":"编译",
"answer":"Ａ",
"explain":"本题考查的是Java虚拟机。\n    Java语言的执行模式是半编译和半解释型。Java编写好的程序首先由编译器转换为标准字节代码，然后由Java虚拟机去解释执行。字节代码也是一种二进制文件，但不能直接在操作系统上运行，它可看作虚拟机的机器码。虚拟机把字节代码程序与各操作系统和硬件分开，使Java程序独立于平台。",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":4,
"title":"Java源程序文件的扩展名为______。",
"optionA":"java ",
"optionB":"class ",
"optionC":"html ",
"optionD":"exe ",
"answer":"Ａ",
"explain":"本题考查的是Java程序的结构。\n    Java源程序的后缀名是.java，源程序编译后的字节码文件的后缀是.class，.exe文件是Windows系统的应用程序的文件后缀。.html是静态网页的后缀。",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":5,
"title":"下面有关变量及其作用域的陈述______是不对的。",
"optionA":"在方法里面定义的局部变量在方法退出的时候被撤销 ",
"optionB":"局部变量也叫自动变量 ",
"optionC":"在方法外面定义的实例变量在对象被构造时创建",
"optionD":"在方法中定义的方法的参变量只要该对象被需要就一直存在 ",
"answer":"Ｄ",
"explain":"    本题考查的是变量的作用域。\n    在方法中定义的局部变量在方法退出时被自动撤消，只有静态变量不会被撤消。如果未对变量指定修释符，在JAVA中将自动将其设置为局部变量，局部变量也叫自动变量，对于方法外面的变量，将在对象被创建时一起被创建，其初值可通过构造函数对其进行初始化。如果方法中是一个简单类型的形参，由于其是按值传递，在编译时会占用存储空间，直到该对象释放时为止。如果形参为一个类类型，其参数是按地址传递，编译时不会为其分配空间，因此该参变量不会存在于方法中。",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":6,
"title":"在Java中，负责对字节代码解释执行的是______。",
"optionA":"垃圾回收器 ",
"optionB":"虚拟机 ",
"optionC":"编译器 ",
"optionD":"多线程机制 ",
"answer":"Ｂ",
"explain":"本题考查的是Java语言的特点和实现机制。\n    虚拟机（JVM）负责对字节码（Byte Code）进行解释执行。 ",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":7,
"title":"用来导入已定义好的类或包的语句是______。",
"optionA":"main ",
"optionB":"import ",
"optionC":"public class ",
"optionD":"class ",
"answer":"Ｂ",
"explain":"    本题考查的是包的概念。\n        import 语句用来导入已定义好的包或类。",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":8,
"title":"Java语言中，负责并发管理的机制是______。",
"optionA":"垃圾回收",
"optionB":"虚拟机",
"optionC":"代码安全 ",
"optionD":"多线程 ",
"answer":"Ｄ",
"explain":"    本题考察的是线程的概念。\n    多线程是指一个程序中包含多个执行流，多线程是实现并发的一种有效手段。",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":9,
"title":"运行Java程序需要的工具软件所在的目录是______。",
"optionA":"JDK的bin目录 ",
"optionB":"JDK的demo目录 ",
"optionC":"JDK的lib目录",
"optionD":"JDK的jre目录",
"answer":"Ａ",
"explain":"本题考的是JDK目录结构。\n    bin目录下有编译器、解释器和许多工具（如服务器工具、IDL、package工具和jdb等）。\n    demo目录下有各种演示例子。\n    lib目录下都是库文件。\n    jre目录是Java程序运行用环境的根目录，它下面有bin子目录，包括平台所用工具和库的可执行文件和DLL文件；lib子目录，包括java运行环境的代码库、属性设置和资源文件，默认安装目录，安全管理。\n",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":10,
"title":"Java语言与C++语言相比，最突出的特点是______。",
"optionA":"面向对象 ",
"optionB":"高性能 ",
"optionC":"跨平台 ",
"optionD":"有类库 ",
"answer":"Ｃ",
"explain":"本题考的是Java与C++的比较。\n    在不同的平台上，Java有不同的JVM，使Java字节码可以跨越平台的限制，在不同的平台上运行。但C++程序不具备平台独立性。\n",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":11,
"title":"下列关于System类的叙述中，错误的是______。",
"optionA":"System类是一个final类 ",
"optionB":"System类不能实例化 ",
"optionC":"System类中没有定义属性 ",
"optionD":"System类主要提供了系统环境参数的访问",
"answer":"Ｃ",
"explain":"    本题考查的是System类。\n    System类是一个final类，它不能被继承，同时它又是一个抽象类，所以也是一个不能被实例化的类，它主要提供标准输入输出、错误输出流、对外部定义的属性及环境变量的访问、加载文件和库的方法、还有快速复制数组的一部分的实用方法。",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":12,
"title":"下列对Java特性的叙述中，错误的是______。",
"optionA":"在编写Java子类时可以自由地增加新方法和属性",
"optionB":"Java的Applet要求编程首先创建JFrame窗口 ",
"optionC":"Java语言用解释器执行字节码 ",
"optionD":"Java中的类一般都有自己的属性和方法 ",
"answer":"Ｂ",
"explain":"    本题考查的是Applet的概念。\n    Applet是能够嵌入到HTML页面中，并能够在浏览器中运行的Java类，本身并不一定需要首先创建窗体，但可以使用JApple类来使用Swing构件。\n    Swing包中的JFrame类与创建窗口有关，是提供给java应用程序用来放置图形用户界面的一个容器。\n    JApplet类与JFrame一样是顶层的Swing容器。包含Swing构件的Applet必须是JApplet的子类。",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":13,
"title":"下列对Java语言的叙述中，错误的是______。",
"optionA":"Java虚拟机解释执行字节码",
"optionB":"JDK的库文件目录是bin ",
"optionC":"Java的类是对具有相同行为对象的一种抽象",
"optionD":"Java中的垃圾回收机制是一个系统级的线程",
"answer":"Ｂ",
"explain":"    本题考查的是JDK目录结构。\n    在JDK目录结构中，lib目录下存放的都是库文件，而bin目录下有编译器、解释器和许多工具（如服务器工具、IDL、package工具和jdb等）。",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":14,
"title":"Java虚拟机（JVM）运行Java代码时，不会进行的操作是______。",
"optionA":"加载代码 ",
"optionB":"校验代码",
"optionC":"编译代码 ",
"optionD":"执行代码 ",
"answer":"Ｃ",
"explain":"本题考查的是Java虚拟机。\n    Java语言的执行模式是半编译和半解释型。Java编写好的程序首先由编译器转换为标准字节代码，然后由Java虚拟机去解释执行。\n    Java虚拟机(JVM)是可运行Java代码的假想计算机。只要根据JVM规格描述将解释器移植到特定的计算机上，就能保证经过编译的任何Java代码能够在该系统上运行。\n    字节代码也是一种二进制文件，但不能直接在操作系统上运行，它可看作虚拟机的机器码。运行JVM字节码的工作是由解释器来完成的。解释执行过程分三步进行：代码的装入、代码的校验和代码的执行。\n",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":15,
"title":"用于设置组件大小的方法是______。",
"optionA":"paint() ",
"optionB":"setSize()",
"optionC":"getSize() ",
"optionD":"repaint() ",
"answer":"Ｂ",
"explain":"    本题考查的是构件和容器。\n    paint()：绘制构件。\n    setSize()：设置构件的大小。\n    getSize()：获得构件的大小。\n    repaint()：重新绘制构件。",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":16,
"title":"Java中定义常量的保留字是______。",
"optionA":"const ",
"optionB":"final ",
"optionC":"finally",
"optionD":"native",
"answer":"Ｂ",
"explain":"    本题考查的是常量的保留字。\n    常量在程序运行过程中其值不能改变。所有的常数都是常量。此外，还可以在程序中定义一些常量。常量的定义比变量的定义多一个修饰符\"final\"，另外，常量必须有初始值。\n    final属性是专门定义常值变量的保留字，说明该变量赋值以后永不改变，变量初值是该变量的默认值。",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":17,
"title":"下列特点中不属于Java的是______。",
"optionA":"多线程 ",
"optionB":"多继承 ",
"optionC":"跨平台 ",
"optionD":"动态性 ",
"answer":"Ｂ",
"explain":"本题考察的是Java语言的特点及优势。\n    Java语言的特点包括：简单易学、利用面向对象技术、分布式计算、健壮性、安全性、跨平台、可移植性、解释执行、高性能、多线程、动态性以及Applet的特点。\n",
"type":"Java体系结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":18,
"title":"Frame默认的布局管理器是______。",
"optionA":"FlowLayout",
"optionB":"BorderLayout ",
"optionC":"GridLayout",
"optionD":"CardLayout ",
"answer":"B",
"explain":"    本题考查的是布局管理器。\n    Frame继承自java.awt.window类，它们都在java.awt包中，对于Frame而言，其默认的布局管理器为BorderLayout。采用FlowLayout时，当容器内一行中构件布满后，将自动从下行开始；采用BorderLayout，将窗体分成东、南、西、北、中五个部分，在每个部分中可以放置一个构件；采用GridLayout布局时，将以m*n的网格的形式来显示容器中的构件，每个网格中可以放置一个构件；采用CardLayout时将为构件提供卡式界面。另外还有GridBag Layout布局管理器。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":19,
"title":"以下______不是Java中有效的关键字。",
"optionA":"const ",
"optionB":"NULL ",
"optionC":"false ",
"optionD":"this ",
"answer":"B",
"explain":"本题考查的是Java的关键字。\n    Java中常量null，false，true，new，this，const，break都是小写。\n",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":20,
"title":"Java语言有多种实现机制，下列______技术属于垃圾回收机制。",
"optionA":"字节编译 ",
"optionB":"内存跟踪 ",
"optionC":"语法检查 ",
"optionD":"堆栈上\/下溢检查 ",
"answer":"B",
"explain":"    本题考查的是垃圾回收机制。\n    Java语言不同于C++，它可以自动跟踪内存的使用情况，释放一些不再需要使用的空间，从而保证了不会由于程序的运行而生成大量无法释放的空间，该机置被称垃圾回收机制，由于这种机制的引入，从很大程度上减轻了程序员的负担。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":21,
"title":"main方法是Java  Application程序执行的入口点，关于main方法的方法头以下______是合法的。",
"optionA":"public static void main(String args[])",
"optionB":"public static void main()",
"optionC":"public static void main(string arg[])",
"optionD":"public static void main(String args)",
"answer":"A",
"explain":"    本题考查的是Java程序的结构。\n    Java应用程序中标准的main方法的结构是public static  void main(String args[])。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":22,
"title":"下面有关Java代码安全性的叙述______是不对的。",
"optionA":"字节码校验器加载查询执行需要的所有类 ",
"optionB":"运行时解释器执行代码 ",
"optionC":"在运行时，字节码被加载，验证然后在解释器里面运行 ",
"optionD":"类加载器通过分离本机文件系统的类和从网络导入的类增加安全性 ",
"answer":"A",
"explain":"本题考查的是Java的安全机制。\n类加载器（class loader）加载程序运行所需要的所有类，它通过区分本机文件系统的类和网络系统导入的类增加安全性，这可以限制任何的特洛伊木马程序，因为本机类总是先被加载，一旦所有的类被加载完，执行文件的内存划分就固定了，在这个时候特定的内存地址被分配给对应的符号引用，查找表（lookup table）也被建立，由于内存划分发生在运行时，解释器在受限制的代码区增加保护防止未授权的访问；然后字节码校验器（byte code verifier）进行校验，主要执行下面的检查：类符合JVM规范的类文件格式，没有违反访问限制，代码没有造成堆栈的上溢或者下溢，所有操作代码的参数类型都是正确的，没有非法的数据类型转换（例如将整型数转换成对象类型）发生；校验通过的字节码被解释器（interpreter）执行，解释器在必要时通过运行时系统执行对底层硬件的合适调用。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":23,
"title":"下列叙述中，正确的是______。",
"optionA":"Java语言中的标识符是区分大小写的",
"optionB":"源文件名与public类名可以不相同",
"optionC":"源文件名其扩展名为.jar ",
"optionD":"源文件中public类的数目不限 ",
"answer":"A",
"explain":"    本题考查的是Java语言基础。\n    Java语言中的标识符是区分大小写的；Java中源文件名必须与public类名相同，且源文件的扩展名必须为java；每个源文件中最多只能有一个public类。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":24,
"title":"下列叙述中，正确的是______。",
"optionA":"声明变量时必须指定一个类型 ",
"optionB":"Java认为变量number与Number相同",
"optionC":"Java中唯一的注释方式是\"\/\/\"",
"optionD":"源文件中public类可以有0或多个 ",
"answer":"A",
"explain":"    本题考查的是Java的基本概念。\n    Java的变量标识符是区分大小写的，因此number与Number是两个不同的变量。\n    Java有三类注释方式：\n    1）文档注释 \/**  *\/\n    2）C语言风格注释  \/* *\/\n    3）单行注释 \/\/\n    每个源文件中最多只能有一个public类。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":25,
"title":"下列描述中，错误的是______。",
"optionA":"Java要求编程者管理内存 ",
"optionB":"Java的安全性体现在多个层次上",
"optionC":"Applet要求在支持Java 的浏览器上运行 ",
"optionD":"Java有多线程机制 ",
"answer":"A",
"explain":"    本题考察的是Java语言的特点及优势。\n    Java的内存管理是指对象的分配和释放问题。在Java中，对象的分配是由程序员通过new关键字为每个对象申请内存空间 (基本类型除外)，但对象的释放是由垃圾收集器决定和执行的，程序员不需要通过调用函数来释放内存，从而使程序员从繁忙的内存管理中解放出来。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":26,
"title":"下列关于Java语言特点的叙述中，错误的是______。",
"optionA":"Java是面向过程的编程语言 ",
"optionB":"Java支持分布式计算 ",
"optionC":"Java是跨平台的编程语言 ",
"optionD":"Java支持多线程 ",
"answer":"A",
"explain":"    本题考的是Java语言特点。\n    Java利用的是面向对象技术，它把所有的Java应用和Applet都看作对象，按类封装。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":27,
"title":"下列叙述中，错误的是______。",
"optionA":"Java提供了丰富的类库 ",
"optionB":"Java最大限度地利用网络资源",
"optionC":"Java支持多线程",
"optionD":"Java不支持TCP\/IP协议 ",
"answer":"D",
"explain":"    本题考的是Java语言的特点。\n    Java提供的类库支持TCP\/IP协议，应用程序可通过URL地址，在访问网络上任何地方的对象时，如同访问本地文件一样简单。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":28,
"title":"下列布尔变量定义中，正确并且规范的是______。",
"optionA":"BOOLEAN canceled = false;",
"optionB":"boolean canceled = false;",
"optionC":"boolean CANCELED = false；",
"optionD":"boolean canceled = FALSE;",
"answer":"B",
"explain":"    本题考查的是布尔变量的定义格式。\n    布尔型数据只有两个值：true（真）和false（假），布尔变量定义形式举例如：boolean tt=true;。在Java中，标识符是区分大小写的，故选项A错误；Java程序中的语句必须以英文状态下的分号结尾，选项C错误。另外，从标识符一般都采用小写的规范来讲，选项C也不正确；在Java中，常量null、false、true都是小写，所以选项D错误。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":29,
"title":"下列对Java源程序结构的叙述中，错误的是______。",
"optionA":"import语句必须在所有类定义之前",
"optionB":"接口定义允许0或多个",
"optionC":"Java Application中的public class类定义允许0或多个",
"optionD":"package语句允许0或1个",
"answer":"C",
"explain":"    本题考查的是Java源程序结构。\n    Import语句可以有多个，它们必须放在package语句之后，class语句之前。\n    接口是用来实现类间多重继承的结构模式，其实际上是一个特殊的类，接口定义中extends后面可以列出多个父接口，接口定义也可以为0个。\n    public class类定义表明该类是一个公共类，Java Application中的公共类只能有一个。\n    package语句必须是源程序中的第一个非注释语句，每一个编译单元最多只能使用一次package语句。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":30,
"title":"下列Java源程序结构中前三种语句的次序，正确的是______。",
"optionA":"下列Java源程序结构中前三种语句的次序，正确的是______。",
"optionB":"import必为首，其他不限",
"optionC":"public class，import，package ",
"optionD":"package，import，public class",
"answer":"D",
"explain":"    本题考查的是JAVA程序结构。\n    JAVA源程序结构：\n    1、package语句，0或1个，指定源文件存入所指定的包中，该语句必须在文件之首，如没有此语句，源文件存入当前目录下。\n    2、import语句，0或多个，必须在所有类定义之前引入标准类。\n    3、public classDefinition，0或1个，指定应用程序类名，也是源程序名；\n    4、classDefinition，0或多个，类定义。\n    5、interfaceDefinition，0或多个，接口定义。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":31,
"title":"Java程序的并发机制是______。",
"optionA":"多线程",
"optionB":"多接口",
"optionC":"多平台",
"optionD":"多态性",
"answer":"A",
"explain":"    本题考查的是线程的概念。\n    Java语言的一个重要的特性是在语言级上支持多线程的程序设计。多线程是指一个程序中包含多个执行流，多线程是实现并发的一种有效手段。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":32,
"title":"点击窗口内的按钮时，产生的事件是______。",
"optionA":"MouseEvent",
"optionB":"WindowEvent",
"optionC":"ActionEvent",
"optionD":"KeyEvent",
"answer":"C",
"explain":"    本题考查的是Java语言中的事件处理。\n    MouseEvent：处理鼠标拖动、移动、单击、按下、释放或者进入、退出组件的事件。\n    WindowEvent：处理窗口激活、失去活动窗口、最小化、打开、关闭或者退出的事件。\n    ActionEvent：处理按钮、列表双击、单击菜单项目。\n    KeyEvent：处理键盘的输入。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":33,
"title":"下列有关Java布尔类型的描述中，正确的是______。",
"optionA":"一种基本的数据类型，它的类型名称为boolean",
"optionB":"用int表示类型",
"optionC":"其值可以赋给int类型的变量",
"optionD":"有两个值，1代表真，0代表假",
"answer":"A",
"explain":"    本题考查的是简单数据类型。\n    Java的数据类型共分为两大类，一类是简单数据类型，一类是复合数据类型。布尔类型是简单数据类型中的一种。布尔类型用boolean表示，Java中的布尔类型只有两个值：true（真）和false（假）。Java中的布尔类型不对应于任何整数，也不能转换成任何数字。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":34,
"title":"Java的反汇编命令是______。",
"optionA":"javap",
"optionB":"javac ",
"optionC":"jdb",
"optionD":"java",
"answer":"A",
"explain":"    本题考察的是JDK工具。\n    在编写执行java程序的过程中会用到一些SUN公司提供的JDK工具，主要包括：\n    ①javac.exe：Java编译器，能将源代码编译成字节码，以.class扩展名存入java工作目录中。\n    ②java.exe：Java解释器，执行字节码程序。\n    ③javadoc.exe：Java文档生成器，对Java源文件和包以MML格式产生AP文档。\n    ④javap.exe：Java类分解器，对.class文件提供字节代码的反汇编，并打印。\n    ⑤jdb.exe：Java调试器，如编译器返回程序代码错误，可用它对程序进行调试，它是解释器的拷贝，类调试器。",
"type":"JDK目录结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":35,
"title":"保证Java语言可移植性的特征是______。",
"optionA":"面向对象",
"optionB":"安全性",
"optionC":"分布式计算",
"optionD":"可跨平台",
"answer":"D",
"explain":"    本题考的是Java语言的特点。\n    Java解释器采用生成与体系结构无关的字节代码指令的技术，只需安装Java运行系统，就可保证Java程序可以在网络的任何地方运行，即同一个Java程序可在不同的处理器上运行，这就是Java的跨平台的特点，此特点保证了软件的可移植性。",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":36,
"title":"以下______不是Java中正确的整数表示。",
"optionA":"22",
"optionB":"0x22",
"optionC":"022",
"optionD":"22H ",
"answer":"D",
"explain":"    本题考的是Java的简单数据类型。\n    整型常量分3种书写格式：\n    （1）十进制整数，如189，-360。\n    （2）八进制整数，以0开头，如012表示十进制的10。\n    （3）十六进制整数，以0x或0X开头，如0x123表示十进制数291。",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":37,
"title":"以下______字符串是Java中合法的标识符。",
"optionA":"super",
"optionB":"3number",
"optionC":"#number",
"optionD":"$number",
"answer":"D",
"explain":"    本题考查的是Java标识符。\n    标识符命名规则为：\n    1、标识符是以字母、下划线、美元符（$）作为首字符的字符串序列。在首字符后面可以跟字母、下划线、美元符和数字。\n    2、标识符区分大小写。\n    3、标识符的字符数目没有限制，但为便于阅读和记忆，不宜太长。\n    另外要注意的是Java中有一些标识符是具有专门意义和用途的，不允许作为一般的标识符用，它们是保留字。例如本题中的super。",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":38,
"title":"下列______是不合法的Java标识符。",
"optionA":"Tree$Glasses",
"optionB":"FirstJavaApplet",
"optionC":"_$theLastOne",
"optionD":"273.5",
"answer":"D",
"explain":"    本题考查的是Java标识符。\n    标识符命名规则为：\n    1、标识符是以字母、下划线、美元符（$）作为首字符的字符串序列。在首字符后面可以跟字母、下划线、美元符和数字。\n    2、标识符区分大小写。\n    3、标识符的字符数目没有限制，但为便于阅读和记忆，不宜太长。\n    另外要注意的是Java中有一些标识符是具有专门意义和用途的，不允许作为一般的标识符用，它们是保留字。",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":39,
"title":"给出下面的代码：\npublic class Data{\n  public static void main (String args[]){\n    float f=0.0;\n    f+=1.0;\n    System.out.println(f);\n  }\n}\n______叙述是对的。",
"optionA":"编译时将发生错误 ",
"optionB":"编译时正确但是运行时出错 ",
"optionC":"输出为1.0 ",
"optionD":"输出为null",
"answer":"A",
"explain":"本题考查的是数据类型的定义。\n由于Java在数据类型中，浮点数类型的数据分为float和double两种类型。当数据的末尾加f或F表示float型，当在数据的末尾加d或D时，此数表示double型，若两都不加的话，则默认为double型。\n本题中由于0.0是double型的数据，而f是float型的变量，在Java中，优先级高的数据类型不能直接赋值给优先低的数据类型，必须要强制类型转换。这种错误将在程序编译时发现。",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":40,
"title":"下列属于合法的Java标识符是______。",
"optionA":"_cat",
"optionB":"5books",
"optionC":"+static",
"optionD":"-3.14159",
"answer":"A",
"explain":"    本题考查的是Java语言基础。\n    Java语言中，所有变量、常量、对象和类都是用标识符命名的。标识符的命名规则如下：\n    （1）必须以字母、下划线（_）或美元符（$）开头\n    （2）区分大小写\n    （3）长度无限制，但不宜过长",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":41,
"title":"下列属于合法的Java标识符是______。",
"optionA":"ABC",
"optionB":"&5678",
"optionC":"+rriwo",
"optionD":"saler ",
"answer":"D",
"explain":"    本题考查的是Java的标识符。\n    在Java语言中，所有的变量、常量、对象和类都是用标识符命名的，标识符命名规则为：\n    1）标识符是以字母、下划线（_）、美元符（$）作为首字符串序列。\n    2）标识符是区分大小写的。\n    3）标识符的字符数目没有限制，但是为便于阅读和记忆，不宜过长。",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":42,
"title":"Java为移动设备提供的平台是______。",
"optionA":"J2ME",
"optionB":"J2SE",
"optionC":"J2EE",
"optionD":"JDK5.0",
"answer":"A",
"explain":"    本题考察的是J2ME平台。\n    J2ME是为嵌入式和移动设备提供的Java平台，它的体系结构由Profiles 、Configuration 和 Optional Packages组成。",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":43,
"title":"Java的核心包中，提供编程应用的基本类的包是______。",
"optionA":"java.lang",
"optionB":"java.util ",
"optionC":"java.applet",
"optionD":"java.rmi",
"answer":"A",
"explain":"    本题考的是Java核心包。\n    java.lang包：封装所有编程应用的基本类。\n    java.util包：提供实用程序类和集合类。\n    java.applet包：为Applet提供执行需要的所有类，主要是访问Applet内容的通信类。\n    java.rmi包：提供程序远程方法调用所需的类。",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":44,
"title":"在下列Java语言的包中，提供图形界面构件的包是______。",
"optionA":"java.io",
"optionB":"javax.swing",
"optionC":"java.net",
"optionD":"java.rmi",
"answer":"B",
"explain":"    本题考的是Java的API结构。\n    java.io包：提供程序输入\/输出文件操作的类。\n    javax.swing包：提供构建和管理应用程序图形界面的轻量级的构件。\n    java.net包：提供程序执行网络通信应用及URL处理的类。\n    java.rmi包：提供程序远程方法调用所需的类。",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":45,
"title":"数组中各个元素的数据类型是______。",
"optionA":"相同的",
"optionB":"不同的",
"optionC":"部分相同的",
"optionD":"任意的",
"answer":"A",
"explain":"    本题考查的是数组的数据类型。\n    数组，即用一个变量表示一组相同性质的数据，一个数组中的所有元素的类型都必须是相同的数据类型。数组的数据类型可以是Java语言的任意数据类型，包括简单类型和复杂类型。",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":46,
"title":"下列变量定义中，正确的是______。",
"optionA":"long l=123L",
"optionB":"long l=3.14156f",
"optionC":"int i=\"k\"",
"optionD":"double d=1.55989E2f",
"answer":"A",
"explain":"    本题考查的是简单数据类型。\n    对于long类型整型常量书写表示时，要在数字后面加L或l，如123L表示一个64位的123长整数，所以B选项错误；\n    双精度浮点数常量书写表示时，要在数字后面加D或d，所以D选项错误；\n    字符串是用双引号括起来的，所以C选项错误，k的数据类型不是整型而是字符串；",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":47,
"title":"public class {\n  public static void main(String args[]){\n    double d=12.3;\n    Decrementer dec=new Decrementer();\n    dec.decrement(d);\n    System.out.println(d);\n  }\n}\nclass Decrementer{\n  public void decrement(double decMe){\n    decMe=decMe-1.0;\n  }\n}\n代码执行后输出结果是______。",
"optionA":"12.3",
"optionB":"11.3",
"optionC":"13.3",
"optionD":"-1.0",
"answer":"A",
"explain":"    本题考查的是参数传递。\n    在程序中，语句\"Decrementer dec=new Decrementer();\"创建了一个Decrementer类的对象，并将变量d作为参数调用decrement方法，在类decrement中，方法decrement()得到参数并进行计算，但是，由于方法decrement()并没有将计算结果返回，所以d的值仍然为初始值12.3。",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":48,
"title":"在方法内部使用，代表对当前对象自身引用的关键字是______。",
"optionA":"super",
"optionB":"This ",
"optionC":"Super",
"optionD":"this",
"answer":"D",
"explain":"    本题考查的是类的封装、多态和继承。\n    super关键字表示超（父）类的意思。this变量代表对象本身。为了访问父类的成员变量或方法，可以采用super加上点和成员变量或方法的形式，如果当前方法中的形参名与成员变量名相同或与方法中的局部变量名相同时，就要采用this关键字来区别变量及使用范围。\n    另外，关键字也称为保留字，是程序设计语言本身已经使用并赋予特定意义的一些标识符，Java严格区分大小写。",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":49,
"title":"AWT中用来表示对话框的类是______。",
"optionA":"Font",
"optionB":"Color",
"optionC":"Panel",
"optionD":"Dialog",
"answer":"D",
"explain":"    本题考查的是Java的图形用户界面AWT包。\n    Font类提供的构造方法和方法可以对字体的大小、字体的样式等进行设置。\n    Color类用来设置颜色。\n    Panel通常也称为面板，是一种透明的容器，既没有标题，也没有边框，它不能作为最外层的容器单独存在，它首先必须作为一个构件放置到其他容器中，然后再把它当作容器，把其他构件放在它里面。\n    Dialog：对话框，对话框是Window类的子类。",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":50,
"title":"Java中所有类的父类是______。",
"optionA":"Father",
"optionB":"Lang",
"optionC":"Exception",
"optionD":"Object",
"answer":"D",
"explain":"    本题考查的是Object类。\n    Object类是Java程序中所有类的直接或间接父类，也是类库中所有类的父类，处在类层次的最高点。所有其他的类都是从Object类派生出来的。\n    故本题答案为D。",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":51,
"title":"下列变量定义中，不合法的是______。",
"optionA":"int $x;",
"optionB":"int _123;",
"optionC":"int Summer_2010_gross_sale;",
"optionD":"int #dim;",
"answer":"D",
"explain":"    本题考察的是标识符的命名规则。\n    在Java语言中，所有的变量、常量、对象、和类都是用标识符命名的，标识符的命名规则为：\n    ①标识符是以字母、下划线（_）、美元符（$）作为首字符的字符串序列。在首字符后面可以跟字母、下划线（_）、美元符（$）和数字。\n    ②标识符是区分大小写的。\n    ③标识符的字符数目没有限制，但为便于阅读和记忆，不宜太长。",
"type":"Java的API结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":52,
"title":"下列有关Java语言的叙述中，正确的是______。",
"optionA":"Java是不区分大小写的",
"optionB":"源文件名与public类型的类名必须相同",
"optionC":"源文件名其扩展名为.jar",
"optionD":"源文件中public类的数目不限",
"answer":"B",
"explain":"    本题考的是Java程序结构。\n    Java规定，源文件名与程序类名必须相同，其扩展名为.java，源文件中最多只能有一个public类，其他类的个数不限。且Java是区分大小写的。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":53,
"title":"已知如下定义：String s = \"story\";下面______表达式是合法的。",
"optionA":"s += books;",
"optionB":"char c = s[1];",
"optionC":"int len = s.length;",
"optionD":"String t = s.toLowerCase();",
"answer":"D",
"explain":"    本题考查的是表达式。\n    选项A类型不一致，若此表达式改为s+=\"books\"就对了；\n    选项B中s[1]表示数组，Java中数组是对象，它需通过new关键字来创建；\n    选项C中s的类型不确定，如果s定义的是数组的，则此表达式是合法的，因为数组中length是属性，而字符串中是通过length()方法获得字符长度的，故此表达式不合法。若把它改为int len=s.length();就对了；\n    选项D中toLowerCase()是String类提供的一个方法，作用是将字符串中所有字符变为小写。返回一个字符串值赋给t。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":54,
"title":"执行以下语句后，str2的值是______。\nString str1=\"abc\";\nString str2=str1.concat(\"cde\");",
"optionA":"abcde ",
"optionB":"abccde",
"optionC":"cdeabc",
"optionD":"edccba",
"answer":"B",
"explain":"    本题考查的是字符串的修改。\n    String提供concat(),replace(),substring(),toLowerCase(),toUpperCase()等方法。\n    public String concat(String str)\/\/将当前字符串对象与指定str字符串相连；\n    public String replace(char oldChar,char newChar)\/\/用新字符替换老字符；\n    public String substring(int beginIndex)\/\/按指定的起始位置获得子字符串；\n    public String substring(int beginIndex,int endIndex)\/\/按指定范围去获得字符串中的子字符串；\n    public String toLowerCase()\/\/将字符串中所有字符变为小写；\n    public String toUpperCase()\/\/将字符串中所有字符变为大写。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":55,
"title":"Java的字符类型采用的是Unicode编码方案，每个Unicode码占用______个比特位。",
"optionA":"8",
"optionB":"16",
"optionC":"32",
"optionD":"64",
"answer":"B",
"explain":"    本题考查的是变量中的编码。\n    ASCII是用8位表示一个字符。\n    unicode是用16位表示一个字符，因此unicode中汉字和英文字母占用的空间是一样的。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":56,
"title":"类的设计要求它的某个成员变量不能被外部类访问。应该使用下面的______修饰符获得需要的访问控制。",
"optionA":"public",
"optionB":"no modifier ",
"optionC":"protected",
"optionD":"private",
"answer":"D",
"explain":"本题考查的是Java程序的特点。\nJava有四种访问类型，分别为：public，protected，default，private，其中public变量可以被所有的外部类访问，而protected的可以被同一个包及该类的子类访问，default即没有任何修饰符的变量可以被同一个包中的类访问，而private变量只能在被该类内部被访问。题目中的外部类应该理解为除该类自身的所有其它类，因此只有使用private可以达到要求。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":57,
"title":"在Java中，表示换行符的转义字符是______。",
"optionA":"\\n",
"optionB":"\\f",
"optionC":"'n'",
"optionD":"\\dd",
"answer":"A",
"explain":"    本题考查的是Java的基本数据类型。\n    字符\"\\\"为Java中的转义字符；\"\\n\"表示换行符。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":58,
"title":"下列代表十六进制整数的是______。",
"optionA":"0123",
"optionB":"1900",
"optionC":"fa00 ",
"optionD":"0xa2",
"answer":"D",
"explain":"    本题考查的是数据类型。\n    十六进制数必须以0x开头。比如0x1表示一个16进制数，而1则表示一个十进制数。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":59,
"title":"JDK中提供的文档生成器是______。",
"optionA":"java.exe",
"optionB":"javap.exe",
"optionC":"javadoc.exe",
"optionD":"javaprof.exe",
"answer":"C",
"explain":"    本题考察的是J2SDK的操作命令。\n    javadoc.exe是Java文档生成器，用于对Java源文件和包以MML格式产生AP文档。如给出包名，它到类路径相关的对应包目录下找出所有.java源文件，为每个类生成一个HTML文档并生成该包中所有类的HTML文档索引。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":60,
"title":"下列关于Java对import语句规定的叙述中，错误的是______。",
"optionA":"在Java程序中import语句可以有多个",
"optionB":"在Java程序中import语句可以没有",
"optionC":"在Java程序中import语句必须有一个",
"optionD":"在Java程序中import语句必须引入在所有类定义之前",
"answer":"C",
"explain":"    本题考的是Java程序结构。\n    在Java程序中import语句可以有零个或多个，当导入的类所在的包中有相同名字的类时，不用import导入，而是直接用带包名的方法使用。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":61,
"title":"下列叙述中，错误的是______。",
"optionA":"javac.exe是Java的编译器",
"optionB":"javadoc.exe是Java的文档生成器",
"optionC":"javaprof.exe是Java解释器的剖析工具",
"optionD":"javap.exe是Java的解释器",
"answer":"D",
"explain":"    本题考的是JDK工具。\n    javac.exe：Java编译器，能将源代码编译成字节码，以.class扩展名存入java工作目录中。\n    javadoc.exe：Java文档生成器，对Java源文件和包以MML格式产生AP文档。\n    javaprof.exe：Java剖析工具，提供解释器剖析信息。\n    javap.exe：Java类分解器，对.class文件提供字节代码反汇编，并打印。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":62,
"title":"内部类不可直接使用外部类的成员是______。",
"optionA":"静态成员",
"optionB":"实例成员",
"optionC":"方法内定义",
"optionD":"以上A、B、C都不是",
"answer":"C",
"explain":"    本题考查的是内部类。\n    在一个类的内部嵌套定义的类称为内部类（Inner Class）。与普通类一样，内部类也具有自己的成员变量和成员方法。同样可以通过建立内部类的对象，去访问其他成员变量和调用其他成员方法。但是不同的是：\n    （1）内部类的类名只能在定义它的类、程序段或在表达式内部匿名使用，外部使用他时必须给出类的全名。而且，内部类的类名不允许与包含它的类名相同。\n    （2）内部类可以使用它所在类的静态成员变量和实例成员变量，也可以使用它所在类的方法中的局部变量。\n    （3）内部类可用abstract修饰定义为抽象类，也可用private或protected定义。\n    （4）内部类可作为其他类的成员，而且可访问它所在类的成员。\n    （5）除static内部类外，不能在类内声明static成员。一旦内部类声明为static，就变成顶层类，不能再使用局部变量。这时可声明static成员。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":63,
"title":"下列Java表达式\n19\/3\n(int)71.7-2*3\n7%3\n(double)1\/8+3\n计算结果是______。",
"optionA":"6.3\n64\n2\n2.5 ",
"optionB":"6\n63\n1\n3.125 ",
"optionC":"6.4\n67\n2\n2.5 ",
"optionD":"6\n65\n1\n3.125 ",
"answer":"D",
"explain":"    本题考查的是运算符和表达式。\n    19\/3：该表达式中19与3都是整型，所以默认其运算结果也是整型，19除以3的结果取整数为6；\n    (int)71.7-2*3：尽管该表达式中71.1是一个浮点数，但通过\"(int)\"强制转换，该表达式的结果为整型，答案为65；\n    7%3：\"%\"为模数除，也就是求余，7除以3的余数为1；\n    (double)1\/8+3：该表达式中的三个数均为整型，但是通过\"(double)\"数据类型强制转换为双精度型，1\/8=0.125，0.125+3=3.125，结果保留小数位，所以答案为：3.125。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":64,
"title":"给一个short类型变量赋值的范围是______。",
"optionA":"-128 ~ +127",
"optionB":"-2147483648 ~ +2147483647",
"optionC":"-32768 ~ +32767",
"optionD":"-1000 ~ +1000",
"answer":"C",
"explain":"    本题考查的是简单数据类型。\n    short类型数据存储时占16位bit，表示的数据范围是-32768 ~ +32767。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":65,
"title":"阅读下列程序\npublic class VariableUse{\n    public static void main(String[] args){\n        int a;\n        if(a==8){\n            int b=9;\n            System.out.println(\"a=\"+a);\n            System.out.println(\"b=\"+b);\n        }\n        System.out.println(\"a=\"+a);\n        System.out.println(\"b=\"+b);\n    }\n}\n该程序在编译时的结果是______。",
"optionA":"变量a未赋值",
"optionB":"第二个System.out.println(\"b=\"+b)语句中，变量b作用域有错 ",
"optionC":"第二个System.out.println(\"a=\"+a)语句中，变量a作用域有错",
"optionD":"第一个System.out.println(\"b=\"+b)语句中，变量b作用域有错 ",
"answer":"B",
"explain":"    本题考查的是变量的作用域。\n    {}表示的是Java语句体的范围，在一个语句体中定义的变量，其生命周期仅限于该语句体。像if、for、while等语句，{}中定义的变量的作用范围也只是在该语句体中的。本题中，整型变量b是在if语句中定义的，其作用域也仅限于if语句中，所以在if语句外的输出语句\"System.out.println(\"b=\"+b);\"会发生变量b作用域的错误。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":66,
"title":"下列运算符中，优先级最高的是______。",
"optionA":"+=",
"optionB":"==",
"optionC":"&&",
"optionD":"++",
"answer":"D",
"explain":"    本题考查的是运算符的优先级。\n    本题选项中的四个运算符优先级由高到低依次是：++、==、&&、+=。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":67,
"title":"下列程序段的输出结果是______。\nint data =0;\nchar k='a',p='f';\ndata=p-k;\nSystem.out.println(data);",
"optionA":"0",
"optionB":"a ",
"optionC":"f",
"optionD":"5",
"answer":"D",
"explain":"    本题考查的是基本数据类型的转换。\n    在Java中整型、浮点型、字符型被视为简单数据类型，可以进行混合运算，当类型不一致时，需要进行类型转换。从低位类型到高位类型会进行自动转换，而从高位类型到低位类型需要进行强制类型的转换。表达式\"p-k\"中包含char类型的数据，因此变量p和k自动会转换为int类型，然后参与运算，表达式的值为int类型，把它赋给int类型的变量data，输出结果为5。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":68,
"title":"下列选项中为单精度数的是______。",
"optionA":"2",
"optionB":"5.2",
"optionC":"0.2f ",
"optionD":"023",
"answer":"C",
"explain":"    本题考察的是浮点型数据。\n    在Java数据类型中，浮点数类型的数据分为float和double两种类型。当数据的末尾加f或F表示float型单精度浮点数，当在数据的末尾加d或D时，此数表示double型双精度浮点数，若两者都不加的话，则默认为double型。",
"type":"开发环境设置",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":69,
"title":"下列代表八进制整数的是______。",
"optionA":"0XA6",
"optionB":"-1E3 ",
"optionC":"1840 ",
"optionD":"0144",
"answer":"D",
"explain":"    本题考的是Java的简单数据类型。\n    整型常量分3种书写格式：\n    （1）十进制整数，如189，-360。\n    （2）八进制整数，以0开头，如012表示十进制的10。\n    （3）十六进制整数，以0x或0X开头，如0x123表示十进制数291。\n    另外选项B的书写格式表示科学计算，E是指数符。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":70,
"title":"下面______是main()函数的合法参数。",
"optionA":"char args[]",
"optionB":"char args[][] ",
"optionC":"String args[]",
"optionD":"String args",
"answer":"C",
"explain":"    本题考查的是main()方法的组成。\n    main()方法是一个特殊的方法，它是所有的Java Application程序执行的入口点，所以任何一个Java Application方法必须有且只能有一个main()方法，而且这个main()方法的格式统一为：\n    public static void main(String args[])",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":71,
"title":"如果类中的成员变量只能被同一包访问，则使用以下______约束符。",
"optionA":"无访问控制符",
"optionB":"public ",
"optionC":"protected",
"optionD":"final ",
"answer":"A",
"explain":"    本题考查的是修饰符的含义。\n    1、public指明变量为公有。\n    2、protected指明变量为保护访问。可被同一个包中其他类、不同包中该类的子类以及该类自己访问和引用。\n    3、final指明变量为常量。\n    4、默认（friendly）即无访问控制符，表示只能被同一个包中的类访问和引用。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":72,
"title":"设a=8，则表达式a>>>2的值是______。",
"optionA":"1",
"optionB":"2",
"optionC":"3",
"optionD":"4",
"answer":"B",
"explain":"    本题考查的是表达是逻辑右移运算符。\n    逻辑右移运算符>>>用来将一个数的各二进制位添零右移若干位，注意它的最高位补的是0，因此本题8>>>2的结果是2。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":73,
"title":"假设以下代码\npublic class Parent {\n　　public int addValue( int a, int b) {\n　　int s;\n　　s = a+b;\n　　return s;\n　　}\n}\n　　class Child extends Parent {\n　　}\n选项中______方法可以正确加入类Child中且父类的方法不会被覆盖。",
"optionA":"int addValue( int a, int b ){\/\/ do something...}",
"optionB":"public void addValue (){\/\/ do something...}",
"optionC":"public int addValue( int a, int b )throws MyException {\/\/do something...}",
"optionD":"public float addValue ( int a ,int b, float b=1.0 ){\/\/ do something...}",
"answer":"B",
"explain":"本题考查的是Java的应用。\n此题涉及方法重载（overload），方法重写（override）以及类派生时方法重写的规则。方法重载的规则是：\n一、参数列表必须不同，个数的不同完全可以，如果个数相同，则参数类型的不同不会引起歧意，例如int和long，float和double就不能作为唯一的类型不同；\n二、返回值可以不同，但是不能是重载时唯一的不同点（这点和c++中不同，c++中返回类型必须一致）。\n方法重写发生在类继承时，子类可以重写一个父类中已有的方法，必须在返回类型和参数列表一样时才能说是重写，否则就是重载，java中方法重写的一个重要而且容易被忽略的规则是重写的方法的访问权限不能比被重写的方法的访问权限低！\n重写的另一个规则是重写的方法不能比被重写的方法抛弃(throws)更多种类的异常，其抛弃的异常只能少，或者是其子类，不能以抛弃异常的个数来判断种类，而应该是异常类层次结果上的种类。\n此题中选取项A的错误就是重写的访问权限比被重写的方法的低，而B属于重载，选项C的错误在于比被重写的方法抛弃了更多种类的异常。选项D中，当只传递两个变量的值的时候，那系统就不知道倒底调用哪个方法了，因为b为常量，可以不指定，所以只有选项B是符合题意的。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":74,
"title":"在Java中，由Java编译器自动导入，而无需在程序中用import导入的包是______。",
"optionA":"java.applet",
"optionB":"java.awt",
"optionC":"java.util",
"optionD":"java.lang",
"answer":"D",
"explain":"    本题考查的是Java的API结构。\n    java.lang包封装了所有基本类。由Java编译器自动导入。因此，编程时使用该包中的类，可省去import导入。但使用其它包中的类，必须用import导入。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":75,
"title":"在Java中，实现用户界面功能的包是______。",
"optionA":"java.applet   ",
"optionB":"java.transaction",
"optionC":"java.util  ",
"optionD":"java.awt",
"answer":"D",
"explain":"    本题考查的是Java的包。\n    抽象窗口工具包AWT是Java提供的建立图形用户界面GUI的开发包，AWT可用于Java的Applet和Application中，它支持图形用户界面编程的主要功能：用户界面构件；事件处理模型；图形和图像工具；布局管理器；数据传送类。\n    java.applet包含了一些设计小应用程序（Applet）的类和接口。\n    java.util包是Java的实用工具类库。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":76,
"title":"在Java语言中，不允许使用指针体现出的Java特性是______。",
"optionA":"可移植",
"optionB":"解释执行",
"optionC":"健壮性",
"optionD":"安全性",
"answer":"D",
"explain":"    本题考察的是Java语言的特点。\n    不允许使用指针体现出的Java 特性是安全性，相对于C\/C++等允许使用指针的语言，Java防止了因为指针造成的程序在稳定性和安全性上的漏洞，如对内存的非法入侵，它是目前安全性最佳的语言。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":77,
"title":"在编译Java程序时，用于指定生成.class文件位置的选项是______。",
"optionA":"-g",
"optionB":"-d",
"optionC":"-verbose",
"optionD":"-nowarn",
"answer":"B",
"explain":"    本题考的是Java程序编写及运行的过程。\n    -g：输出文件中加行号及局部变量信息，为调试程序时用；\n    -d：指定存放生成的类(.class)文件的位置；\n    -verbose：显示源代码文件和字节码文件的相关信息；\n    -nowarn：关闭警告信息，只显示错误信息。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":78,
"title":"在执行Java程序时，将应用程序连接到调试器的选项是______。",
"optionA":"-D",
"optionB":"-debug",
"optionC":"-verbosegc",
"optionD":"-mx",
"answer":"B",
"explain":"    本题考的是JDK工具。\n    -D：定义属性名；\n    -debug：将程序连接到调试器；\n    -verbosegc：无用单元收集器每释放一次内存，打印一条信息；\n    -mx：分配最大内存值。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":79,
"title":"阅读下面程序\npublic class Test1{\n    public static void main(String[] args){\n        System.out.println(34+56-6);\n        System.out.println(26*2-3);\n        System.out.println(3*4\/2);\n        System.out.println(5\/2);\n    }\n}\n程序运行结果是______。",
"optionA":"84\n49\n6\n2 ",
"optionB":"90\n25\n6\n2.5 ",
"optionC":"84\n23\n12\n2",
"optionD":"68\n49\n14\n2.5 ",
"answer":"A",
"explain":"    本题考查的是算术运算符。\n    对于二元算术运算符，其表达式结果的类型归纳为以下几类情况：\n    （1）操作数全为整型，那么，只要其中有一个为long型，则表达式结果为long型。\n    （2）两个操作数全是byte型或short型，表达式结果为int型。\n    （3）操作数为浮点型，只要其中有一个为double型，表达式结果就是double型。\n    （4）两个操作数全是float型或其中一个是float型，而另外一个是整型，则表达式结果为float型。\n    本题所有数据都是整型，所以结果也应为整型。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":80,
"title":"switch语句中表达式(expression)的值不允许用的类型是______。",
"optionA":"byte",
"optionB":"int",
"optionC":"boolean",
"optionD":"char ",
"answer":"C",
"explain":"    本题考查的是多分支语句。\n    switch语句中的表达式expression只能返回以下几种类型的值：int、byte、short和char。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":81,
"title":"Reader类所处理的是______。",
"optionA":"字符流",
"optionB":"字节流 ",
"optionC":"文件流",
"optionD":"管道流 ",
"answer":"A",
"explain":"    本题考查的是Java中包含的输入\/输出流的类。\n    Java中处理字符流的抽象类是Reader类和Writer类，它们的直接子类分别有6个和7个。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":82,
"title":"下列不属于Swing的构件是______。",
"optionA":"JButton ",
"optionB":"JLabel",
"optionC":"JFrame",
"optionD":"JPane",
"answer":"D",
"explain":"    本题考查的是Swing构件和容器。\n    在Swing中，JPanel是一类无边框、不能移动、放大、缩小或关闭的容器。本题中D选项拼写错误。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":83,
"title":"下列运算中结果为1的是______。",
"optionA":"8>>1",
"optionB":"4>>>2",
"optionC":"8<<1",
"optionD":"4<<<2",
"answer":"B",
"explain":"    本题考查的是移位运算符。\n    Java使用补码来表示二进制数，在补码表示中，最高位为符号位，正数的符号位为0，负数为1。补码的规定如下：\n    对正数来说，最高位为0，其余各位代表数值本身（以二进制表示），如+42的补码为00101010。\n    对负数而言，把该数绝对值的补码按位取反，然后对整个数加1，即得该数的补码，如-1的补码为11111111。\n    移位运算符包括三种：\n1、算术右移运算符：>>\n    用来将一个数的二进制位序列右移若干位，移到右端的低位被舍弃，最高位则移入原来高位的值。如选项A，8>>1，8的补码为00001000，所以8>>1=00000100，00000100转换为十进制为4。实际上，右移一位相当于除2取商。\n2、算术左移运算符：<<\n    用来将一个数的二进制位序列左移若干位，右补0。则选项C，8<<1，8的补码为00001000，所以8<<1=00010000，00010000转换为十进制为16。在不产生溢出的情况下，左移一位相当于乘2。\n3、逻辑右移运算符：>>>\n    用来将一个数的各二进制位添零右移若干位。与运算符>>的相同之处是，移出的低位被舍弃，不同之处是>>运算时，最高位则移入原来高位的值，而>>>运算时，最高位补0，所以逻辑右移也叫无符号右移。则选项B，4>>>2，4的补码为00000100，所以4>>>2=00000001，00000001转换为十进制为1。\n    选项D，4<<<2，符号<<<不存在。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":84,
"title":"下列数中为八进制的是______。",
"optionA":"27",
"optionB":"0x25",
"optionC":"026",
"optionD":"028",
"answer":"C",
"explain":"    本题考查的是八进制数。\n    八进制数的基数为8，八进制数就是逢8进1，八进制数采用0-7这八个数字来表示一个数，一个数如果要指明它采用八进制，必须在它前面加上一个0。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":85,
"title":"下列关于boolean类型的叙述中，正确的是______。",
"optionA":"可以将boolean类型的数值转换为int类型的数值",
"optionB":"可以将boolean类型的数值转换为字符串",
"optionC":"可以将boolean类型的数值转换为char类型的数值",
"optionD":"不能将boolean类型的数值转换为其他基本数据类型",
"answer":"D",
"explain":"    本题考察的是布尔型数据。\n    布尔型数据（boolean）只有两个值：true（真）和false（假），它不对应任何数值，因此，它不能与数字进行相互转换。",
"type":"Java程序结构",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":86,
"title":"按运算符操作数的数目划分，运算符?:的类型是______。",
"optionA":"三元",
"optionB":"二元",
"optionC":"四元",
"optionD":"一元",
"answer":"A",
"explain":"    本题考的是运算符。\n    \"?:\"是条件运算符，条件运算符是三元运算符。\n    三元条件表达式的一般形式为：\n    expressinon1?expression2:expression3\n    其中表达式expression1应该是关系或布尔表达式，其计算结果为布尔值。如果该值为true，则计算表达式expression2，并将计算结果作为整个表达式的结果；如果为false，则计算表达式expression3，将计算结果作为条件表达式的结果。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":87,
"title":"已知如下代码：\nboolean m = true;\nif ( m == false )  System.out.println(\"False\");\n   else  System.out.println(\"True\");\n执行结果是______。",
"optionA":"False",
"optionB":"True",
"optionC":"None",
"optionD":"运行时出错",
"answer":"B",
"explain":"    本题考查的是if判断语句。\n    if-else结构：\nif(条件)\n    statement1;或{block1}\nelse\n    statement2;或{block2}\n    在条件为真时，执行语句statement1(或代码块block1)，然后跳过else和statement2(或代码块block2)执行下面的语句；在条件为假时，跳过语句statement1(或代码块block1)执行else后面的statement2(或代码块block2)，然后继续执行下面语句。\n    本题中，条件m == false不成立，执行System.out.println(\"True\");所以输出True。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":88,
"title":"以下______表达式是不合法的。",
"optionA":"String  x=\"Hello\";  int  y=9;  x+=y;",
"optionB":"String  x=\"Hello\";  int  y=9;  if(x==y)  { }",
"optionC":"String  x=\"Hello\";  int  y=9;  x=x+y;",
"optionD":"String  x=null;  int  y=(x!=null)&&(x.length()>0) ? x.length() : 0",
"answer":"B",
"explain":"    本题考查的是表达式。\n    Java对\"+\"进行了扩展，不仅可以连接字符串，而且还能将字符串与其它类型数据进行连接，结果是字符串。\n    若\"+\"的第一个操作数是字符串，Java会自动将后面的操作数类型转换成字符串类型。例如本题选项A中，x+=y即x=x+y，则计算结果x的值为字符串Hello9；选项C与此类似，故此选项也是正确的；选项D主要考查的是条件运算符\"?:\"，即把表达式(x!=null)&&(x.length()>0) ? x.length() : 0的值赋给整型变量y，运行结果y的值是0；而选项B是因为\"==\"两边的类型不匹配，无法比较，所以此表达式是错误的。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":89,
"title":"若a的值为3时，下列程序段被执行后，c的值是______。\nif(a>0)  \n  if(a>3) \n    c = 2;   \n  else c = 3;  \nelse c = 4;",
"optionA":"1",
"optionB":"2",
"optionC":"3",
"optionD":"4",
"answer":"C",
"explain":"    本题考查的是条件语句的使用。\n    由于if总是和最近的else语句配对，又因为a=3，a>0成立，执行{if(a>3) c = 2;  else c = 3;}这一程序段，此时a>3不成立，则执行此处if相对应的else语句，所以c=3。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":90,
"title":"______表达式是声明一个含有10个String对象的数组。",
"optionA":"char str[]; ",
"optionB":"char str[][];",
"optionC":"String str[]= new String[10]; ",
"optionD":"String str[10];",
"answer":"C",
"explain":"    本题考查的是数组的声明方法。\n    数组运算符形式如下：[]可给出数组中某个元素的值。合法的取值范围是从0到数组的长度减1。取值范围的检查只在运行时核实。运算符以String对象实现。如果要声明数组的大小可以使用数字表明大小。但是JAVA语言中不同于C语言格式，因此D使错误的。\n    故本题答案为C。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":91,
"title":"在Java中，所有类的根类是______。",
"optionA":"java.lang.Object",
"optionB":"java.lang.Class ",
"optionC":"java.applet.Applet",
"optionD":"java.awt.Frame",
"answer":"A",
"explain":"    本题考查的是Java的API结构。\n    java.lang.Object是Java中所有类的根类；java.lang.Class是由编译器自动生成的一个伴随每个类的特殊类；java.applet.Applet是所有Applet的父类；java.awt.Frame用于构建GUI中的窗体。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":92,
"title":"\"++\"运算符的操作数个数是______。",
"optionA":"1个 ",
"optionB":"2个 ",
"optionC":"3个 ",
"optionD":"4个 ",
"answer":"A",
"explain":"    本题考查的是运算符。\n    一个操作符利用一个、两个或者三个运算对象来执行了一个函数。只需要一个运算对象的操作符称为单元运算符，例如++是一个单元操作符，它是对运算对象自增1；需要两个运算对象的操作符号称为双元操作符，比如等于号（=）就是一个双元操作符，它指定右边的运算对象赋值给左边的运算对象；而三元操作符需要三个运算对象。JAVA编程语言有一个三元运算符（? :），它是一个简要的if-else语句。 \n    单元操作符支持前缀或者后缀记号：\n    前缀记号是指操作符出现在它的运算对象之前，例如：operator op \/\/前缀记号\n    后缀记号是指运算对象出现在操作符之前，例如：op operator \/\/后缀记号",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":93,
"title":"下列不属于Swing中构件的是______。",
"optionA":"Jpanel",
"optionB":"JTable",
"optionC":"Memu",
"optionD":"JFrame",
"answer":"C",
"explain":"    本题考察的是Swing特性。\n    Swing是AWT的扩展，它提供了许多新的图形界面构件。Swing构件以\"J\"开头。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":94,
"title":"阅读下面程序：\nimport java.io.*;\npublic class TypeTransition{\n   public static void main(String args[]){\n    char a='h';\n    int i=100;\n    int j=97;\n    int aa=a+i;\n    System.out.println(\"aa=\"+aa);\n    char bb=(char)j;\n    System.out.println(\"bb=\"+bb);\n  }\n}\n如果输出结果的第二行为bb=a，那么第一行的输出是______。",
"optionA":"aa=I ",
"optionB":"aa=204",
"optionC":"aa=v",
"optionD":"aa=156",
"answer":"B",
"explain":"    本题考的是基本数据类型及转换。\n    bb是通过强制类型转换，将int型的j转为char型，由bb=a可以知道a=97，所以h由char型转换为int型：h=a+7=104，aa=a+i=104+100=204。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":95,
"title":"请阅读下面程序\nimport java.io.*;\npublic class TypeTransition{\n   public static void main(String args[]){\n     char a='a';\n     int i=100;\n     long y=456L;\n     int aa=a+i;\n     long yy=y-aa;\n     System.out.print(\"aa=\"+aa);\n     System.out.print(\"yy=\"+yy);\n    }\n}\n程序运行结果是______。",
"optionA":"aa=197  yy=259",
"optionB":"aa=177  yy=259 ",
"optionC":"aa=543  yy=288 ",
"optionD":"aa=197  yy=333 ",
"answer":"A",
"explain":"    本题考的是基本数据类型及转换。\n    先将a自动转换为int类型后再运算，在ASCII码中，a对应的值是97，字符型的a转换为整型为97，所以aa=197；然后再将aa转为long类型后再运算，得出yy=456-197=259。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":96,
"title":"在JDK目录中，Java程序运行环境的根目录是______。",
"optionA":"bin ",
"optionB":"demo ",
"optionC":"lib ",
"optionD":"jre ",
"answer":"D",
"explain":"    本题考查的是Java的体系结构。\n    JDK目录结构：\n    bin目录下有编译器、解释器和许多工具（如服务器工具、IDL、package工具和jdb等）；\n    demo目录下有各种演示例子;include目录下是Win32子目录，都是本地方法文件；\n    lib目录下都是库文件；\n    jre目录是Java程序运行环境的根目录，它下面有bin子目录，包括平台所用工具和库的可执行文件和DLL文件。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":97,
"title":"下列语句能给数组赋值而不使用for循环的是______。",
"optionA":"myArray{[1]= \"One\"; [2]= \"Two\"; [3]= \"Three\";}",
"optionB":"String s[5]=new String[]{\"Zero\",\"One\",\"Two\",\"Three\",\"Four\"};",
"optionC":"String s[]=new String[]{\"Zero\",\"One\",\"Two\",\"Three\",\"Four\"}; ",
"optionD":"String s[]=new String[]={\"Zero\",\"One\",\"Two\",\"Three\",\"Four\"}; ",
"answer":"C",
"explain":"    本题考查的是赋初值初始化数组。\n    可以在声明数组的同时，给数组元素赋初值。所赋初值的个数决定数组元素的数目。其格式如下：\n    类型标识符 数组名[]={初值表}\n    初值表是用逗号隔开的初始值。\n    String s[]=new String[]{\"Zero\",\"One\",\"Two\",\"Three\",\"Four\"};\n    该语句声明了一个数组s，其元素类型为String，因为初始值个数为5，所以数组有5个元素，并且5个元素s[0],s[1],s[2],s[3],s[4]的初始值分别为：\"Zero\",\"One\",\"Two\",\"Three\",\"Four\"。这样就不需要使用for循环为数组赋值了。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":98,
"title":"阅读下列代码段\nByteArrayOutputStream bout=new ByteArrayOutputStream();\nObjectOutputStream out=new ObjectOutputStream(bout);\nout.writeObject(this);\nout.close();\n以上代码段的作用是______。",
"optionA":"将对象写入内存 ",
"optionB":"将对象写入硬盘",
"optionC":"将对象写入光盘",
"optionD":"将对象写入文件",
"answer":"A",
"explain":"    本题考查的是Java中包含的输入\/输出流的类。\n    ByteArrayOutputStream，字节数组输出流。这个类将一个字节数组作为输出流。这个用于存储输出数据的内部字节数组长度可以按照需要增长。\n    ObjectOutputStream既继承了OutputStream抽象类，又实现了ObjectOutput接口，这是Java用接口技术代替双重继承例子，其构造方法参数是串行化了的对象。\n    在java.io中，ByteArrayOutputStream是OutputStream的子类，可以直接访问内存。用ByteArrayOutputStream可以向字节数组（缓冲区）写入数据。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":99,
"title":"对鼠标点击按钮操作进行事件处理的接口是______。",
"optionA":"MouseListener",
"optionB":"WindowListener ",
"optionC":"ActionListener",
"optionD":"KeyListener",
"answer":"A",
"explain":"    本题考查的是鼠标事件。\n    在Java中，当用户使用鼠标进行操作时，会产生鼠标事件MouseEvent。对MouseEvent事件的响应是实现MouseListener接口或MouseMotionListener接口，或者是继承MouseApdapter类，来实现MouseApdapter提供的方法。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":100,
"title":"下列语句中，可以作为无限循环语句的是______。",
"optionA":"for(;;){ }",
"optionB":"for(int i=0;i<10000;i++){ }",
"optionC":"while(false){ }",
"optionD":"do{ } while(false);",
"answer":"A",
"explain":"    本题考查的是循环语句。\n    for循环执行时，首先执行初始化操作，然后判断循环条件是否满足，如果满足，则执行循环体中的语句，最后执行迭代部分。完成一次循环后，重新判断循环条件，直到不满足循环条件，则循环结束，所以B选项不是无限循环语句。\n    while循环首先计算循环条件，当条件满足时（布尔表达式为true），才去执行循环体中的语句或代码块，若首次计算条件就不满足（布尔表达式为false），则大括号中的语句或代码块一次都不会被执行，所以C选项不是无限循环语句。\n    do-while结构首先执行循环体，然后计算循环条件，若结果为true，则循环执行大括号中的语句或代码块，直到布尔表达式的结果为false，所以D选项不是无限循环语句。\n    for循环的初始化、终止以及迭代部分都可以为空语句（但分号不能省），三者均为空的时候，相当于一个无限循环。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":101,
"title":"下列方法中，不属于Throwable类的方法是______。",
"optionA":"printMessage ",
"optionB":"getMessage ",
"optionC":"toString ",
"optionD":"fillStackTrace ",
"answer":"A",
"explain":"    本题考查的是Throwable类的方法。\n    Throwable类是Java语言中所有错误和异常类的超类。只有当对象是此类（或其子类之一）的实例时，才能通过Java虚拟机或者Java throw语句抛出。类似地，只有此类或其子类之一才可以是catch子句中的参数类型。选项A中printMessage()方法不是Throwable类的方法；选项B中getMessage()方法用来返回带参数构造函数创建异常时的参数内容；选项C中toString()方法用来返回异常的类名和getMessage()能得到的内容，两者用冒号分隔；选项D中fillStackTrace()方法用在重新抛出异常时对堆栈的跟踪。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":102,
"title":"若定义int a=2,b=2，下列表达式中值不为4的是______。",
"optionA":"a*(++b)",
"optionB":"a*(b++)",
"optionC":"a+b",
"optionD":"a*b",
"answer":"A",
"explain":"    本题考察的是算术运算符和表达式。\n    将增量运算表达式作为其他表达式的操作数使用时，i++与++i是有区别的：i++在使用i之后，使i的值加1，因此执行完i++后，整个表达式的值为i，而i的值变为i+1；++i在使用i之前，使i的值加1，因此执行完++i之后，整个表达式和i的值均为i+1。\n    选项A：a*(++b)=a*(b+1)=2*(2+1)=6；\n    选项B：a*(b++)=a*b=2*2=4；\n    选项C：a+b=2+2=4；\n    选项D：a*b=2*2=4。",
"type":"Java语言中面向对象的特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":103,
"title":"执行下面程序后，输出的正确结果是______。\npublic class Test\n{\n   public static void main(String args[])\n   {\n       System.out.print(100%3);\n       System.out.print(\",\");\n       System.out.print(100%3.0);\n   }\n} ",
"optionA":"1,1  ",
"optionB":"1,1.0  ",
"optionC":"1.0,1",
"optionD":"1.0,1.0",
"answer":"B",
"explain":"    本题考查的是算术运算符。\n    首先说明一点，在Java语言中，取模运算符%，其操作数可以为浮点数。\n    对于二元算术运算符，其表达式结果的类型归纳为以下几类情况：\n    （1）操作数全为整型，那么，只要其中有一个为long型，则表达式结果为long型。\n    （2）两个操作数全是byte型或short型，表达式结果也为int型。\n    （3）操作数为浮点型，只要其中有一个为double型，表达式结果就是double型。\n    （4）两个操作数全是float型或其中一个是float型，而另外一个是整型，则表达式结果为float型。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":104,
"title":"在Java中，以下______约束符是不正确的。",
"optionA":"private",
"optionB":"public",
"optionC":"protected",
"optionD":"friend",
"answer":"D",
"explain":"    本题考查的是Java的修饰符。\n    Java的修饰符包括public，private，protected，friendly，final等。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":105,
"title":"下面标识符中______是不合法的。",
"optionA":"BigMeaninglessName ",
"optionB":"$int",
"optionC":"1 s ",
"optionD":"$1 ",
"answer":"C",
"explain":"    本题考查的是Java标识符。\n    标识符命名规则为：\n    1、标识符是以字母、下划线、美元符（$）作为首字符的字符串序列。在首字符后面可以跟字母、下划线、美元符和数字。\n    2、标识符区分大小写。\n    3、标识符的字符数目没有限制，但为便于阅读和记忆，不宜太长。\n    另外要注意的是Java中有一些标识符是具有专门意义和用途的，不允许作为一般的标识符用，它们是保留字。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":106,
"title":"在编写Java Application程序时，若需要使用到标准输入输出语句，必须在程序的开头写上______语句。",
"optionA":"import java.awt.* ;",
"optionB":"import applet.Applet  ;",
"optionC":"import java.io.* ;",
"optionD":"import java.awt.Graphics ;",
"answer":"C",
"explain":"    本题考查的是文件输入输出库。\n    Java中通过java.io包封装了对文件的各种操作方法，要使用Java对文件进行操作必须包含java.io包。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":107,
"title":"假设有以下代码\nString s= \"hello\";\nString t = \"hello\";\nchar c[] = {'h','e','l','l','o'} ;\n下列选项中返回false的语句是______。",
"optionA":"s.equals(t);",
"optionB":"t.equals(c);",
"optionC":"s==t;",
"optionD":"t.equals(new String(\"hello\")); ",
"answer":"B",
"explain":"本题考查的是比较方法的使用。\n==操作符比较的是操作符两端的操作数是否是同一个对象，而String的equals()方法比较的是两个String对象的内容是否一样，其参数是一个String对象时才有可能返回true，其它对象都返回假。需要指出的是由于s和t并非使用new创建的，他们指向内存池中的同一个字符串常量，因此其地址实际上是相同的（这个可以从反编译一个简单的测试程序的结果得到，限于篇幅不列出测试代码和反编译的分析），因此答案C也是正确的。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":108,
"title":"在Java中，用package语句说明一个包时，该包的层次结构必须是______。",
"optionA":"与文件的结构相同 ",
"optionB":"与文件目录的层次相同 ",
"optionC":"与文件类型相同 ",
"optionD":"与文件大小相同",
"answer":"B",
"explain":"    本题考查的是包的使用。\n    包的层次结构必须与文件目录的层次相同。如定义一个包：package com.wuyou，则包含该package语句的源文件须放在名为wuyou的文件夹下，而文件夹wuyou的父文件夹必须是com。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":109,
"title":"在switch(expression)语句中，expression的数据类型不能是______。",
"optionA":"double",
"optionB":"char ",
"optionC":"byte ",
"optionD":"short ",
"answer":"A",
"explain":"    本题考查的是多分支语句。\n    表达式expression只能返回这个几种类型的值：int、byte、short和char。多分支语句把表达式返回的值依次与每个case子句中的值相比较，如果遇到匹配的值，则执行该case子句后的语句序列。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":110,
"title":"下列方法中，不属于windowListener接口的是______。",
"optionA":"windowopened( ) ",
"optionB":"windowClosed( )",
"optionC":"windowActivated( )",
"optionD":"windowActivated( )",
"answer":"D",
"explain":"    本题考察的是windowListener 接口。\n    mouseDragged( )属于鼠标监听接口。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":111,
"title":"阅读下面程序\npublic class OperatorsAndExpressions{\n   void equalsMethod1(){\n      String s1=new String(\"how are you\");\n      String s2=new String(\"how are you\");\n      System.out.println(s1==s2);\n  }\n  public static void main(String args[]){\n     OperatorsAndExpressions OperAndExp=new OperatorsAndExpressions();\n     \/\/用于复合类型数据的\"==\"运算符\n     OperAndExp.equalsMethod1();\n  }\n}\n程序运行结果是______。",
"optionA":"==",
"optionB":"true ",
"optionC":"false ",
"optionD":"equal",
"answer":"C",
"explain":"    本题考的是复合类型数据的\"==\"运算符。\n    对于复合数据类型数据的\"==\"运算，其作用是比较两个操作数是否是同一个对象，在题目中就是要比较s1和s2是否为同一个对象，虽然s1和s2的值都是\"how are you\"，但是它们却是不同的对象，因此\"==\"运算后的结果是flase。如果需要比较两个对象的值是否相同，则可以调用equals()方法。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":112,
"title":"请阅读下面程序\npublic class OperatorsAndExpressions{\n  void residual(){\n     int i=100,j=30;\n     float m=563.5f,n=4.0f;\n     System.out.println(i%j);\n     System.out.println(m%n);\n}\npublic static void main(String args[]){\n   OperatorsAndExpressions OperAndExp=new OperatorsAndExpressions();\n   \/\/取模运算符在整数和浮点数中的应用\n   OperAndExp.residual();}}\n程序运行结果是______。",
"optionA":"10\n3.5 ",
"optionB":"20\n2.5 ",
"optionC":"10\n4.5 ",
"optionD":"20\n3.5 ",
"answer":"A",
"explain":"    本题考的是算术运算符。\n    在Java语言中，二元算术运算符包括取模运算符%。\n    对于二元算术运算符，其表达式结果的类型归纳为以下几类情况：\n    （1）操作数全为整型，那么，只要其中有一个为long型，则表达式结果为long型。\n    （2）两个操作数全是byte型或short型，表达式结果也为int型。\n    （3）操作数为浮点型，只要其中有一个为double型，表达式结果就是double型。\n    （4）两个操作数全是float型或其中一个是float型，而另外一个是整型，则表达式结果为float型。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":113,
"title":"阅读下面程序\npublic class ConcatTest{\n    public static void main(String[] args){\n        String strl = \"abc\";\n        String str2 = \"ABC\";\n        String str3 = strl.concat(str2);\n        System.out.println(str3);\n    }\n}\n程序的运行结果是______。",
"optionA":"abc ",
"optionB":"ABC ",
"optionC":"abcABC",
"optionD":"ABCabc",
"answer":"C",
"explain":"    本题考查的是字符串的连接。\n    字符串连接函数concat(String str)的作用是将当前字符串对象与指定str字符串相连；本题中\"strl.concat(str2)\"是指将str1字符串与str2字符串相连，所以程序的运行结果是\"abcABC\"。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":114,
"title":"Swing与AWT相比新增的布局管理器是______。",
"optionA":"CardLayout ",
"optionB":"GridLayout ",
"optionC":"GridBagLayout ",
"optionD":"BoxLayout ",
"answer":"D",
"explain":"    本题考查的是布局管理器。\n    Swing继续沿用AWT中的布局管理器，包括FlowLayout、BorderLayout、CardLayout、GridLayout、GridBagLayout，另外Swing新增加了一个BoxLayout布局管理器。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":115,
"title":"下列不属于Swing构件的是______。",
"optionA":"JMenu ",
"optionB":"JApplet ",
"optionC":"JOptionPane ",
"optionD":"Panel ",
"answer":"D",
"explain":"    本题考查的是Swing构件和容器。\n    Swing中的大多数构件都是AWT构件名前面加了一个\"J\"。\n    Swing构件分类（从功能上）：\n    1、顶层容器，JFrame、JApplet、JDialog和JWindow共4个。\n    2、中间容器，JPanel、JScrollPane、JSplitPane、JToolBar。\n    3、特殊容器，在GUI上起特殊作用的中间层，如JInternalFrame、JLayeredPane、JRootPane。\n    4、基本控件，实现人机交互的构件，如Jbutton、JComboBox、JList、JMenu、JSlider、JtextField。\n    5、不可编辑信息的显示，向用户显示不可编辑信息的构件，例如JLabel、JProgressBar、ToolTip。\n    6、可编辑信息的显示，向用户显示能被编辑的格式化信息的构件，如JColorChooser、JFileChooser、JFileChooser、JTable、JTextArea。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":116,
"title":"AWT中用来表示颜色的类是______。",
"optionA":"Font",
"optionB":"Color ",
"optionC":"Panel",
"optionD":"Dialog",
"answer":"B",
"explain":"    本题考查的是AWT。\n    Java语言是通过AWT（抽象窗口化工具包）和Java基础类（JFC或更常用的Swing）来提供这些GUI部件的。\n　　其中Java.awt是最原始的GUI工具包，存放在java.awt包中。现在有许多功能被已被Swing取代并得到了很大的增加与提高，因此一般很少再使用Java.awt，但是AWT中还是包含了最核心的功能，通常，一个Java的GUI程序至少还要使用下面几个类：\n    java.awt.Color：基本颜色定义\n    java.awt.Font：基本字体定义\n    java.awt.Cursor：光标操作定义",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":117,
"title":"下列表达式中，类型可以作为int型的是______。",
"optionA":"abc+\"efg\"",
"optionB":"\"abc\"+'efg' ",
"optionC":"a'+'b' ",
"optionD":"3+\"4\"",
"answer":"C",
"explain":"    本题考查的是基本数据类型及转换。\n    在Java语言中，使用\"+\"将两个字符串连接起来，所以表达式：\"abc\"+\"efg\"的结果是\"abcefg\"，所以A选项不能作为int类型；字符常量是用单引号括起来的一个字符，如'a'、'b'，用双引号括起来的是字符串，例如\"abc\"、\"efg\"，所以B选项不能作为int类型；在Java中，String类型是作为一个对象存在的，字符串类型和整型在没有强制类型转换的情况下，不能直接做运算操作，所以D选项不是正确答案；char类型的值可以转换成int类型，'a'+'b'相当与'a'的ASCII码值与'b'的ASCII码值相加，所以C选项正确。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":118,
"title":"下列程序的输出结果是______。\npublic class Test {\n  public static void main(String[] args){\n      int [] array={2,4,6,8,10};\n      int size=6;\n      int result=-1;\n      \n      try {\n        for(int i=0;i<size && result==-1;i++)\n          if(array[i]==20) result = i;\n      }\n      catch(ArithmeticException e){\n         System.out.println(\"Catch---1 \");\n      }\n      catch(ArrayIndexOutOfBoundsException e){\n         System.out.println(\"Catch---2 \");\n      }\n      catch(Exception e){\n         System.out.println(\"Catch---3\");\n  }\n}",
"optionA":"Catch---1 ",
"optionB":"Catch---2",
"optionC":"Catch---3 ",
"optionD":"以上都不对 ",
"answer":"D",
"explain":"    本题考查的是Java程序结构。\n    Java使用try语句包括可能抛出异常的代码段，用catch语句指明要捕获的异常相应的处理代码。Java预定义了一些常见异常类，如：\n    ①ArithmeticException，算术异常，如整数除法中，如果除数为0，则发生该类异常；\n    ②ArrayIndexOutofBoundsException，数组索引越界异常，当对数组的索引值为负数或大于等于数组大小时抛出。但是本题程序中缺少一个\"}\"，所以程序编译不通过，更无法运行。如果加上\"}\"则本题程序执行到第i=6次循环时，会发生数组下标越界异常，即输出：Catch---2。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":119,
"title":"下列可以获得构件前景色的方法是______。",
"optionA":"getSize() ",
"optionB":"getForeground() ",
"optionC":"getBackground()",
"optionD":"paint() ",
"answer":"B",
"explain":"    本题考察的是构件和容器。\n    java.awt.Component类中封装了构件通用的方法和属性，如图形的构件对象、大小、显示位置、前景色和背景色、边界、可见性等。其中，getSize()获得构件的大小；getForeground()获得构件的前景色；getBackground()获得构件的背景色；paint(Graphics g)绘制构件。",
"type":"面向对象编程的基本概念和特征",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":120,
"title":"下列赋值语句中错误的是______。",
"optionA":"float f=11.1f;",
"optionB":"double d=5.3E12;",
"optionC":"char c='\\r';",
"optionD":"byte bb=433;",
"answer":"D",
"explain":"    本题考查的是赋值运算符。\n    赋值运算符（=）把一个表达式赋给一个变量，在赋值运算符两侧不一致的情况下，如果左侧变量类型的级别高，则右侧的数据被转化为与左侧相同级别的数据类型后赋给左侧变量；否则，需要使用强制类型转换运算符。\n    本题中选项D右侧433为int型，而左侧是比它级别低的byte型，且byte型的数据范围是-128～+127，所以此选项不正确。",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":121,
"title":"以下代码段执行后的输出结果为______。\nint  x=3；\nint  y=10；\nSystem.out.println(y%x);",
"optionA":"1.0",
"optionB":"1",
"optionC":"3",
"optionD":"3.0",
"answer":"B",
"explain":"    本题考查的是算术运算符。\n    首先说明一点，在Java语言中，取模运算符%，其操作数可以为浮点数。\n    对于二元算术运算符，其表达式结果的类型归纳为以下几类情况：\n    （1）操作数全为整型，那么，只要其中有一个为long型，则表达式结果为long型。\n    （2）两个操作数全是byte型或short型，表达式结果也为int型。\n    （3）操作数为浮点型，只要其中有一个为double型，表达式结果就是double型。\n    （4）两个操作数全是float型或其中一个是float型，而另外一个是整型，则表达式结果为float型。\n    由于本题的操作数x,y全为整型，所以表达式结果也为int类型。",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":122,
"title":"下列______是反斜杠字符的正确表示。",
"optionA":"\\\\",
"optionB":"*\\\\",
"optionC":"\\",
"optionD":"\\'\\'",
"answer":"A",
"explain":"    本题考查的是转义字符。\n    Unicode字符集中对一些字符必须用转义字符。转义字符以反斜杠(\\)开头，如\"\\n\"表示换行符，\"\\\\\"表示反斜杠。",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":123,
"title":"Java是______公司提出来的。",
"optionA":"Microsoft ",
"optionB":"Sun ",
"optionC":"IBM ",
"optionD":"Oracel ",
"answer":"B",
"explain":"    本题考查的是Java的历史。\n    Java来自于Sun公司的一个叫Green的项目，其原先的目的是为家用消费电子产品开发一个分布式代码系统，这样我们可以把E-mail发给电冰箱、电视机等家用电器，对它们进行控制，和它们进行信息交流。开始，准备采用C++,但C++太复杂，安全性差，最后基于C++开发一种新的语言Oak(Java的前身)，Oak是一种用于网络的精巧而安全的语言，Sun公司曾依此投标一个交互式电视项目，但结果是被SGI打败。可怜的Oak几乎无家可归，恰巧这时MarkArdreesen开发的Mosaic和Netscape启发了Oak项目组成员，他们用Java编制了HotJava浏览器，得到了Sun公司首席执行官ScottMcNealy的支持，触发了Java进军Internet。Java的取名也有一个趣闻，有一天，几位Java成员组的会员正在讨论给这个新的语言取什么名字，当时他们正在咖啡馆喝着Java(爪哇)咖啡，有一个人灵机一动说就叫Java怎样，得到了其他人的赞赏，于是，Java这个名字就这样传开了。",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":124,
"title":"欲构造ArrayList类的一个实例，此类实现了List接口，下列______方法是正确的。",
"optionA":"ArrayList myList=new Object( );",
"optionB":"List myList=new ArrayList( ); ",
"optionC":"ArrayList myList=new List( ); ",
"optionD":"List myList=new List( );  ",
"answer":"B",
"explain":"本题考查的是类的使用。\n不能直接建立接口的实例，只能通过实现接口的相应的类来实现接口。",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":125,
"title":"在读字符文件Employee.dat时，使用该文件作为参数的类是______。",
"optionA":"BufferedReader",
"optionB":"DataInputStream",
"optionC":"DataOutputStream",
"optionD":"FileInputStream",
"answer":"D",
"explain":"    本题考查的是文件和文件I\/O。\n    BufferedReader用来从字符输入流中读取并缓冲字符，以提高读取字符（或字符数组）的效率。其构造方法为：\n    public BufferedReader(Reader in)\n    public BufferedReader(Reader in, int sz)\n    DataInputStream用来以独立于机器的方式从潜在的输入流中读取Java基本数据类型。构造方法为：\n    DataInputStream(InputStream in) \n    FileInputStream用来从文件中读取字节。构造方法为：\n    FileInputStream(String name) \n    FileInputStream(File file) ",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":126,
"title":"下列叙述中，错误的是______。",
"optionA":"父类不能替代子类",
"optionB":"子类能够替代父类 ",
"optionC":"子类继承父类",
"optionD":"父类包含子类",
"answer":"D",
"explain":"    本题考查的是类之间的关系。\n    通过继承实现代码复用：\n    Java中所有的类都是通过直接或间接地继承java.lang.Object类得到的。继承而得到的类称为子类，被继承的类称为父类。子类不能继承父类中访问权限为private的成员变量和方法，子类可以重写父类的方法，及命名与父类同名的成员变量。\n    子类通过隐藏父类的成员变量和重写父类的方法，把父类的状态和行为改变为自身的状态和行为。注意：子类中重写的方法和父类中被重写的方法要具有相同的名字，相同的参数表和相同的返回类型，只是函数体不同。\n    由于子类继承了父类所有的属性（私有的除外），所以子类对象可以作为父类对象使用。程序中凡是使用父类对象的地方，都可以用子类对象来代替。一个对象可以通过引用子类的实例来调用子类的方法。\n    java运行时系统根据调用该方法的实例，来决定调用哪个方法。对子类的一个实例，如果子类重写了父类的方法，则运行时系统调用子类的方法；如果子类继承了父类的方法（未重写），则运行时系统调用父类的方法。",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":127,
"title":"下列语句中，属于多分支语句的是______。",
"optionA":"if语句 ",
"optionB":"switch语句 ",
"optionC":"do-while语句 ",
"optionD":"for语句 ",
"answer":"B",
"explain":"    本题考察的是分支语句的概念。\n    分支语句可以分为以下两种语句：\n    1、条件语句。\n    条件语句根据判定条件的真假来决定执行哪一种操作。有两种结构：\n    （1）if结构；\n    （2）if - else结构\n    2、多分支语句。\n    Java语言提供了多分支语句switch。Switch语句根据表达式的值从多个分支中选择一个来执行，它的一般格式为：\nswitch (expression)\n{\n case value1:    statement1;\n break;\n case value2: statement2;\n break;\n .\n .\n .\n case valueN: statementN;\n break;\n [default: defaultStatement;]\n}",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":128,
"title":"阅读下面代码\nif(x==0){System.out.println(\"冠军\");}\n   else if(x>-3){System.out.println(\"亚军\");}\n       else{System.out.println(\"季军\");}\n若要求打印字符串\"季军\"，则变量x的取值范围是______。",
"optionA":"x=0&x<=-3",
"optionB":"x>0",
"optionC":"x>-3",
"optionD":"x<=-3",
"answer":"D",
"explain":"    本题考的是条件语句。\n    当x的值等于0时，输出\"冠军\"；当x的值大于-3时，输出\"亚军\"；其余情况输出\"季军\"，所以只有在小于等于-3的情况下，才符合输出\"季军\"的条件。",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":129,
"title":"请阅读下面程序\npublic class ForLoopStatement{\n  public static void main(String[] args){\n    int i,j;\n    for(i=1;i<5;i++){       \/\/i 循环\n        for(j=1;j<=i;j++)   \/\/j 循环\n            System.out.print(i+\"×\"+j+\"=\"+i*j+\" \");\n    System.out.println();\n    }\n  }\n}\n程序完成后，i循环和j循环执行的次数分别是______。",
"optionA":"4，10 ",
"optionB":"8，9",
"optionC":"9，8",
"optionD":"10，10",
"answer":"A",
"explain":"    本题考的是循环语句。\n    外层FOR循环控制每循环一次i的值加1，因为要求i<5，所以i=4循环执行后跳出循环，内部FOR循环以j为循环变量，i的值为终止条件，所以外层循环变量i每增加1，内层循环运行的次数比较前次增加1。程序运行结果为：\n1×1=1\n2×1=2 2×2=4\n3×1=3 3×2=6 3×3=9\n4×1=4 4×2=8 4×3=12 4×4=16",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":130,
"title":"下列运算符中属于关系运算符的是______。",
"optionA":"==",
"optionB":"=",
"optionC":"+=",
"optionD":"-=",
"answer":"A",
"explain":"    本题考查的是运算符。\n    运算符表示各种不同运算的符号。\n    按运算符的功能分，可以分为：\n    （1）算术运算符：+，-，*，\/，%，++，--\n    （2）关系运算符：>，<，>=，<=，==，!=\n    （3）布尔逻辑运算符：!，&&，‖\n    （4）位运算符：>>，<<，>>>，&，︱，^，~\n    （5）赋值运算符=，及其扩展赋值运算符\n    （6）条件运算符?:\n    （7）其他：包括分量运算符·，下标运算符[]，实例运算符instanceof，内存分配运算符new，强制类型转换运算符(类型)，方法调用运算符()等。",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":131,
"title":"下列语句中正确的是______。",
"optionA":"System.out.println(1+'1');",
"optionB":"int i=2+\"2\"; ",
"optionC":"String s=\"on\"+'one';",
"optionD":"byte b=257;",
"answer":"A",
"explain":"    本题考查的是语句。\n    选项A是一个输出语句，输出结果是：字符1对应的ASCII码的值（值为49）加1，即：50。\n    选项B语句中包含一个算术表达式，在算术表达式中，操作数只能是整型或浮点型数据，而表达式中的\"2\"为字符串类型，所以该选项错误；\n    JAVA允许将字符串用+号连接起来，但是选项C中one是用单引号括起来的，不能算字符串，所以C选项错误；\n    选项D中，变量b的数据类型为byte型，只有8位，能表示数据的范围为-128~+127，而257已超过byte型所能表示的数据范围，故D选项错误。",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":132,
"title":"下列不是AWT的布局管理器的是______。",
"optionA":"FlowLayout ",
"optionB":"BorderLayout",
"optionC":"BoxLayout",
"optionD":"GridLayout",
"answer":"C",
"explain":"    本题考查的是布局管理器。\n    AWT布局管理器的相关类主要包括：FlowLayout、GridLayout、CardLayout、GridBagLayout等。BoxLayout是Swing新增加的一个布局管理器。",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":133,
"title":"JAVA语言中属于跳转语句的是______。",
"optionA":"try ",
"optionB":"catch ",
"optionC":"finally ",
"optionD":"break ",
"answer":"D",
"explain":"    本题考查的是跳转语句。\n    跳转语句包括：break语句、continue语句、return语句。",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":134,
"title":"阅读下列程序\npublic class Test implements Runnable{\n  private int x=0;\n  private int y=0;\n  boolean flag=true;\n  public static void main(String[] args){\n     Test r=new Test();\n     Thread t1=new Thread(r);\n     Thread t2=new Thread(r);\n     t1.start();\n     t2.start();\n  }\n  public void run(){\n     while(flag){\n        x++;\n        y++;\n        System.out.println(\"(\"+x+\",\"+y+\")\");\n        if(x>=10)\n          flag=false;\n     }\n  }\n}\n下列对程序运行结果描述的选项中，正确的是______。",
"optionA":"每行的(x,y)中，可能有x≠y；每一对(x,y)值都出现两次。 ",
"optionB":"每行的(x,y)中，可能有x≠y；每一对(x,y)值仅出现一次。 ",
"optionC":"每行的(x,y)中，x=y；每一对(x,y)值都出现两次。 ",
"optionD":"每行的(x,y)中，x=y；每一对(x,y)值仅出现一次。 ",
"answer":"B",
"explain":"    本题考查的是线程与对象串行化。\n    在本程序中，Test类实现了Runnable接口，在main()方法中，以Test类的两个实例对象分别创建了t1、t2两个线程，并调用线程的start()方法将线程启动。在创建的线程中，Test类的run()方法就是线程体，当main()方法中的t1、t2启动时，是从Test类对象的run()开始执行的。\n    在Test类中首先用private定义了两个int类型的私有成员变量x、y，并为其赋初值x=0，y=0，并定义了一个boolean类型的变量flag。在run()方法中，使用while循环来控制输出，while循环的判断条件就是布尔型变量flag，当flag=true时，执行循环体，直到x>=10时，程序执行语句flag=false;退出整个循环，run()方法运行结束。\n    变量XY是程序外部定义的，所以每一对(x,y)值仅出现一次。t1与t2两个线程运行的先后顺序不一定，所以可能有x≠y。",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":135,
"title":"下列包中，包含JOptionPane类的是______。",
"optionA":"javax.swing ",
"optionB":"java.lang ",
"optionC":"java.util ",
"optionD":"java.applet",
"answer":"A",
"explain":"    本题考查的是Swing基本组件JOptionPane类。\n    JOptionPane类有助于方便地弹出要求用户提供值或向其发出通知的标准对话框。javax.swing包中包含JOptionPane类。",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":136,
"title":"下列程序的运行结果是______。\n  public class test {\n      private String[] data={\"10\",\"10.5\"};\n      public void fun () {\n          double s = 0;\n          for (int i = 0;i < 3; i++) {\n              try{\n                  s = s + Integer.parseInt(data[i]);\n              }catch (Exception e) {\n              System.out.print(\"error1: \"+data[i]);\n              }\n          }\n      }\n      public static void main(String[] args) {\n          try {\n              test d=new test();\n              d.fun();\n          } catch (Exception e){\n              System.out.println(\" error2\");\n          }\n      }\n  }",
"optionA":"erro1: 10.5 ",
"optionB":"error2 ",
"optionC":"error1: 10.5 error2 ",
"optionD":"以上都不对",
"answer":"C",
"explain":"    本题考察的是异常处理。\n    本题程序运行时将依次产生两次异常。\n    第一次异常产生在执行fun()函数中的\"Integer.parseInt(data[i])\"语句时，将产生数组下标越界异常和类型转换异常，被fun()方法内的catch语句所捕获，显示输出：error1: 10.5。\n    第二次异常在执行\"System.out.print(\"error1: \"+data[i]);\"语句时产生，为数组下标越界异常，被主函数内的catch所捕获，显示输出：error2。",
"type":"类的基本组成和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":137,
"title":"给出下面程序段：\nif(x>0){System.out.println(\"Hello.\");}\nelse if(x>-3){System.out.println(\"Nice to meet you!\");}\n     else{System.out.println(\"How are you?\");}\n若打印字符串\"How are you?\"，则x 的取值范围是______。 ",
"optionA":"x>0 ",
"optionB":"x>-3 ",
"optionC":"x<=-3",
"optionD":"x<=0&x>-3 ",
"answer":"C",
"explain":"    本题考查的是条件语句。\n    if-else if结构：\n    if(条件1)\n        statement1;或{block1}\n    else if(条件2)\n        statement2;或{block2}\n    ……\n    else if(条件N)\n        statementN;或{blockN}\n   [else \n    statementN+1;或{blockN+1}]\n    执行过程如下：\n    判断条件1：结果为真，执行statement1;或{block1}，执行完直接跳到statementN+1;或{blockN+1}下面的语句继续执行；结果为假，判断条件2：结果为真，执行statement2;或{block2}，执行完直接跳到statementN+1;或{blockN+1}下面的语句继续执行；结果为假，判断条件3……判断条件N：结果为真，执行statementN;或{blockN}，否则执行statementN+1;或{blockN+1}。\n    本题当x>0，输出Hello；\n          x<=0，判断第一个else后面的if条件；\n          x<=0&x>-3，输出Nice to meet you!；\n          x<=-3，输出How are you?",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":138,
"title":"设 x = 1 , y = 2 , z = 3，则表达式 y+＝z--\/++x 的值是______。",
"optionA":"3",
"optionB":"3.5",
"optionC":"4",
"optionD":"5",
"answer":"A",
"explain":"    本题考查的是表达式的运算。\n    增量运算符\"++\"是将操作数加1。对++x与x++的运算结果均为x=x+1，但若将增量运算表达式再作为其他表达式的操作数使用时，i++与++i是有区别的：i++在使用i之后，使i的值加1，因此执行表达式时是以i的值参加表达式的运算的，执行完后，i本身的值变为i+1；而++i是在使用i之前，使i的值加1，因此执行表达式时是以i+1的值参加运算的，执行完后i自身的值也为i+1。\n    另外，对于二元算术运算符\"\/\"，其表达式结果的类型归纳为以下几类情况：\n    （1）操作数全为整型，那么，只要其中有一个为long型，则表达式结果为long型。\n    （2）两个操作数全是byte型或short型，表达式结果也为int型。\n    （3）操作数为浮点型，只要其中有一个为double型，表达式结果就是double型。\n    （4）两个操作数全是float型或其中一个是float型，而另外一个是整型，则表达式结果为float型。\n    对一个复杂表达式进行运算时，要按运算符的优先顺序从高到低进行，同级的运算符则按照在表达式中出现的位置从左到右的方向进行。\n    本题y+＝z--\/++x由于++的运算优先级高于\/，所以表达式即为y=2+3\/2，固表达式值为3。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":139,
"title":"下列程序段的输出是______。\npublic class Test5{\n    public static void main(String args[]){ \n        String ss1=new String(\"hello\");\n        String ss2=new String(\"hello\");\n        System.out.println(ss1==ss2);\n        System.out.println(ss1.equals(ss2));\n    }\n}",
"optionA":"true,false ",
"optionB":"true,true ",
"optionC":"false,true ",
"optionD":"false,false ",
"answer":"C",
"explain":"    本题考查的是字符串对象的比较运算。\n    对于复合数据类型的数据的\"==\"运算，其比较目标是两个操作数是否是同一个对象。若需要比较两个对象的值是否相同，则用equals()方法，equals()是Object的方法，和\"==\"一样，功能是比较两个操作数是否是同一个对象，但类库中许多子类重写了equals()方法，使其变为比较两个操作数的内容是否一样。例如String类就对equals()方法进行了修改。\n    本题ss1与ss2并非是同一个对象，所以ss1==ss2的值为false；但对象ss1与ss2的值都为hello，所以表达式ss1.equals(ss2)的值为true。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":140,
"title":"执行代码：\nm = 1;  \nwhile( m++ < 2 ) \nSystem.out.println( m );\n最后的输出是______。",
"optionA":"0",
"optionB":"1",
"optionC":"2",
"optionD":"Nothing and an exception is thrown ",
"answer":"C",
"explain":"    本题考查的是循环语句及++运算符。\n    增量运算符\"++\"是将操作数加1。对++x与x++的运算结果均为x=x+1，但若将增量运算表达式再作为其他表达式的操作数使用时，i++与++i是有区别的：i++在使用i之后，使i的值加1，因此执行表达式时是以i的值参加表达式的运算的，执行完后，i本身的值变为i+1；而++i是在使用i之前，使i的值加1，因此执行表达式时是以i+1的值参加运算的，执行完后i自身的值也为i+1。\n    由于m=1因此在执行一次while语句，判断条件成立后m=2，这时输出的结果m的值是2.而这时2<2为假，不再执行输出，因此输出的结果是2。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":141,
"title":"paint()方法使用______类型的参数。",
"optionA":"Graphics ",
"optionB":"Graphics2D ",
"optionC":"String ",
"optionD":"Color ",
"answer":"A",
"explain":"本题考查的是Applet中paint方法的参数。\n    paint()方法：Applet的paint()方法具体执行Applet的绘制，该方法定义如下：\n    public void paint(Graphics g)\npaint()方法只有一个参数g是Graphics类的实例，该实例对象由浏览器生成，它包含了Applet的图形上下文信息，通过它向Applet中显示信息，该对象相当于Applet的画笔。在调用paint()方法时，由浏览器将该对象传递给paint()方法。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":142,
"title":"下列构造方法的调用方式中，正确的是______。",
"optionA":"按照一般方法调用",
"optionB":"由用户直接调用",
"optionC":"只能通过new自动调用",
"optionD":"被系统调用",
"answer":"C",
"explain":"    本题考查的是类的定义。\n    构造方法用来初始化对象，其方法名必须与类名相同且只能通过new自动调用。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":143,
"title":"已知：int[] a=new int[100];在下列给出的数组元素中，非法的是______。",
"optionA":"a[0]  ",
"optionB":"a[1]  ",
"optionC":"a[99]  ",
"optionD":"a[100]  ",
"answer":"D",
"explain":"    本题考查的是数组的定义。\n    数组元素类似于单个变量，可以自由地存取。各个数组元素都由该元素在数组中的位置唯一地确定，这一位置称为下标。因此题中第一个元素下标为0，元素表示成a[0]；第二个元素下标为1，元素表达成a[1]；第100个元素下标为99，元素表示成a[99]。请注意，Java语言中数组元素下标是从0开始而非从1开始，数组的下标必须在定义数组时规定的长度界限内。a[100]已经是第101个元素了，属于非法的。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":144,
"title":"阅读下列代码 \npublic class Test2005 \n{ \n   public static void main( String args[])\n  { \n    String s=\"Test\"; \n    switch(s)\n    { \n      case \"Java\": System.out.print(\"Java\");\n      break; \n      case \"Language\": System.out.print(\"Language\");\n      break;\n      case \"Test\":System.out.print(\"Test\");\n      break;\n    } \n  } \n} \n其运行结果是______。",
"optionA":"Java ",
"optionB":"Language",
"optionC":"Test",
"optionD":"编译出错 ",
"answer":"D",
"explain":"    本题考察的是switch语句。\n    对switch语句说明如下：\n    1、表达式expression只能返回这几种类型的值：int , byte , short 和char。\n    2、case子句中的值valueN必须是常量，而且所有case子句中的值应是不同的。\n    3、default子句是任选的。\n    4、break语句用来在执行完一个case分支后，使程序跳出switch语句的执行。\n    5、case分支中包含多条语句（即statement为一连串语句序列）时，可以用大括号{}括起。\n    switch语句的功能可以用if - else结构来实现。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":145,
"title":"下列关于构造方法的叙述中，错误的是______。",
"optionA":"Java语言规定构造方法名与类名必须相同",
"optionB":"Java语言规定构造方法没有返回值，但不用void声明",
"optionC":"Java语言规定构造方法不可以重载",
"optionD":"Java语言规定构造方法只能通过new自动调用",
"answer":"C",
"explain":"    本题考的是构造方法的概念。\n    构造方法可以重载实现不同的初始化方法，使类的实例有多种初值，调用时按参数决定调用哪个方法。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":146,
"title":"下列叙述中，错误的是______。",
"optionA":"Java中，方法的重载是指多个方法可以共享同一个名字",
"optionB":"Java中，用abstract修饰的类称为抽象类，它不能实例化 ",
"optionC":"Java中，接口是不包含成员变量和方法实现的抽象类 ",
"optionD":"Java中，构造方法可以有返回值 ",
"answer":"D",
"explain":"    本题考的是面向对象的程序设计概念。\n    构造方法属于特殊的一种方法，它的主要作用是初始化对象的成员变量。构造方法前面没有返回类型定义，也就是说它没有返回值，也不是void。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":147,
"title":"下列语句中执行跳转功能的语句是______。",
"optionA":"for语句 ",
"optionB":"while语句",
"optionC":"continue语句",
"optionD":"switch语句",
"answer":"C",
"explain":"    本题考查的是java流程控制中的跳转语句。\n    在java中，执行跳转功能的语句有：break语句、continue语句、return语句，其中continue语句的功能是跳过循环体中下面尚未执行的语句，回到循环体的开始，继续下一轮的循环。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":148,
"title":"下列关键字中可以表示常量的是______。",
"optionA":"final",
"optionB":"default",
"optionC":"private",
"optionD":"transient",
"answer":"A",
"explain":"    本题考查的是JAVA关键字。\n    对于基本类型前加以final修饰，表示被修饰的变量为常数，不可以修改。final的变量如果没有赋予初值的话，其他方法就必需给他赋值，但只能赋值一次。这个关键字并不是很难理解，final的英文意思是\"最终的\"，它修饰了什么东西都是最终的，不可以改变的，效率也比较高。\n    default关键字用来标记switch语句中的默认分支。\n    private关键字是访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。\n    transient关键字可以应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":149,
"title":"子类继承了父类的方法和状态，在子类中可以进行的操作是______。",
"optionA":"更换父类方法",
"optionB":"减少父类方法",
"optionC":"减少父类变量",
"optionD":"增添方法",
"answer":"D",
"explain":"    本题考查的是继承。\n    继承性是面向对象方法的一个重要基本特征。Java语言中，对一个类的继承是指在现有类（父类）的基础上构建一个新类（子类），子类重用（继承）了父类的方法和状态，同时还可以向新类中增添新的方法和状态。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":150,
"title":"阅读下列利用递归来求n!的程序\nclass FactorialTest{\n    static long Factorial(int n){\/\/定义Factorial( )方法\n        if (n==1)\n            return 1;\n        else\n            return n* Factorial(______);\n    }\n    public static void main(String a[]){\/\/main( )方法\n        int n=8;\n        System.out.println(n+ \"!=\"+Factorial(n));\n    }\n}\n为保证程序正确运行，在下划线处应该填入的参数是______。",
"optionA":"n-1 ",
"optionB":"n-2",
"optionC":"n",
"optionD":"n+1 ",
"answer":"A",
"explain":"    本题考查的是递归调用。\n    所谓递归就是用自身的结构来描述自身。一个使用递归技术的方法将直接或间接地调用自身的方法。\n    根据阶乘的概念，可以写出其递归定义：\n    Factorial(n=1)    n=1\n    n*Factorial(n-1)  n>1\n    递归结构主要包括两部分：定义递归头和定义当前问题的同一性质的简化。例如n!这个问题被划分为求(n-1)!与n相乘两个步骤；同理，求(n-1)!的问题被简化为求(n-2)!与(n-1)相乘两个步骤的问题，依此类推，直到求Fac(1)，再逐级返回，依次求得Fac(1)、Fac(2)…Fac(n)。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":151,
"title":"如果线程正处于运行状态，则它可能到达的下一个状态是______。",
"optionA":"只有终止状态",
"optionB":"只有阻塞状态和终止状态 ",
"optionC":"可运行状态，阻塞状态，终止状态",
"optionD":"其他所有状态",
"answer":"C",
"explain":"    本题考查的是线程状态与生命周期。\n    运行状态是线程占有CPU并实际运行的状态，此时线程状态的变迁有3种情况：终止状态、可运行状态、阻塞状态。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":152,
"title":"下列选项中，与成员变量共同构成一个类的是______。",
"optionA":"关键字",
"optionB":"方法",
"optionC":"运算符",
"optionD":"表达式",
"answer":"B",
"explain":"    本题考查的是类的基本组成。\n    类有两种基本成分：变量和方法，称为成员变量和成员方法。类的成员变量可以是基本类型的数据或数组，也可以是一个类的实例；类的成员方法用于处理该类的数据。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":153,
"title":"下列程序片段中，能通过编译的是______。",
"optionA":"public abstract class Animal {\n   public void speak(); } ",
"optionB":"public abstract class Animal {\n   public void speak() {} } ",
"optionC":"public class Animal {\n   public abstract void speak(); } ",
"optionD":"public abstract class Animal {\n   public abstract void speak() {} } ",
"answer":"B",
"explain":"    本题考察的是abstract修饰符的使用。\n    abstract修饰符用来修饰类和成员方法：\n    ①用abstract修饰的类表示抽象类，抽象类不能被实例化。\n    ②用abstract修饰的方法表示抽象方法，抽象方法没有方法体。\n    抽象类可以没有抽象方法，但是有抽象方法的类必须定义为抽象类。\n    选项中A中，方法speak()若作为一般成员方法则缺少方法主体，若作为抽象方法则需要使用abstract修饰符来声明。选项C中，类Animal包含了一个抽象方法，因此Animal必须使用abstract修饰符定义为抽象类。选项D中，抽象方法speak()不能有方法体。",
"type":"对象的生成、使用和删除",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":154,
"title":"属于main()方法的返回类型是______。",
"optionA":"public",
"optionB":"static",
"optionC":"void ",
"optionD":"main",
"answer":"C",
"explain":"    本题考查的是main()方法的组成。\n    main()方法是一个特殊的方法，它是所有的Java Application程序执行的入口点，所以任何一个Java Application方法必须有且只能有一个main()方法，而且这个main()方法的方法头必须按照下面的格式书写：\n    public static void main(String args[])\n    或public static void main(String[] args)\n    因为对于一个方法来讲，它是由方法头和方法体组成，其中方法头的一般格式如下：\n    修饰符1 修饰符2 ……返回值类型 方法名（形式参数列表）throw[异常列表]\n    所以，main()方法头中的public、static属于修饰符，void是返回类型，main为方法名，String args[]是形式参数。",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":155,
"title":"为AB类的一个无形式参数无返回值的方法method书写方法头，使得使用类名AB作为前缀就可以调用它，该方法头的形式为______。",
"optionA":"static  void  method( ) ",
"optionB":"public  void  method( ) ",
"optionC":"final  void  method( ) ",
"optionD":"abstract  void  method( ) ",
"answer":"A",
"explain":"    本题考查的是修饰符的含义。\n    1、public修饰的方法可被其它类访问或引用。\n    2、abstract修饰的方法是抽象方法，抽象方法没有方法体，要使用抽象方法，必须先实现此抽象方法。\n    3、final修饰的方法不能被继承。\n    4、static修饰的方法为静态方法，静态方法不需要类的实例化就可以被类直接调用。\n    故要使得类名AB可以直接调用method()方法，则必须在method()前用static来修饰。",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":156,
"title":"下列______类声明是正确的。",
"optionA":"abstract final class HI{贩穧 ",
"optionB":"abstract private  move(){贩穧 ",
"optionC":"protected private number; ",
"optionD":"public abstract class Car{贩穧 ",
"answer":"D",
"explain":"    本题考查的是类的声明。\n    类声明的格式如下：\n    [修饰符]class 类名[extends 父类名][implements 类实现的接口列表]{   }\n    其中[]括起来的内容为可选项。关键字class是类定义的开始，类名应符合标识符命名规则，第一个字母大写。\n    本题中选项B，C无关键字class，故它们不是类声明。选项A中的两个修饰符不能同时用于修饰同一个类，因为abstract类自身没有具体对象，需要派生出子类后再创建子类的对象；而final类不可能有子类，这样abstract final类就无法使用，也就没有意义了。",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":157,
"title":"假设MyProg.java已经通过JDK编译程序进行编译通过生成了应用程序，那么通过命令行执行这个语句：java MyProg I like tests ，那么main方法中的args[0]是______。",
"optionA":"MyProg",
"optionB":"I",
"optionC":"like ",
"optionD":"tests ",
"answer":"B",
"explain":"    本题考查的是Java程序的结构。\n    Java程序通过args数组保存了在命令行中输入的所有参数，其中第一个参数是I。",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":158,
"title":"下面______表达式是正确的。",
"optionA":"byte=128;  ",
"optionB":"Boolean=null;",
"optionC":"long l=0xfffL; ",
"optionD":"double=0.9239d; ",
"answer":"C",
"explain":"    本题考查的是变量定义。\n    Java的原始数据类型一共就八个，分别是：byte，short，int，long，boolean，char，float，double。注意这些是大小写敏感的，而Boolean是boolean的封装类。\n    对于类类型的数据必需要创建对象才能分配存储空间，而对于一般的变量赋值只要根据一般的变量定义格式定义就可以了：变量类型 变量名=数据。\n    而本题只有选项C符合变量赋值的规则。",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":159,
"title":"类Panel默认的布局管理器是______。",
"optionA":"GridLayout",
"optionB":"BorderLayout",
"optionC":"FlowLayout",
"optionD":"CardLayout",
"answer":"C",
"explain":"    本题考查的是布局管理器。\n    1、GridLayout布局管理器使容器中各个构件呈网格状布局，平均占据容器的空间。即使容器的大小发生变化，每个构件还是平均占据容器的空间。构件在往容器中放置的时候，是按照从上到下、从左到右的规律进行的。\n    2、BorderLayout是Window,Frame和Dialog的默认布局管理器。BorderLayout布局管理器把容器分成5个区域：North,South,East,West和Center，每个区域只能放置一个构件。\n    3、FlowLayout是Panel和Applet的默认布局管理器。构件在容器中的放置规律是从上到下、从左到右进行放置，如果容器足够宽，第一个构件先添加到容器中第一行的最左边，后续的构件依次添加到上一个构件的右边，如果当前行已放置不下该构件，则放置到下一行的最左边。构件的大小不随容器的大小改变而改变。\n    4、CardLayout布局管理器能够帮助用户处理两个以至更多的成员共享同一显示空间，它把容器分成许多层，每层的显示空间占据整个容器的大小，但是每层只允许放置一个构件。",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":160,
"title":"在文件类提供的方法中，用于创建目录的方法是______。",
"optionA":"mkdir()",
"optionB":"mkdirs()",
"optionC":"list() ",
"optionD":"listRoots()",
"answer":"A",
"explain":"    本题考查的是File类的方法。\n    File类用于创建目录的方法是mkdir()，用于创建父目录的方法是mkdirs()。",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":161,
"title":"阅读下列代码 \npublic class Test2005\n{ \n  public static void main(String args[])\n  { \n    System.out.println(~(0xa5)&0xaa); \n  }\n} \n其运行结果是______。 ",
"optionA":"0xa5",
"optionB":"10",
"optionC":"0x50",
"optionD":"0xaa",
"answer":"B",
"explain":"    本题考察的是位运算和十六进制转换。\n    先将0xa5由十六进制转换成二进制数，即：10100101，然后再对其进行位反操作，得到：01011010；将0xaa转换成二进制数：10101010，与01011010进行位与操作，得到结果：00001010，转换为十进制数是：10。",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":162,
"title":"阅读下面程序\nimport javax.swing.JOptionPane;\npublic class Comparison {\n   public static void main(String args[]){\n     String firstNumber, \/\/用户输入第1个数据变量\n            secondNumber, \/\/用户输入第2个数据变量\n            result;  \/\/输出结果变量\n     int number1,   \/\/用于比较的第1个数\n         number2;   \/\/用于比较的第2个数\n     \/\/用户输入第1个数据的字符串\n     firstNumber=JOptionPane.showInputDialog(\"输入第1个整数：\");\n     \/\/用户输入第2个数据的字符串\n     secondNumber=JOptionPane.showInputDialog(\"输入第2个整数：\");\n     \/\/将字符串转换为整数类型\n     number1=Integer.parseInt(firstNumber);\n     number2=Integer.parseInt(secondNumber);\n     \/\/初始化结果变量\n     ________________________;\n     \/\/比较两个数据\n     if(number1==number2)\n        result+=number1+\"==\"+number2;\n     if(number1!=number2)\n        result+=number1+\"!=\"+number2;\n     if(number1<number2)\n        result=result+\"\\n\"+number1+\"<\"+number2;\n     if(number1>number2)\n        result=result+\"\\n\"+number1+\">\"+number2;\n     if(number1<=number2)\n        result=result+\"\\n\"+number1+\"<=\"+number2;\n     if(number1>=number2)\n        result=result+\"\\n\"+number1+\">=\"+number2;\n     \/\/显示结果\n     JOptionPane.showMessageDialog(null,result,\"比较结果\",\n                                JOptionPane.INFORMATION_MESSAGE);\n     System.exit(0);\n   }\n}\n为使程序能正确运行并得到合理的输出结果，初始化结果变量语句（下划线处）应是______。\n",
"optionA":"result=\"\" ",
"optionB":"result=null ",
"optionC":"result=number1",
"optionD":"result=number2 ",
"answer":"A",
"explain":"    本题考的是基本数据类型及转换。\n    在Java中，字符串是作为对象出现的，所以在定义字符串变量后，还必须创建其对象。但对于String类型的变量，可以不用new来创建对象，直接给定义好的字符串变量赋值，那么系统就会自动创建其对象。选项B虽然给字符串变量赋了空值字符串，但程序运行后得到的结果并不合理。",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":163,
"title":"请阅读下面程序\npublic class ExampleStringBuffer{\n  public static void main(String[] args){\n   StringBuffer sb=new StringBuffer(\"test\");\n   System.out.println(\"buffer=\"+sb);\n   System.out.println(\"length=\"+sb.length());}}\n程序运行结果中在\"length=\"后输出的值是______。",
"optionA":"10",
"optionB":"4",
"optionC":"20",
"optionD":"30",
"answer":"B",
"explain":"    本题考的是字符串操作。\n    StringBuffer类被设计用于创建和操作动态字符串信息。为该对象分配的内存会自动扩展以容纳新增的文本。首先使用初始化字符串的方法创建一个StringBuffer对象sb，其对应的值为字符串\"test\"，方法length()的功能是返回字符串的长度，返回值的数据类型为int，程序运行后，\"length=\"后输出的值是字符串\"test\"的长度。",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":164,
"title":"下列适配器类中不属于事件适配器类的是______。",
"optionA":"MouseAdapter",
"optionB":"KeyAdapter",
"optionC":"ComponentAdapter",
"optionD":"FrameAdapter",
"answer":"D",
"explain":"    本题考查的是事件适配器。\n    Java语言为一些Listener接口提供适配器（Adapter）类。可以通过继承事件所对应的Adapter类，重写需要的方法，无关方法不用实现。\n    事件适配器--EventAdapter。\n    java.awt.event包中定义的事件适配器包括以下几个：\n    ComponentAdapter：构件适配器\n    ContainerAdapter：容器适配器\n    FocusAdapter：焦点适配器\n    KeyAdapter：键盘适配器\n    MouseAdapter：鼠标适配器\n    MouseMotionAdapter：鼠标运动适配器\n    WindowAdapter：窗口适配器",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":165,
"title":"在Java语言中，被称为内存分配的运算符是______。",
"optionA":"new",
"optionB":"instance of",
"optionC":"[ ]",
"optionD":"( )",
"answer":"A",
"explain":"    本题考查的是JAVA关键字。\n    Java语言中，程序为对象动态分配内存。Java中内存分配的运算符是new。",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":166,
"title":"下列能表示字符串sl长度的是______。",
"optionA":"sl.length() ",
"optionB":"sl.length ",
"optionC":"sl.size",
"optionD":"sl.size()",
"answer":"A",
"explain":"    本题考查的是字符串操作。\n    String类包括的方法有：length()、charAt()、indexOf()、lastIndexOf()、getChars()、getBytes()、toCharArray()等，其中，提取字符串长度的方法是\"length()\"，调用方法如下：\n    String greeting=\"Hello\";\n    int n=greeting.length(); \/\/返回字符串的字符个数n=5",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":167,
"title":"阅读下列代码\npublic class Person{\n    static int arr[ ] = new int[10];\n    public static void main(String args){\n        System.out.println(arr[9]);\n    }\n}\n该代码的运行结果是______。",
"optionA":"编译时将产生错误",
"optionB":"编译时正确，运行时将产生错误",
"optionC":"输出零",
"optionD":"输出空",
"answer":"B",
"explain":"    本题考查的是Java程序设计。\n    \"public static void main(String args[])\"（也可以写作\"public static void main(String[] args)\"）建立一个名为main的方法。一个应用程序中可以有多个方法，但只能有一个main方法。main方法是程序的入口点，若无此方法，程序无法运行。",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":168,
"title":"在下列程序的空白处，应填入的正确选项是______。\nimport java.io.*;\npublic class WriteInt{\n   public static void main(String[] a){\n     int [] myArray = {10,20,30,40};\n     try{\n        DataOutputStream dos = new DataOutputStream(new FileOutputStream(\"ints.dat\"));\n        for (int i=0;i<myArray.length;i++)\n          dos.writeInt(myArray[i]);\n        dos.______;\n        System.out.println(\"Have written binary file ints.dat\");\n        }\n     catch(IOException ioe)\n   {  System.out.println (\"IO Exception\");\n   }\n  }\n}",
"optionA":"start()",
"optionB":"close() ",
"optionC":"read()",
"optionD":"write()",
"answer":"B",
"explain":"    本题考查的是输入输出流类。\n    DataOutputStream是OutputStream的子类，DataOutputStream具备数据类型或格式转换的功能，即向流中写入数据时，可以实现对二进制字节数据的编码功能。\n    OutputStream的子类继承以下方法：\n1、write()方法：向输出流写入数据的方法；\n2、flush()方法：强制清空缓冲区，并将缓冲区中的现有数据写入外设；\n3、close()方法：当输出流使用完毕后，可以调用close()方法将其关闭，断开Java程序与外设数据源的连接，释放此连接所占用的系统资源。\n    程序使用语句\"dos.writeInt(myArray[i]);\"向流中写入int类型的数据，完成数据写入后，需要使用语句\"dos.close();\"来释放此连接所占用的系统资源。",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":169,
"title":"下列程序的功能是将一个整数数组写入二进制文件。在程序的下划线处应填入的选项是______。\nimport java.io.*;\npublic class XieShuzu {\n   public static void main(String[] a) {\n     int [] myArray = {10,20,30,40};\n     try {\n       DataOutputStream dos =\n         new DataOutputStream( new\n         FileOutputStream(\"ints.dat \") );\n       for(int i=0;i<myArray.length;i++)\n          dos.______(myArray[i]);\n       dos.close( );\n       System.out.println\n             (\"已经将整数数组写入二进制文件:ints.dat \");\n         } catch(IOException ioe)\n           { System.out.println(\"IO Exception \");  }\n }\n    }",
"optionA":"writeArray ",
"optionB":"writeByte",
"optionC":"writeInt",
"optionD":"writeDouble",
"answer":"C",
"explain":"    本题考查的是DataOutputStream类。\n    处理字节流有DataOutputStream类，数据输出流允许应用程序以适当方式将基本Java数据类型写入输出流，可提供一些对Java基本数据类型写入的方法，写入int、double和boolean等的方法。本题要求将一个整数数组写入到二进制文件中，所以需要调用writeInt()方法，将一个int值以4-byte值形式写入基础输出流中，先写入高字节。",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":170,
"title":"下列不属于接口WindowListener的方法是______。",
"optionA":"windowClosing()",
"optionB":"windowClosed()",
"optionC":"windowMinimized()",
"optionD":"windowOpened()",
"answer":"C",
"explain":"    本题考察的是AWT事件监听器接口。\n    WindowListener接口中的方法有：\n    ①windowClosing()        \n    ②windowOpened()\n    ③windowIconified()\n    ④windowDeiconified()\n    ⑤windowClosed()\n    ⑥windowActivated()\n    ⑦windowDeactivated()",
"type":"接口与包",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":171,
"title":"下列内部类的正确用途是______。  \nbtnn.addActionListener(new ActionListener()    \/\/注册监听器\n{\n    public void actionPerformed(ActionEvent event)\n    {\n       String s=input.getText();\n       output.setText(\"Hello\"+s+\",Welcome You!\");\n    }\n});",
"optionA":"用于访问外部类的数据 ",
"optionB":"用于进行事件处理",
"optionC":"隐藏起来不被同一包中的其他类所见",
"optionD":"生成事件适配器",
"answer":"B",
"explain":"    本题考查的是内部类。\n    在Java中经常使用内部类，但一般采用内部类的原因有以下几点：\n    1、内部类的对象可以访问外部类的成员和方法。\n    2、实现事件监听时，采用内部类、匿名类容易实现。\n    3、编写事件驱动程序，内部类很方便。\n    本题中，不存在内部类对外部类的数据访问，故A是错的；同样也不存在同一包内其它类访问该内部类的问题，故选项C也是错的；又因为ActionListener事件监听器在Java中无事件适配器，所以此内部类不可能用于生成事件适配器。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":172,
"title":"关于被私有访问控制符private修饰的成员变量，以下说法正确的是______。",
"optionA":"可以被三种类所引用：该类自身、与它在同一个包中的其他类、在其他包中的该类的子类",
"optionB":"可以被两种类访问和引用：该类本身、该类的所有子类",
"optionC":"只能被该类自身所访问和修改",
"optionD":"只能被同一个包中的类访问",
"answer":"C",
"explain":"    本题考查的是成员变量的修饰符。\n    private修饰的变量说明变量为私有访问。只能被该类自己访问或调用，是对成员变量的高级保护。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":173,
"title":"下列语句正确的是______。",
"optionA":">> 是算术右移操作符",
"optionB":">> 是逻辑右移操作符",
"optionC":">>> 是算术右移操作符 ",
"optionD":">>> 是逻辑左移操作符 ",
"answer":"A",
"explain":"    本题考查的是移位运算符。\n    1、算术右移运算符>>\n    用来将一个数的二进制位序列右移若干位。\n    2、算术左移运算符<<\n    用来将一个数的二进制位序列左移若干位。\n    3、逻辑右移运算符>>>\n    用来将一个数的各二进制位添零右移若干位。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":174,
"title":"在编写异常处理的Java程序中，每个catch语句块都应该与______语句块对应，使得用该语句块来启动Java的异常处理机制。",
"optionA":"if-else",
"optionB":"switch ",
"optionC":"try ",
"optionD":"throw ",
"answer":"C",
"explain":"    本题考查的是异常处理的格式。\n    Java中通过try{}catch来捕获程序应用中异常信息。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":175,
"title":"下列程序运行的结果是______。\npublic class Example{ \n  String str=new String(\"good\"); \n  char[]ch={'a','b','c'}; \npublic static void main(String args[]){ \n  Example ex=new Example(); \n  ex.change(ex.str,ex.ch); \n  System.out.print(ex.str+\" and \"); \n  System.out.print(ex.ch); \n　　} \npublic void change(String str,char ch[]){ \n  str=\"test ok\"; \n  ch[0]='g'; \n　　} \n} ",
"optionA":"good and abc",
"optionB":"good and gbc ",
"optionC":"test ok and abc  ",
"optionD":"test ok and gbc ",
"answer":"B",
"explain":"本题考查的是条件语句的使用。\nJava语言中，原始数据类型变量是按值传递的，引用类型变量是按地址传递的。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":176,
"title":"在Java中，能实现多重继承效果的方式是______。",
"optionA":"内部类 ",
"optionB":"适配器",
"optionC":"接口",
"optionD":"同步",
"answer":"C",
"explain":"    本题考查的是接口。\n    Java实现的是单继承，即一个类只能从一个直接父类继承属性和方法；但一个接口可以继承多个父接口的成员，故可以利用接口能实现多重继承的效果。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":177,
"title":"容器类java.awt.Container的父类是______。",
"optionA":"java.awt.Windows ",
"optionB":"java.awt.Component",
"optionC":"java.awt.Frame ",
"optionD":"java.awt.Panel",
"answer":"B",
"explain":"    本题考查的是Java的容器构件。\n    Java的图形用户界面的最基本的组成部分就是构件（Component），构件是一个可以以图形化的方式显示在屏幕上并能与用户交互的对象，但构件不能独立地显示出来，必须将构件放在一定的容器中才可以显示出来。\n    容器Container是一个类，因为容器本身也是一个构件，具有构件的所有性质，因此继承之Component类。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":178,
"title":"阅读下列代码\npublic class Test2005\n{ \n  public static void main(String args [ ])\n  {\n    System.out.println((3>2)?4:5);\n  }\n} \n其运行结果是______。",
"optionA":"2",
"optionB":"3",
"optionC":"4",
"optionD":"5",
"answer":"C",
"explain":"    本题考察的是条件运算符。\n    三元条件表达式一般形式为：\n    expression1 ? expression2 :expression3\n    其中表达式expression1应该是关系或布尔逻辑表达式，其计算结果为布尔值，若其值为真，则计算表达式expression2，并将其结果作为整个表达式的结果；若为假，则计算表达式expression3，并将其结果作为整个表达式的结果。在本题中，先判断（3>2）的值为真，则表达式的结果为4。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":179,
"title":"阅读下面程序\npublic class Increment {\n public static void main(String args[]){\n  int c;\n  c=5;\n  System.out.println(c);\n  System.out.println(c++);\n  System.out.println(c);\n  }\n}\n程序运行结果是______。",
"optionA":"5\n6\n6 ",
"optionB":"5\n5\n6 ",
"optionC":"6\n7\n7",
"optionD":"6\n6\n6 ",
"answer":"B",
"explain":"    本题考的是运算符和表达式。\n    增量运算符是将操作数加1，c++是指在使用过c之后加1，在输出c++时，c的值还是5，但是运行后，c的值为6，所以在第三次输出c的值时c=6。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":180,
"title":"请阅读下面程序\nimport java.io.*;\npublic class ExceptionCatch{\n  public static void main(String args[]){\n   try{\n        FileInputStream fis=new FileInputStream(\"text\");\n        System.out.println(\"content of text is:\");\n      }catch(FileNotFoundException e){\n         System.out.println(e);\n         System.out.println(\"message:\"+e.getMessage());\n         e.printStackTrace(System.out);\n      }______{\n         System.out.println(e);\n      }\n   }\n}\n为保证程序正确运行，程序中下划线处的语句应是______。",
"optionA":"catch(FileInputStream fis) ",
"optionB":"e.printStackTrace()",
"optionC":"catch(IOException e) ",
"optionD":"System.out.println(e) ",
"answer":"C",
"explain":"    本题考的是异常处理。\n    在捕获异常时要用try-catch语句，该语句执行时，解释器把可能产生异常的代码段形成一个由try引导的\"警戒区\"，\"警戒区\"后面是catch从句，一个\"警戒区\"后面可接多个catch从句，catch的程序段由catch引导，所以B、D选项错误。catch子句都带一个参数，该参数是某个异常的类及其变量名（该异常对象的指针），所以A选项错误。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":181,
"title":"下列运算符中不能进行位运算的是______。",
"optionA":">> ",
"optionB":">>> ",
"optionC":"<< ",
"optionD":"<<< ",
"answer":"D",
"explain":"    本题考查的是位运算符。   \n    位运算符：\n    >>：按位右移，高位扩展，即算术右移；\n    <<：按位左移；\n    >>>：添零右移,即逻辑右移；\n    &：按位与；\n    ︱：按位或；\n    ^：按位异或；\n    ~：按位取反。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":182,
"title":"阅读下面程序\npublic class Cycle{\n  public static void main (String args[]){\n    System.out.println(args[0]);\n  }\n}\n在命令行中输入java Cycle one two，该程序输出结果是______。",
"optionA":"Cycle ",
"optionB":"one ",
"optionC":"two ",
"optionD":"其他选项均不对 ",
"answer":"D",
"explain":"    本题考查的是数组。\n    该程序运行报错，该程序要求输出一个数组的第一个元素，但是却没有对数组进行定义，也没有语句读取键盘输入的赋值内容。\n    public static void main (String args[])创建一个名为main的方法，但是其中的String args[]只是表明该方法有一个字符串的参数，并不能用作输出数组的定义。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":183,
"title":"阅读下列代码段\nabstract class Person{\n  public Person(String n){\n     name=n;\n  }\n  public ______ String getDescription();\n  public String getName(){\n      return name;\n  }\n  private String name;\n}\n在下划线处应填入的修饰符是______。",
"optionA":"static ",
"optionB":"abstract ",
"optionC":"protected ",
"optionD":"final ",
"answer":"B",
"explain":"    本题考查的是定义抽象类。\n    抽象类是专门设计来让子类继承的类。抽象类通常都包括一个或多个抽象方法（只有方法说明，没有方法体），抽象类的子类必须完成其父类定义的每一个抽象方法，除非该子类也是抽象类。\n    抽象类是以abstract关键字开头，抽象类定义具体形式：\n    abstract class 类名称\n    {\n      成员变量;\n      方法();  \/\/定义一般的方法\n      abstract 方法(); \/\/定义抽象的方法\n    }",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":184,
"title":"在Java中，若要使用一个包中的类时，首先要求对该包进行导入，其关键字是______。",
"optionA":"import ",
"optionB":"package ",
"optionC":"include ",
"optionD":"packet ",
"answer":"A",
"explain":"    本题考查的是包的引用。\n    使用一个包中的类时，首先要用关键字import导入这些类所在的包。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":185,
"title":"在一个线程中调用下列方法，不会改变该线程运行状态的是______。",
"optionA":"yield方法 ",
"optionB":"另一个线程的join方法 ",
"optionC":"sleep方法",
"optionD":"一个对象的notify方法 ",
"answer":"B",
"explain":"    本题考查的是线程的调度与线程控制。\n    yield方法：调用该方法后，可以使具有与当前线程相同优先级的线程有运行的机会。\n    join方法：t.join()方法使当前的线程等待，直到t结束为止，线程恢复到可运行状态。\n    sleep方法：该方法使一个线程暂停运行一段固定的时间。\n    notify方法 ：当线程调用某个对象X的notify()方法X.notify()时，则对象的wait pool中的一个线程将移入lock pool，在lock pool中线程将等待X的锁，一旦获得便可运行。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":186,
"title":"Java中的抽象类Reader和Writer所处理的流是______。",
"optionA":"图像流 ",
"optionB":"对象流",
"optionC":"字节流 ",
"optionD":"字符流",
"answer":"D",
"explain":"    本题考查的是Java输入\/输出流。\n    InputStream类和OutputStream类用于面向字节流（例如处理二进制文件），Reader类和Writer类用于面向字符流（例如处理文本文件）。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":187,
"title":"下列选项中，不能输出100个整数的是______。",
"optionA":"for (int i=0;i<100;i++)\n    System.out.println(i); ",
"optionB":"int i=0;\ndo {\n    System.out.println(i);\n    i++;\n}while (i<100); ",
"optionC":"int i=0;\nwhile(i<100){\n     System.out.println(i);\n     i++;\n} ",
"optionD":"int i=0;\nwhile(i<100){\n     i++;\n     if (i<100) continue;\n     System.out.println(i);\n} ",
"answer":"D",
"explain":"    本题考察的是循环语句和跳转语句。\n    选项A、B、C设i初值为0，每次循环先输出i值，再i+1，直到i为100时不满足条件，退出循环，共循环100次，依次输出0到99（包括99）。选项D除第一次循环外，每次在循环中，先对变量i的值加1，再输出i值。但因语句\"if(i<100) continue;\"，continue语句跳过循环体中下面未执行的语句，回到循环体的开始继续下一轮的循环，因而在i<99时，均不输出i值；在i为99时，\"i++;\"使i为100，不满足if语句，输出i值100，并退出循环。",
"type":"Java类库的常用类和接口",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":188,
"title":"下列数组a中，能在程序运行时动态调整大小的是______。",
"optionA":"int a[] ",
"optionB":"String[] a  ",
"optionC":"a=new ArrayList()",
"optionD":"a=new Array()",
"answer":"C",
"explain":"    本题考查的是数组大小的调整。\n    Java语言中用一种特殊的类-java.util.ArrayList(数组列表)在运行时动态调整数组的大小。ArrayList类在定义数组时，不必限定数组的大小。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":189,
"title":"下面的代码段中，执行之后i 和j 的值是______。\nint i = 1;\nint j;\nj = i++;",
"optionA":"1, 1 ",
"optionB":"1, 2 ",
"optionC":"2, 1 ",
"optionD":"2, 2 ",
"answer":"C",
"explain":"    本题考查的是表达式的运算。\n    增量运算符\"++\"是将操作数加1。对++x与x++的运算结果均为x=x+1，但若将增量运算表达式再作为其他表达式的操作数使用时，i++与++i是有区别的：i++在使用i之后，使i的值加1，因此执行表达式时是以i的值参加表达式的运算的，执行完后，i本身的值变为i+1；而++i是在使用i之前，使i的值加1，因此执行表达式时是以i+1的值参加运算的，执行完后i自身的值也为i+1。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":190,
"title":"public class Test\n{\n    public static void main(String arg[]){\n        int i = 5;\n        do{\n              System.out.println(i);\n          }while (--i>4)\n    }\n}\n执行后的输出是______。",
"optionA":"4",
"optionB":"5",
"optionC":"54",
"optionD":"45",
"answer":"B",
"explain":"    本题考查的是do-while循环语句。\n    do-while循环又称\"直到型\"循环，它首先执行循环体，然后计算终止条件，若结果为true，则循环执行循环体，直到布尔表达式的结果为false。\n    另外，运算符\"--\"是将操作数减1。对--x与x--的运算结果均为x=x-1，但若将\"--\"运算表达式再作为其他表达式的操作数使用时，i--与--i是有区别的：i--在使用i之后，使i的值减1，因此执行表达式时是以i的值参加表达式的运算的，执行完后，i本身的值变为i-1；而--i是在使用i之前，使i的值减1，因此执行表达式时是以i-1的值参加运算的，执行完后i自身的值也为i-1。\n    本程序执行过程如下：\n    i=5  执行System.out.println(i);，输出5；比较--i>4是否成立，因为\"--i\"在表达式中运算时是先让i减1，再进行运算。故此处比较时4>4不成立，循环结束。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":191,
"title":"创建一个标识有\"关闭\"按钮的语句是______。",
"optionA":"textField b=new TextField(\"关闭\"); ",
"optionB":"Label b=new Label(\"关闭\"); ",
"optionC":"Checkbox b=new Checkbox(\"关闭\"); ",
"optionD":"Button b=new Button(\"关闭\"); ",
"answer":"D",
"explain":"    本题是对AWT构件的考查。       \n    TextField用于申明一个文本域，它可以使用户进行输入。\n    Lable是一个标签，它用于显示信息。\n    Checkbox是一个选择框，用于选择项目。\n    Button是一个按钮标签。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":192,
"title":"要从文件\"file.dat\"文件中读出第10个字节到变量C中，下列______方法适合。",
"optionA":"FileInputStream in=new FileInputStream(\"file.dat\"); in.skip(9); int c=in.read(); ",
"optionB":"FileInputStream in=new FileInputStream(\"file.dat\"); in.skip(10); int c=in.read();  ",
"optionC":"FileInputStream in=new FileInputStream(\"file.dat\"); int c=in.read();  ",
"optionD":"RandomAccessFile in=new RandomAccessFile(\"file.dat\"); in.skip(9); int c=in.readByte();  ",
"answer":"A",
"explain":"本题考查的是Java中对文件的操作。\nJava提供FileInputStream是将文件作为流的方式读取，它是按照文件的顺序从0位置开始进行读取，RandomAccessFile是随机读取数据，读取的位置不一定是从0开始，可以使用skip(n)方法来跳过n个字符，通过readByte()读取一个字符，通过read()可以读取输入流中的一个字符。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":193,
"title":"char类型的取值范围是______。",
"optionA":"2-7～27-1 ",
"optionB":"0～216-1",
"optionC":"-215～215-1",
"optionD":"0～28-1",
"answer":"B",
"explain":"    本题考查的是Java语言的基本数据类型。\n    char类型数据是用无符号16位二进制表示的，故其取值范围为0~216-1。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":194,
"title":"下列代码中\nif(x>0) {System.out.println(\"first\");}\n  else if (x>-3) {System.out.println(\"second\");}\n    else {System.out.println(\"third\");}\n要求打印字符串为\"second\"时，x的取值范围是______。",
"optionA":"x<=0 并且 x>-3",
"optionB":"x>0",
"optionC":"x>-3",
"optionD":"x<-3",
"answer":"A",
"explain":"    本题考查的是if语句。\n    使用\"if\"语句检查一个条件是真或假(true或false)，如果条件存在，执行接下来的语句；如果条件不存在，转而判断\"else if\"，以此类推，如果所有条件都不成立，则执行\"else\"后面语句。\n    本题中要使之执行System.out.println(\"second\")，则需要\"if\"后条件不成立，且\"else if\"后的条件成立。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":195,
"title":"阅读下列代码：\npublic class Test\n{ \n  public static void main(String args[])\n  {\n    System.out.println(89>>1);\n  }\n} \n其运行结果是______。",
"optionA":"44 ",
"optionB":"45",
"optionC":"88",
"optionD":"90",
"answer":"A",
"explain":"    本题考察的是移位运算符。\n    算术右移运算符\">>\"用来将一个数的二进制位序列右移若干位，移到右端的低位被舍弃，最高位则移入原来高位的值。右移一位相当于除2取商。本题要求将89右移一位，用除法方法即为89\/2，取其商44，用二进制位移的方法则先将89转换为二进制数，结果为：0101 1001，将结果进行右移一位操作，得到结果：0010 1100，将其转换成十进制数得到答案：44。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":196,
"title":"下列叙述中，错误的是______。",
"optionA":"Java Application与Applet所用编译命令相同 ",
"optionB":"通常情况下Java Application只能有一个main()方法",
"optionC":"Java Applet必须有HTML文件才能运行 ",
"optionD":"Java Applet程序的.class文件可用java命令运行 ",
"answer":"D",
"explain":"    本题考的是Java Application和Applet。\n    Applet是能够嵌入HTML语言中，并能够在浏览器中运行的类。Applet的运行环境是Web浏览器，所以必须建立HTML文件，告诉浏览器如何加载与运行Applet。因此Applet是不能直接通过Java命令行启动运行的。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":197,
"title":"下列叙述中，错误的是______。",
"optionA":"所有的字节输入流都从InputStream类继承 ",
"optionB":"所有的字节输出流都从OutputStream类继承",
"optionC":"所有的字符输出流都从OutputStreamWriter类继承 ",
"optionD":"所有的字符输入流都从Reader类继承 ",
"answer":"C",
"explain":"    本题考的是Java中包含的输入输出流的类。\n    字符输出流类都是Writer抽象类的子类，所以，所有的字符输出流都从Writer类继承。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":198,
"title":"阅读下面程序\npublic class Test2{\n    public static void main(String args[]){\n        int a=10,b=4,c=20,d=6;\n        System.out.println(a++*b+c*--d);\n    }\n}\n程序运行的结果是______。",
"optionA":"144",
"optionB":"160",
"optionC":"140",
"optionD":"164",
"answer":"C",
"explain":"    本题考查的是运算符的优先级。\n    在对于一个复杂表达式进行运算时，要按运算符的优先级顺序从高到低进行，同级的二元运算符则按在表达式中的位置从左到右进行，而一元算术运算符则按从右到左的顺序结合。在本题的复杂表达式中：++、--属于同一级；高于*和+；*又高于+。\n    另外对++a与a++的运算结果均为a=a+1，但若将增量运算表达式再作为其他表达式的操作数使用时，a++与++a是有区别的：a++在使用a之后使a的值加1，因此执行表达式时是以a的值参加表达式的运算的，执行完后，a本身的值变为a+1；而++a是在使用a之前，使a的值加1，因此执行表达式时是以a+1的值参加运算的，执行完后a自身的值也为a+1。--d的运算也同样如此。所以本题表达式\"a++*b+c*--d\"相当于对\"10*4+20*5\"，即结果为140。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":199,
"title":"阅读下面程序\npublic class MyVal{\n  public static void main (String args []){\n    MyVal m=new MyVal ();\n     m.amethod ();\n}\npublic void amethod (){\n  boolean b[]=new Boolean [5];\n}\n}\n程序编译或运行结果是______。",
"optionA":"1 ",
"optionB":"null ",
"optionC":"\" \"  ",
"optionD":"编译不通过 ",
"answer":"D",
"explain":"    本题考查的是Java语言关键字。\n    首先，需要了解初始化数组格式可以为：类型标识符 数组名[]=new 类型标识符[元素个数]。\n    Java语言关键字是区分字母大小写的，在本题中，\"boolean b[]=new Boolean [5];\"编译时不能识别\"Boolean []\"，所以编译不能通过。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":200,
"title":"阅读下列代码\npublic class Jixiangwu{\n  public static void main(String[] args){\n    String[] stars={\"贝贝\",\"晶晶\",\"欢欢\",\"迎迎\",\"妮妮\"};\n    System.out.println(\"你抽取的奥运吉祥物是\"+\"\"\"\n         +stars[(int)(stars. ______*Math.random())]+\"\"\"+\"！\");\n }\n}\n为保证程序能正确执行，程序中下划线处应填写的是______。",
"optionA":"long ",
"optionB":"width ",
"optionC":"wide ",
"optionD":"length ",
"answer":"D",
"explain":"    本题考查的是数组。\n    初始化数组后，如果想知道其元素个数，可以通过属性length获得，其格式为：数组名.length。\"Math.random()\"的作用是产生一个0-1之间的随机数，即返回大于或等于0.0但小于1.0的伪随机double值。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":201,
"title":"继承是面向对象编程的一个重要特征，它可降低程序的复杂性并使代码______。",
"optionA":"可读性好 ",
"optionB":"可重用",
"optionC":"可跨包访问 ",
"optionD":"运行更安全 ",
"answer":"B",
"explain":"    本题考查的是继承的概念。\n    继承性是面向对象方法的一个重要基本特征，它使代码可重用，可降低程序复杂性",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":202,
"title":"在关闭浏览器时调用，能够彻底终止Applet并释放该Applet所有资源的方法是______。",
"optionA":"stop() ",
"optionB":"destroy() ",
"optionC":"paint() ",
"optionD":"start() ",
"answer":"B",
"explain":"    本题考查的是Applet的关键方法。\n    stop()：当Applet被覆盖时，可用该方法停止线程。\n    destroy()：关闭浏览器时调用，彻底终止Applet，从内存卸载并释放该Applet的所有资源。\n    paint()：画Applet界面的基本方法。\n    start()：在init()方法完成后，将调用start()方法，使Applet成为激活状态。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":203,
"title":"下列叙述中，错误的是______。",
"optionA":"内部类的名称与定义它的类的名称可以相同",
"optionB":"内部类可用abstract修饰",
"optionC":"内部类可作为其他类的成员",
"optionD":"内部类可访问它所在类的成员",
"answer":"A",
"explain":"    本题考查的是内部类具有的属性。\n    内部类具有如下几个属性：1、类名只能在定义的范围内被使用，内部类的名称必须区别于外部类；2、内部类可以使用外部类的类变量和实例变量，也可以使用外部类的局部变量；3、内部类可以定义为abstract类型；4、内部类可以是一个接口，这个接口必须由另一个内部类来实现；5、内部类可以被定义为private或protected类型。当一个类中嵌套另一个类时，访问保护并不妨碍内部类使用外部类的成员；6、被定义为static型的内部类将自动转化为顶层类，它们不能再使用局部范围中或其他内部类中的数据和变量；7、内部类不能定义static型成员，而只有顶层类才能定义static型成员；8、内部类可作为其他类的成员，而且可访问它所在类的成员。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":204,
"title":"类变量必须带有的修饰符是______。",
"optionA":"static",
"optionB":"final",
"optionC":"public",
"optionD":"volatile",
"answer":"A",
"explain":"    本题考察的是类成员修饰符的使用。\n    修饰符static说明该变量是一个类变量或者称为静态变量。",
"type":"Java简单数据类型及运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":205,
"title":"下列叙述中，错误的是______。",
"optionA":"接口与类的层次无关",
"optionB":"通过接口说明类所实现的方法",
"optionC":"通过接口可了解对象的交互界面",
"optionD":"接口与存储空间有关",
"answer":"D",
"explain":"    本题考查的是接口的概念。\n    接口是不包含成员变量和方法实现的抽象类，它只包含常量和方法的定义。接口的主要功能是：\n    （1）不管类的层次，可实现互不相关的类具有相同的行为。\n    （2）通过接口说明多个类所需实现的方法。\n    （3）通过接口可以了解对象的交互界面，无需了解对象所对应的类。\n    所以选项A、B、C都是正确的叙述。另外，由于接口不包括任何实现，所以与存储空间没有任何关系。所以选项D的叙述是错误的。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":206,
"title":"public class Test1{\n    public static void main(String args[]){\n         int m=Integer.parseInt(args[0]);\n         switch(m)\n         {\n              case 0:System.out.println(\"case 0\");\n              case 1:System.out.println(\"case 1\");\n              case 2:System.out.println(\"case 2\");break;\n              default:System.out.println(\"default\");\n         }\n    }\n}\n下列m的哪个值将引起\"default\"的输出______。",
"optionA":"0",
"optionB":"1",
"optionC":"2",
"optionD":"3",
"answer":"D",
"explain":"    本题考查的是多分支语句switch。\n    当switch后面表达式的值与任一case子句中的值都不匹配时，程序执行default后面的语句；break语句用来在执行完一个case分支后，使程序跳出switch语句；若没有break语句，当程序执行完匹配的case语句序列后，后面的case子句起不到跳出switch语句的作用，这样，程序会继续执行后面的case语句序列，直到遇到break为止。\n    本题中当m的值为0的时候，会输出\"case 0case 1case 2\"；当m的值为1时，输出\"case 1case 2\"；当m的值为2时，输出\"case 2\"；当m的值为3时，与前面所有case后面的值都不匹配，执行default语句，输出\"default\"。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":207,
"title":"switch (m)\n{\ncase 0: System.out.println(\"Condition 0\");\ncase 1: System.out.println(\"Condition 1\"); \ncase 2: System.out.println(\"Condition 2\");\ncase 3: System.out.println(\"Condition 3\");break;\ndefault: System.out.println(\"Other Condition\"); \n}\n当m 的值为______时，下列哪个选项中的所有值都能引起\"Condition 1\"的输出。",
"optionA":"0，1 ",
"optionB":"1，2 ",
"optionC":"2，3 ",
"optionD":"3，4 ",
"answer":"A",
"explain":"    本题考查的是多分支语句。\n    当switch后面表达式的值与任一case子句中的值都不匹配时，程序执行default后面的语句；break语句用来在执行完一个case分支后，使程序跳出switch语句；若没有break语句，当程序执行完匹配的case语句序列后，继续向下执行，向下执行时，并不与case后面的数据进行比较，而是直接执行下面的所有语句，直到遇到break语句为止。\n    本题中当m的值为0时，输出\"Condition 0Condition 1Condition 2Condition 3\"；当m的值为1时，输出\"Condition 1Condition 2Condition 3\"；当m的值为2时，输出\"Condition 2Condition 3\"；当m的值为3时，输出\"Condition 3\"；当m的值为4时，输出\"Other Condition\"。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":208,
"title":"在使用interface声明一个接口时，用下面______修饰符修饰该接口时，该接口被使用的范围最广。",
"optionA":"private ",
"optionB":"protected",
"optionC":"private protected",
"optionD":"public",
"answer":"D",
"explain":"    本题考查的是类修饰符的使用。\n    Java中声明接口的语法如下：\n    [public] interface 接口名 [extends 父接口名列表]\n    {\n     ……\n    }\n    interface是接口声明的关键字，声明接口时还需给出访问控制符，接口的访问控制符只有一个。用public修饰的接口是公共接口，可以被所有的类和接口使用，而没有public修饰符的接口则只能被同一个包中的其他类和接口使用。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":209,
"title":"给出下面代码： \npublic class Person{ \n　　static int arr[] = new int[10];\n　　public static void main(String a[]) \n　　{ \n　　　System.out.println(arr[1]); \n　　} \n} \n______语句是正确的。",
"optionA":"编译时将产生错误 ",
"optionB":"编译时正确，运行时将产生错误 ",
"optionC":"输出0 ",
"optionD":"输出空 ",
"answer":"C",
"explain":"本题考查的是数组的初始化问题。\nJava中对于整数数组如果没有指点数组的值会自动的用0填充整个数组。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":210,
"title":"能够支持javadoc命令的注释语句是______。",
"optionA":"\/**...\/\/ ",
"optionB":"\/*...*\/ ",
"optionC":"\/\/ ",
"optionD":"\/**...*\/ ",
"answer":"D",
"explain":"    本题考查的是Java语言中的注释语句。\n    Java的单行注释符为\/\/，多行注释符有\/*...*\/和\/**...*\/（javadoc能够利用该注释符自动生成帮助文档）。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":211,
"title":"下列叙述中，错误的是______。",
"optionA":"File类能够存储文件   ",
"optionB":"File类能够读写文件",
"optionC":"File类能够建立文件 ",
"optionD":"File类能够获取文件目录信息",
"answer":"B",
"explain":"    本题考查的是File类的概念。\n    文件File是java.io包中的一个重要的非流类，以一种系统无关的方式表示一个文件对象的属性。通过File所提供的方法，可以得到文件或文件夹的描述信息(包括名字、路径、长度、可读、可写等)，也可以生成新文件、文件夹，修改文件和文件夹，查询文件属性，重命名文件或者删除文件。File描述了文件本身的属性，File类中封装了对文件系统进行操作的功能。简单说，File类所关心的是文件在磁盘上的存储，而要对文件进行读写，就是流类所关心的文件内容，应该掌握相关概念以及相关方法。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":212,
"title":"在Applet 中显示文字、图形等信息时，应使用的方法是______。",
"optionA":"paint()",
"optionB":"init()",
"optionC":"start()",
"optionD":"destroy()",
"answer":"A",
"explain":"    本题考察的是Applet的关键方法。\n    Applet的关键方法主要指Applet生命周期方法以及Applet显示方法。\n    Applet生命周期方法：init( )、start( )、stop( )、destroy( )。\n    Applet显示相关的方法：paint()、updata()、repaint()。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":213,
"title":"下列关于Java语言中线程的叙述中，正确的是______。",
"optionA":"线程是由代码、数据、内核状态和一组寄存器组成 ",
"optionB":"线程间的数据是不共享的",
"optionC":"用户只能通过创建Thread类的实例或定义、创建Thread子类的实例建立和控制自己的线程",
"optionD":"因多线程并发执行而引起的执行顺序的不确定性可能造成执行结果的不确定",
"answer":"D",
"explain":"    本题考的是线程的概念和使用。\n    线程与进程在概念上是相关的。进程是由代码、数据、内核状态和一组寄存器组成，而线程是由表示程序运行状态的寄存器，如程序计数器、栈指针以及堆栈组成，线程不包含进程地址空间中的代码和数据。\n    多个线程之间可共享数据，例如：当两个线程访问同一对象时，将共享数据。\n    线程创建有两种方法：1、通过实现Runnable接口创建线程；2、通过继承Thread类创建线程。\n    当多个线程并发执行时，虽然各个线程中语句的执行顺序是确定的，但线程的相对执行顺序是不确定的，在有些情况下，如多线程对共享数据操作时，这种线程运行顺序的不确定性将会产生执行结果的不确定性，使共享数据的一致性被破坏，因此在某些应用程序中必须对线程的并发操作进行控制。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":214,
"title":"下列叙述中，正确的是______。",
"optionA":"线程与进程在概念上是不相关的 ",
"optionB":"一个线程可包含多个进程 ",
"optionC":"一个进程可包含多个线程 ",
"optionD":"Java中的线程没有优先级 ",
"answer":"C",
"explain":"    本题考的是线程的概念。\n    一个进程可以包含多个线程，在多任务操作系统中，通过运行多个进程来并发地执行多个任务。而在操作系统中引入线程的概念后，由于每个线程都是一个能独立执行自身指令的不同控制流，因此一个包含多线程的进程也能够实现多项任务的并发执行。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":215,
"title":"阅读下面程序\npublic class Test3{\n    public static void main(String args[]){\n        int x=3,y=4,z=5;\n        String s=\"xyz\"; \n        System.out.println(s+x+y+z);\n    }\n}\n程序运行的结果是______。",
"optionA":"xyz12",
"optionB":"xyz345",
"optionC":"xyzxyz",
"optionD":"12xyz",
"answer":"B",
"explain":"    本题考查的是运算符在字符串中的应用。\n    Java对\"+\"运算符进行了扩展，不仅使它能够进行字符串的连接，而且还能够将字符串和其他数据类型连接，其结果是字符串。题中\"s+x+y+z\"得到字符串xyz345。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":216,
"title":"阅读下面求质数的程序\nimport java.lang.Math.*;\npublic class MorePrimesTest{\n  public static void main(String[] args){\n    long[] primes=new long[20];\n     primes[0]=2L;\n     primes[1]=3L;\n     long number=5L;\n    outer:\n     for(int count=2;count<primes.length;number+=2L){\n       long limit=(long)Math.ceil(Math.sqrt((double)number));\n         for(int i=1;i<count&&primes[i]<=limit;i++){\n           if(number ______ primes[i]==0L){\n           continue outer;\n         }\n      }\n    primes[count++]=number;\n  }\n         for(int j=0;j<primes.length;j++){\n          long n=primes[j];\n            System.out.println(n);\n          }\n     }\n}\n在程序下划线处填入的正确选项是______。",
"optionA":"& ",
"optionB":"*",
"optionC":"\/",
"optionD":"%",
"answer":"D",
"explain":"    本题考查的是JAVA程序结构。\n    所谓质数或称素数，就是一个正整数，除了本身和1以外并没有任何其他因子。任何一个整数，可以写成一串质数相乘的积。\n    程序中首先定义了包含有20个元素的长整型数组，为数组的第一，第二个元素赋值，并且还定义了一个长整型变量\"long number=5L;\"，然后进入循环，该循环的作用是判断当前变量number的值是否为质数，其中Math.sqrt(double x)方法的作用是求x的平方根，而Math.ceil()方法的作用是求最小的整数但不小于本身（例如：Math.ceil(3.14)则返回4），在本次循环中，需要判断变量number与primes[i]的取余操作，如果变量number与小于自己的平方根取整且小于count的数取余数为0，则跳出循环，将number的值写入数组中，当20个元素填满后，程序依次输出数组元素。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":217,
"title":"下列方法中可用于定义线程体的是______。",
"optionA":"start() ",
"optionB":"init() ",
"optionC":"run()",
"optionD":"main()",
"answer":"C",
"explain":"    本题考查的是线程的创建。\n    Java中的线程体是由线程类的run()方法定义，在该方法中定义线程的具体行为。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":218,
"title":"阅读下列代码片段\nclass InterestTest ______ ActionListener{\n    ……\n     public void actionPerformed(ActionEvent event){\n        double interest = balance * rate\/100;\n        balance += interest;\n        NumberFormat format =\n                NumberFormat.getCurrencyInstance( );\n        System.out.printlb(\"balance = \"+\n                formatter.format(balance));\n    }\n    private double rate;\n}\n在下划线处，应填的正确选项是______。",
"optionA":"Implementation ",
"optionB":"Inheritance ",
"optionC":"implements ",
"optionD":"extends ",
"answer":"C",
"explain":"    本题考查的是接口。\n    每类事件都有对应的事件监听器，监听器是接口。在类中使用implements关键字实现接口。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":219,
"title":"为了将HelloApplet（主类名为HelloApplet.class）嵌入在greeting.html文件中，应该在下列greeting.html文件的横线处填入的代码是______。\n<HTML>\n<HEAD>\n<TITLE> Greetings <\/TITLE>\n<\/HEAD>\n<BODY>\n<APPLET ______>\n<\/APPLET>\n<\/BODY>\n<\/HTML>",
"optionA":"HelloApplet.class ",
"optionB":"CODE=\"HelloApplet.class\"",
"optionC":"CODE=\"HelloApplet.class\" WIDTH=150 HEIGHT=25",
"optionD":"CODE=\"HelloApplet.class\" VSPACE=10 HSPACE=10",
"answer":"C",
"explain":"    本题考查的是在HTML页中包含Applet。\n    将小应用程序HelloApplet嵌入在greeting.html文件中，必须使用特殊的HTML标记<APPLET>标记实现Applet或JApplet的嵌入运行。\n    CODE=appletFile：这个属性指定包含Applet或JApplet字节码的文件名。\n    WIDTH=pixels HEIGHT=pixels：这两个在<APPLET>标记中必须指定的属性，定义了Applet显示区以像素为单位的高度和宽度。但由Applet运行过程中所产生的任何窗口或对话框不受此约束。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":220,
"title":"用于在子类中调用被重写父类方法的关键字是______。",
"optionA":"this ",
"optionB":"super ",
"optionC":"This ",
"optionD":"Super ",
"answer":"B",
"explain":"    本题考查的是super关键字。\n    Java通过super关键字来实现对父类成员的访问，super关键字用来引用当前对象的父类。子类中的成员变量或方法与父类中的成员变量或方法同名。因为子类中的成员变量或方法名优先级高，所以子类中的同名成员变量或方法就隐藏了父类的成员变量或方法，但是我们如果想要使用父类中的这个成员变量或方法，就需要用到super关键字。另外，在Java中，关键字区分大小写，所以C、D选项错误。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":221,
"title":"下列选项中属于字符串常量的是______。",
"optionA":"abc' ",
"optionB":"\"abc\" ",
"optionC":"[abc]",
"optionD":"(abc)",
"answer":"B",
"explain":"    本题考察的是字符串常量的表示。\n    字符串常量是用\"\"括起来的字符序列，如\"Hello\"、\"欢迎你\"。",
"type":"变量和常量",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":222,
"title":"阅读和理解下面程序段：\nclass Manager extends Employee\n{ \n    public Manager(String n,double s,int year,int month,int day)\n    {\n        super(n,s,year,month,day);\n        bonus=0;\n   }\n   public double getSalary()\n   {\n       double baseSalary=super.getSalary();\n       return baseSalary+bonus;\n   }\n   public void setBonus(double b)\n   {\n       bonus=b;\n   }\n   private double bonus;\n}\nManager是Employee的子类，其理由是______。",
"optionA":"Manager的适用范围较宽 ",
"optionB":"extends关键字声明",
"optionC":"Manager的域减小了",
"optionD":"雇员是一个经理",
"answer":"B",
"explain":"    本题考查的是类的继承。\n    对一个类的继承是指在现有类（父类）的基础上构建一个新类（子类），子类重用（继承）了父类的方法和状态，同时还可以向新类中增添新的方法和状态。Java中创建子类是通过在类声明中加入extends子句来实现的。",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":223,
"title":"outer: for(int i=0;i<3; i++)\ninner: for(int j=0;j<2;j++)\n{\n    if(j==1) continue outer;\n    System.out.println(j+ \"and \"+i+\";\");\n} \n以上代码输出是______。",
"optionA":"0 and 0;0 and 1;0 and 2; ",
"optionB":"0 and 0;1 and 0;2 and 0;",
"optionC":"1 and 0;1 and 1;1 and 2;",
"optionD":"2 and 0;2 and 1;2 and 2;",
"answer":"A",
"explain":"    本题考查的是多重循环。\n    首先介绍一下continue语句的功能：continue语句是跳过循环体中下面尚未执行的语句，回到循环体的开始，继续下一轮的循环。\n    本题程序运行过程如下：\n    i=0：\n       j=0  条件j==1不成立，输出j和i，即0 and 0；\n       j=1  条件j==1成立，执行continue，跳过System.out.println(j+ \"and \"+i+\";\");执行下一轮循环j=2；\n       j=2  条件j<2不满足，退出内层循环，继续外层循环。\n    i=1：\n       j=0  条件j==1不成立，输出j和i，即0 and 1；\n       j=1  条件j==1成立，执行continue，跳过System.out.println(j+ \"and \"+i+\";\");执行下一轮循环j=2；\n       j=2  条件j<2不满足，退出内层循环，继续外层循环。\n    i=2：\n       j=0  条件j==1不成立，输出j和i，即0 and 2；\n       j=1  条件j==1成立，执行continue，跳过System.out.println(j+ \"and \"+i+\";\");执行下一轮循环j=2；\n       j=2  条件j<2不满足，退出内层循环，继续外层循环。\n    i=3：条件i<3不满足，结束。",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":224,
"title":"JScrollPane是带滚动条的面板，主要是通过移动______来实现的。",
"optionA":"JViewport ",
"optionB":"JSplitPane ",
"optionC":"JDesktopPane",
"optionD":"JlayeredPane ",
"answer":"A",
"explain":"    本题考查的是JScrollPane。\n    在JScroolPane类中，主要是通过JViewport(视口)类来实现内容的滚动的。JViewport是一种特殊的对象，用于查看基层构件，滚动条实际上就是沿着构件移动视口，同时描绘出它能看到的内容。",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":225,
"title":"下列选项中关于内部类的定义______是正确的。",
"optionA":"class B{\n} ",
"optionB":"class B extends A{\n} ",
"optionC":"class B extends A{\n  B(){System.out.println(\"i=\"+i);}\n} ",
"optionD":"class B{\n  class A{}\n}",
"answer":"D",
"explain":"本题考查的是内部类。\n    内部类的特点如下：\n    1、内部类的类名只能在定义它的类或程序段中或在表达式内部匿名使用，外部使用它时必须给出类的全名。而且，内部类的类名不允许与包含它的类名相同。\n    2、内部类可以使用它所在的静态成员变量和实例成员变量，也可使用它所在类的方法中的局部变量。\n    3、内部类可用abstract修饰定义为抽象类，也可用private或protected定义。\n    4、内部类可作为其他类的成员，而且可访问它所在类的成员。\n    5、除static内部类外，不能在类内声明static成员。一旦内部类声明为static，就变成顶层类，不能再使用局部变量。",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":226,
"title":"下列代码______会出错。\n1) public void modify() { \n2) int i,j,k; \n3) i=100; \n4) while (i>0) { \n5) j=i*2; \n6) System.out.println (\" The value of j is \" +j ); \n7) k=k+1; \n8) i--; \n9) } \n10) }",
"optionA":"line 4 ",
"optionB":"line 6 ",
"optionC":"line 7 ",
"optionD":"line 8 ",
"answer":"C",
"explain":"    本题考查的是变量初始化问题。\n    由于Java中声明变量并没有分配内存空间，必须通过初始化才能使用变量。",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":227,
"title":"十进制数16的16进制表示格式是______。",
"optionA":"0x10 ",
"optionB":"0x16 ",
"optionC":"0xA ",
"optionD":"016 ",
"answer":"A",
"explain":"    本题考查的是Java语言的基本数据类型。\n    Java语言中，16进制数以Ox开头，8进制数以0开头；而(16)10=(10)16。",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":228,
"title":"下列叙述中，正确的是______。",
"optionA":"Reader是一个读取字符文件的接口 ",
"optionB":"Reader是一个读取数据文件的抽象类 ",
"optionC":"Reader是一个读取字符文件的抽象类 ",
"optionD":"Reader是一个读取字节文件的一般类 ",
"answer":"C",
"explain":"    本题考查的是Java的流。\n    Java中的流分为两种，一种是字节流，另一种是字符流，分别由四个抽象类来表示（每种流包括输入和输出两种，所以一共四个）：InputStream，OutputStream，Reader，Writer。Java中其他多种多样变化的流均是由它们派生出来的。\n    在这其中InputStream和OutputStream在早期的Java版本中就已经存在了，它们是基于字节流的，而基于字符流的Reader和Writer是后来加入作为补充的。在这四个抽象类中，InputStream和Reader定义了完全相同的接口：\n    int read()\n    int read(char cbuf[])\n    int read(char cbuf[], int offset, int length)\n    而OutputStream和Writer也是如此：\n    int write(int c)\n    int write(char cbuf[])\n    int write(char cbuf[], int offset, int length)",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":229,
"title":"线程生命周期中正确的状态是______。",
"optionA":"新建状态、运行状态和终止状态 ",
"optionB":"新建状态、运行状态、阻塞状态和终止状态 ",
"optionC":"新建状态、可运行状态、运行状态、阻塞状态和终止状态 ",
"optionD":"新建状态、可运行状态、运行状态、恢复状态和终止状态 ",
"answer":"C",
"explain":"    本题考察的是线程生命周期中的状态。\n    线程的生命周期主要分为以下几个状态：新建状态、可运行状态、运行状态、阻塞状态和终止状态。",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":230,
"title":"阅读下面程序\nimport javax.swing.JOptionPane;\npublic class BreakLabelTest {\n   public static void main(String args[]){\n      String output=\"\";\n      stop:{\n          for(int row=1;row<=10;row++){\n             for(int column=1;column<=5;column++){\n                if(row==5)\n                   break stop;\n                output+=\"* \";\n          }\n          output+=\"\\n\";\n      }\n      output+= \"\\nLoops terminated normally\";\n   }\n  JOptionPane.showMessageDialog(\n     null,output,\"用一个标志测试break语句\",\n     JOptionPane.INFORMATION_MESSAGE);\n  System.exit(0);\n }\n}\n程序运行结果是______。",
"optionA":"窗口中有5行* * * * * ",
"optionB":"窗口中有5行* * * * *",
"optionC":"窗口中有4行* * * * * ",
"optionD":"窗口中有6行* * * * * ",
"answer":"C",
"explain":"    本题考的是循环语句。\n    第一个FOR循环控制的是输出多少列\"*\"，第二个FOR循环控制的是每列输出多少个\"*\"。虽然第一个FOR循环规定了row<=10，但是下面的if语句却把控制row控制在5次，即row==5时跳出循环。由于row的初始值是1，故运行了4次，输出4列（这里需要注意的是break语句）。第二个FOR循环要求输出5个\"*\"。",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":231,
"title":"请阅读下面程序\npublic class ThreadTest{\n  public static void main(String args[]){\n     Thread t1=new Thread(new Hello());\n     Thread t2=new Thread(new Hello());\n     t1.start();\n     t2.start();\n  }\n}\nclass Hello implements Runnable{\n  int i;\n  public void run(){\n     while(true){\n       System.out.println(\"Hello\"+i++);\n       if(i==5) break;\n     }\n  }\n}\n该程序创建线程使用的方法是______。",
"optionA":"继承Thread类 ",
"optionB":"实现Runnable接口 ",
"optionC":"t1.start() ",
"optionD":"t2.start() ",
"answer":"B",
"explain":"    本题考的是多线程的实现方法。\n    在Java中，创建线程的方法有两种：一种是通过创建Thread类的子类来实现，另一种方法是通过实现Runable接口的类来实现。通过\"class Hello implements Runnable\"可以判断出，该程序使用实现Runnable接口的方法创建线程。",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":232,
"title":"下列类中属于字节输入抽象类的是______。",
"optionA":"FileInputStream",
"optionB":"ObjectInputStream",
"optionC":"FilterInputStream",
"optionD":"InputStream",
"answer":"D",
"explain":"    本题考查的是字节流抽象类。\n    Java中处理字节流的抽象类有InputStream和OutputStream。其中字节输入流都是抽象类InputStream的子类。\n    ByteArrayInputStream以字节数组为输入流。\n    FileInputStream可对一个磁盘文件涉及的数据进行处理。\n    PipedInputStream是实现线程之间通信的一个类。\n    FilterInputStream过滤器输入流本身也是一个抽象类。\n    SequenceInputStream将多个输入流首尾连接，得到一个新的输入流。\n    ObjectInputStream类实现了ObjectInput接口，对象在传输前，要首先实现Serializable接口。",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":233,
"title":"接口中，除了抽象方法之外，还可以含有______。",
"optionA":"变量",
"optionB":"常量",
"optionC":"成员方法",
"optionD":"构造方法",
"answer":"B",
"explain":"    本题考查的是接口的概念。\n    接口是一种只含有抽象方法或常量的一种特殊的抽象类，它不包含成员变量和方法实现。",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":234,
"title":"下列方法中与Applet显示无关的是______。",
"optionA":"update()",
"optionB":"draw()",
"optionC":"repaint()",
"optionD":"paint()",
"answer":"B",
"explain":"    本题考查的是Applet显示。\n    Applet显示相关的3个方法：\n    1、paint()方法：Applet的paint()方法具体执行Applet的绘制，该方法定义如下：\n    public void paint(Graphics g)\n    paint()方法有一个参数g是Graphics类的实例，该实例对象由浏览器生成，它包含了Applet的图形上下文信息，通过它向Applet中显示信息，该对象相当于Applet的画笔。在调用paint()方法时，由浏览器将该对象传递给paint()方法。\n    2、update()方法：\n    public void update(Graphics g)\n    用于更新Applet的显示。该方法将首先清除背景，再调用paint()方法完成Applet的具体绘制。\n    3、repaint()方法：\n    public void repaint()\n    repaint()方法主要用于Applet的重新显示，它调用update()方法实现对Applet的更新。",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":235,
"title":"下列方法中，不属于类String的方法是______。",
"optionA":"toLowerCase() ",
"optionB":"valueOf() ",
"optionC":"charAt() ",
"optionD":"append() ",
"answer":"D",
"explain":"    本题考查的是String类方法。\n    toLowerCase()：将字符串中所有字符变为小写。\n    valueOf()：返回指定对象的原始值，方法String.valueOf(基本类型数据)的返回值是String型，即字符串型。\n    charAt()：提取字符串中指定字符。\n    append()属于StringBuffer类。",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":236,
"title":"下列变量名的定义中，符合Java命名约定的是______。",
"optionA":"fieldName",
"optionB":"super",
"optionC":"Intnum",
"optionD":"$number",
"answer":"A",
"explain":"    本题考查的是标识符和关键字。\n    Java中的名称包括：包名、类名、接口名、变量名、方法名、常数名。Java对于这些名称命名的约定的基本原则如下：\n1）_、$不作为变量名、方法名开头。\n2）变量名、方法名首单词小写，其余单词只有首字母大写，如anyVariableWorld。\n3）接口名、类名首单词第一个字母大写。\n4）常量完全大写。\n5）变量名不能与Java关键字相同（注：super为Java关键字）。",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":237,
"title":"下列Java语句从指定网址读取html文件，在下划线处应填上的选项是______。\nReader in = new ______ (new URL(urlString).openStream());",
"optionA":"Reader ",
"optionB":"DataOutputStream",
"optionC":"ByteArrayInputStream",
"optionD":"InputStreamReader",
"answer":"D",
"explain":"    本题考查的是InputStreamReader类。\n    Java语句从指定网址读取html文件，即打开URL的连接并返回一个从该连接读入的InputStream。代码如下：Reader in=new InputStreamReader(new BufferedInputStream(url.openStream()));",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":238,
"title":"Java程序默认引用的包是______。",
"optionA":"java.text包",
"optionB":"java.awt包",
"optionC":"java.lang包",
"optionD":"java.util包",
"answer":"C",
"explain":"    本题考查的是Java的API结构。\n    java.lang包封装了所有基本类。由Java编译器自动导入。因此，编程时使用该包中的类，可省去import导入。但使用其它包中的类，必须用import导入。",
"type":"基本数据类型及转换",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":239,
"title":"WindowListener中可以实现窗口关闭功能的方法是______。",
"optionA":"public void windowOpened(WindowEvent e)",
"optionB":"public void windowClosed(WindowEvent e)",
"optionC":"public void windowClosing(WindowEvent e)",
"optionD":"public void windowDeactivated(WindowEvent e)",
"answer":"C",
"explain":"    本题考查的是窗体的方法。\n    windowOpened是打开窗体后将要执行的方法。windowClosed是关闭窗体后将要执行的方法，windowClosing是在关闭窗体时要执行的方法，该方法可以执行窗体的关闭功能。windowDeactivated是窗体处于非激活时将会执行该方法。因此windowClosing是可以实现窗口关闭操作的方法。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":240,
"title":"监听器接口的方法返回值的类型是______。",
"optionA":"int",
"optionB":"String",
"optionC":"void",
"optionD":"Object",
"answer":"C",
"explain":"    本题考查的是监听器。\n    每个事件都有自己的监听器，监听器本身是一种接口，该接口中的方法，返回值是void类型。当要为指定的类注册监听器时，就可以通过定在实现该接口的类中定义该方法，这样可以在某个事件发生后，将会自动执行相应方法中的代码。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":241,
"title":"下面______事件监听器在Java中无事件适配器。",
"optionA":"MouseListener",
"optionB":"KeyListener",
"optionC":"ActionListener",
"optionD":"WindowListener",
"answer":"C",
"explain":"    本题考查的是事件适配器。\n    Java语言为一些Listener接口提供了适配器（Adapter）类。可以通过继承事件所对应的Adapter类，重写需要的方法，无关方法不用实现。\n    java.awt.event包中定义的事件适配器类包括以下几个：\n    1、ComponentAdapter，构件适配器。\n    2、ContainerAdapter，容器适配器。\n    3、FocusAdapter，焦点适配器。\n    4、KeyAdapter，键盘适配器。\n    5、MouseMotionAdapter，鼠标运动适配器。\n    6、MouseAdapter，鼠标适配器。\n    7、WindowAdapter，窗口适配器。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":242,
"title":"假设有以下程序\nif(x>4){ \nSystem.out.println(\"Test 1\");} \nelse if (x>9){ \nSystem.out.println(\"Test 2\");} \nelse { \nSystem.out.println(\"Test 3\");} \n如果要输出Test 2，那么条件是______。",
"optionA":"假设有以下程序\nif(x>4){ \nSystem.out.println(\"Test 1\");} \nelse if (x>9){ \nSystem.out.println(\"Test 2\");} \nelse { \nSystem.out.println(\"Test 3\");} \n如果要输出Test 2，那么条件是______。",
"optionB":"x>4 ",
"optionC":"x>9 ",
"optionD":"没有正确答案",
"answer":"D",
"explain":"    本题考查的是条件语句。\n    只有两种情况：大于4时输出\"Test1\"，小于等于4时输出\"Test3\"。 ",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":243,
"title":"下面关于Applet的说法正确的是______。",
"optionA":"Applet也需要main方法",
"optionB":"Applet继承自java.awt.Applet或javax.swing.JApplet ",
"optionC":"Applet能访问本地文件 ",
"optionD":"Applet程序不需要编译",
"answer":"B",
"explain":"    本题考查的是Applet的运行组成结构。\n    Java Applet的字节码文件必须嵌入HTML的文件中并由负责解释HTML文件的WWW浏览器充当解释器来解释运行。因此Applet不需要main方法，但必须继承java.awt.Applet类或javax.swing.JApplet，因为这两个类实现了Applet程序于浏览器的通讯。\n    为了系统的安全，一般情况下Applet程序不能访问本地文件，只有通过授权后才能读写。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":244,
"title":"int型public成员变量MAX_LENGTH，该值保持为常数100，则定义这个变量的语句是______。",
"optionA":"public int MAX_LENGTH=100",
"optionB":"final int MAX_LENGTH=100",
"optionC":"public const int MAX_LENGTH=100",
"optionD":"public final int MAX_LENGTH=100",
"answer":"D",
"explain":"    本题考查的是类成员修饰符。\n    Java语言中，final关键字修饰的变量的值在其被分配初值后不能被改变。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":245,
"title":"用于输入压缩文件格式的ZipInputStream类所属包是______。",
"optionA":"java.util",
"optionB":"java.io",
"optionC":"java.nio",
"optionD":"java.util.zip",
"answer":"D",
"explain":"    本题考查的是ZipInputStream类。\n    ZipInputStream该对象用于从ZIP压缩文件中创建输入流对象。\n    对象定义结构：java.util.zip.ZipInputStream\n    静态成员变量：CENATT、CENATX、CENCRC……，这些静态成员变量用于定义在压缩过程中采用的压缩算法。 \n    构造方法：ZipInputStream(InputStream in)应用输入流对象创建从ZIP文件中读取数据的输入流对象。\n    成员方法： \n    int available() 判断当前入口指定的压缩原始文件中是否还有未读数据。\n    void close() 关闭ZIP输入流对象。\n    void closeEntry() 关闭被读取的ZIP入口，并移动到下一压缩原始文件入口。\n    protectedZipEntry createZipEntry(String name) 利用指定的名称创建ZipEntry对象实例。\n    ZipEntry getNextEntry() 将输入流对象移动到下一入口对象。\n    int read(byte[] b, int off, int len) 从当前ZipEntry中读取字节数组。\n    long skip(long n) 将输入流指定的读取数据位置移动n个字节。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":246,
"title":"Thread 类中能运行线程体的方法是______。",
"optionA":"start()",
"optionB":"resume()",
"optionC":"init()",
"optionD":"run()",
"answer":"D",
"explain":"    本题考察的是线程生命周期中的状态。 \n    start()：新建的线程不会自动运行，必须调用线程的start()方法，此时线程处于运行就绪状态；\n    resume()：在一个线程被暂停执行后，恢复该线程；\n    init()：初始化方法；\n    run()：Java中的线程体是由线程类的run()方法定义，在该方法中定义线程的具体行为。线程开始执行时，也是从它的run()方法开始执行。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":247,
"title":"处理对象传输的接口是______。",
"optionA":"Serializable",
"optionB":"Cloneable",
"optionC":"ItemListener",
"optionD":"ActionListener",
"answer":"A",
"explain":"    本题考的是文件和文件I\/O。\n    Serializable接口用来处理对象流。凡是用于输入输出的对象在传输前，都要实现这个接口。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":248,
"title":"Java对I\/O访问所提供的同步处理机制是______。",
"optionA":"字节流",
"optionB":"过滤流",
"optionC":"字符流",
"optionD":"压缩文件流",
"answer":"B",
"explain":"    本题考的是过滤流。\n    Java对I\/O访问所提供的同步处理机制是过滤流。一般，使用一个过滤流要求首先把过滤流连接到某个I\/O流上，再通过构造方法的参数去指定连接的I\/O流。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":249,
"title":"能向内存直接写入数据的流是______。",
"optionA":"FileOutputStream",
"optionB":"FileInputStream ",
"optionC":"ByteArrayOutputStream",
"optionD":"ByteArrayInputStream",
"answer":"C",
"explain":"    本题考查的是数据流对内存的操作。\n    FileOutputStream用于对磁盘文件涉及的数据流进行输出处理，即向一个文件对象中写入数据。\n    FileInputStream可对一个磁盘文件涉及的数据进行处理。\n    ByteArrayOutputStream字节数组输出流。这个类将一个字节数组作为输出流，而任何内存块都可以以字节数组的形式使用，故利用该类可以对内存进行写入操作。\n    ByteArrayInputStream以字节数组为输入流，它只能用于从内存中读取字节流。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":250,
"title":"StringBuffer类字符串对象的长度是______。",
"optionA":"固定 ",
"optionB":"必须小于16个字符 ",
"optionC":"可变 ",
"optionD":"必须大于16个字符",
"answer":"C",
"explain":"    本题考查的是字符串。\n    在Java中，字符串是作为对象出现的，由java.lang.String和java.lang.StringBuffer定义，分别用来处理长度不变和长度可变的字符串。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":251,
"title":"下列语句中错误的是______。",
"optionA":"String s[]={\"how\",\"are\"}; ",
"optionB":"byte b=255; ",
"optionC":"String s=\"one\"+\"two\";  ",
"optionD":"int i=2+2000;",
"answer":"B",
"explain":"    本题考查的是简单数据类型。\n    赋值运算符（=）把一个表达式赋给一个变量，在赋值运算符两侧不一致的情况下，如果左侧变量类型的级别高，则右侧的数据被转化为与左侧相同级别的数据类型后赋给左侧变量；否则，需要使用强制类型转换运算符。\n    本题中选项B右侧255为int型，而左侧是比它级别低的byte型，且byte型的数据范围是-128～+127，255超出了其数据范围，所以此选项不正确。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":252,
"title":"grid[9][5]描述的是______。",
"optionA":"二维数组",
"optionB":"一维数组",
"optionC":"五维数组",
"optionD":"九维数组",
"answer":"A",
"explain":"    本题考查的是二维数组定义。\n    二维数组定义的格式为：type arrayName[][]；或type[][] arrayName。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":253,
"title":"自定义异常类的父类可以是______。",
"optionA":"Error",
"optionB":"VirtualMachineError",
"optionC":"Exception",
"optionD":"Thread",
"answer":"C",
"explain":"    本题考查的是自定义异常类。\n    自定义异常类可以通过继承Exception类来实现。其一般形式为：\nclass 自定义异常类名 extends Exception\n{\n  异常类体;\n}\n    自定义异常类将继承Exception类的所有方法，除此之外，还可以在类体中定义其他处理方法。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":254,
"title":"下列不属于表达式语句的是______。",
"optionA":"++i;",
"optionB":"--j;",
"optionC":"b#a;",
"optionD":"b*=a;",
"answer":"C",
"explain":"    本题考查的是表达式的概念。\n    Java表达式是由操作数和运算符按一定的语法形式组成的符号序列，用来说明某个计算过程并返回计算结果。选项C中#不是运算符；其余选项都符合表达式的概念。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":255,
"title":"为使下列代码正常运行，应该在下划线处填入的选项是______。\nObjectInputStream in =\n             new ______(new FileInputStream(\"employee.dat\"));\nEmployee[] newStaff = (Employee[]) in.readObject();\nin.close();",
"optionA":"Reader",
"optionB":"InputStream",
"optionC":"ObjectInput",
"optionD":"ObjectInputStream",
"answer":"D",
"explain":"    本题考察的是对象的生成。\n    本题抛开程序功能不看，只看填空出现的位置，根据关键字new可知，该题考察的是对象的生成，生成对象的格式为\"type objectName=new type([参数]);\"，所以应该填\"ObjectInputStream\"。",
"type":"Java类库中对简单数据类型的类包装",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":256,
"title":"下列关于Applet的叙述中，错误的是______。",
"optionA":"Applet是Java类，所以可以由JDK中的解释器java.exe直接解释运行 ",
"optionB":"Applet应该定义为java.applet.Applet类或javax.swing.JApplet类的子类",
"optionC":"Applet与Application的主要区别在执行方式上",
"optionD":"通过在HTML文件中采用<PARAM>标记可以向Applet传递参数",
"answer":"A",
"explain":"    本题考查的是Applet的基础知识。\n    Applet是一类非常重要的Java程序，一般来说其嵌入在HTML语言中，它与Application不同之处在于，它必须要通过其它程序调用执行，本身不能被直接解释执行，故A是错的。Applet是java.applet.Applet的子类，如果其采用了swing构件，则是javax.swing.JApplet的子类，在HTML中可以通过<PARAM>标记向Applet传递参数。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":257,
"title":"下面______方法与applet的显示无关。",
"optionA":"update()",
"optionB":"draw()",
"optionC":"repaint()",
"optionD":"paint()",
"answer":"B",
"explain":"    本题考查的是Applet显示。\n    Applet显示相关的3个方法：\n    1、paint()方法：Applet的paint()方法具体执行Applet的绘制，该方法定义如下：\n    public void paint(Graphics g)\n    paint()方法有一个参数g是Graphics类的实例，该实例对象由浏览器生成，它包含了Applet的图形上下文信息，通过它向Applet中显示信息，该对象相当于Applet的画笔。在调用paint()方法时，由浏览器将该对象传递给paint()方法。\n    2、update()方法：\n    public void update(Graphics g)\n    用于更新Applet的显示。该方法将首先清除背景，再调用paint()方法完成Applet的具体绘制。\n    3、repaint()方法：\n    public void repaint()\n    repaint()方法主要用于Applet的重新显示，它调用update()方法实现对Applet的更新。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":258,
"title":"下面______不是Java中的容器。",
"optionA":"Frame",
"optionB":"Panel",
"optionC":"Scrollbar",
"optionD":"Dialog",
"answer":"C",
"explain":"    本题考查的是Java的容器。\n    容器java.awt.Container是Component的子类，一个容器可以容纳多个构件，并使他们成为一个整体。\n    常用的容器有Frame（窗口容器），Panel（面板容器），Applet（java小程序的容器），Dialog（对话框容器）等。\n    而本题选项中的Scrollbar是滚动条，它是一个构件，并不是容器。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":259,
"title":"______是short型的取值范围。 ",
"optionA":"-27～27-1",
"optionB":"0～216-1 ",
"optionC":"-215～215-1",
"optionD":"-231～231-1",
"answer":"C",
"explain":"    本题考查的是变量的范围。\n    短整型的数据类型的长度是16bits，有符号。另外需要说明的是Java中所有的整（Integer）数（包括byte，short，int，long）全是有符号的。 ",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":260,
"title":"下列程序的运行结果是______。\nint i=9; \nswitch (i) { \ndefault: \nSystem.out.println(\"default\"); \ncase 0: \nSystem.out.println(\"zero\"); \nbreak; \ncase 1: \nSystem.out.println(\"one\"); \ncase 2: \nSystem.out.println(\"two\"); \n} ",
"optionA":"default ",
"optionB":"default,zero ",
"optionC":"error default clause not defined",
"optionD":"没有输出结果",
"answer":"B",
"explain":"    本题考查的是switch语句的使用。\n    执行switch开关语句时，将变量逐个与case后的常量进行比较，若与其中一个相等，则执行该常量下的语句，直到遇到break语句才退出switch语句，执行其它的语句。若不与任何一个常量相等，则执行default后面的语句。 \n    注意： \n    1、switch中变量可以是数值，也可以是字符。 \n    2、可以省略一些case和default。 \n    3、每个case或default后的语句可以是语句体，但不需要使用\"{\"和\"}\"括起来。\n    本题在执行时，第一个遇到的是default语句，即执行它，输出default，再继续向下执行，直到遇到break为止，在继续向下执行的过程中，并不与case后面的数值进行比较。实际上，switch相当于一个开关语句，即遇到与自己匹配的数值就一直向下执行，相当于打开开关，直到遇到break为止，而default语句就相当i==i的一个语句，所以一遇到default语句就会执行。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":261,
"title":"下列不是InputStream子类的是______。",
"optionA":"文件输入流FileInputStream ",
"optionB":"对象输入流ObjectInputStream",
"optionC":"字符输入流CharInputStream",
"optionD":"压缩文件输入流ZipInputStream",
"answer":"C",
"explain":"    本题考查的是Java的输入输出流。\n    Java中没有CharInputStream流。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":262,
"title":"Panel和Applet的默认布局管理器是______。",
"optionA":"CardLayout ",
"optionB":"FlowLayout ",
"optionC":"BorderLayout",
"optionD":"GridLayout ",
"answer":"B",
"explain":"    本题考查的是布局管理器。\n    FlowLayout是java.applet.Applet、java.awt.Panel 和javax.swing.JPanel的缺省布局管理器；而BorderLayout是Window、Frame和Dialog的默认布局管理器。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":263,
"title":"下列关于Applet的说法中，错误的是______。",
"optionA":"Applet自身不能运行，必须嵌入到其它应用程序（如浏览器）中运行",
"optionB":"可以在安全策略的控制下读写本地磁盘文件 ",
"optionC":"Java中不支持向Applet传递参数 ",
"optionD":"Applet的主类要定义为java.applet.Applet类的子类",
"answer":"C",
"explain":"    本题考察的是Applet的概念。\n    Java中向Applet传递参数是通过在HTML文件中采用<PARAM>标记定义参数。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":264,
"title":"在读取二进制数据文件的记录时，为了提高效率常常使用一种辅助类______。",
"optionA":"InputStream ",
"optionB":"FileInputStream ",
"optionC":"StringBuffer ",
"optionD":"BufferedReader ",
"answer":"B",
"explain":"    本题考的是文件和文件I\/O。\n    FileInputStream可对一个磁盘文件涉及的数据进行处理。处理二进制数据不可以使用BufferedReader，否则提取的数据将不会保持原样。所以，此时需要FileInputStream类。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":265,
"title":"Java对文件类提供了许多操作方法，能获得文件对象父路径名的方法是______。",
"optionA":"getAbsolutePath() ",
"optionB":"getParentFile()",
"optionC":"getAbsoluteFile()",
"optionD":"getName()",
"answer":"B",
"explain":"    本题考的是File类提供的方法。\n    getAbsolutePath()：得到一个文件的绝对路径名；\n    getParentFile()：得到文件对象父路径名；\n    getAbsoluteFile()：等价于new File(this.getAbsolutePath())；\n    getName()：得到一个不包含路径的文件名。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":266,
"title":"下面程序中需要对Employee的对象进行存储，请在下划线处填入正确选项______。\nclass Employee implements ______{\n    …… \n}",
"optionA":"Comparable",
"optionB":"Serializable",
"optionC":"Cloneable",
"optionD":"DataInput",
"answer":"B",
"explain":"    本题考查的是对象的序列化。\n    题目中出现了关键字：\"implements\"，那么可以知道所要填的内容是接口。\n    接口是一种只含有抽象方法或常量的一种特殊的抽象类。通过java.io.Serializable接口序列化一个对象时，有关类的信息，比如它的属性和这些属性的类型，都与实例数据一起被存储起来。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":267,
"title":"阅读下面写文件的程序：\nimport java.io.*;\npublic class WriteFile{\n  public static void main(String[] A){\n     int[] myArray={10,20,30,40};\n     try{\n          FileOutputStream f=new FileOutputStream(\"ints.dat\");\n          DataOutputStream ______=new DataOutputStream(f);\n        for(int i=0;i<myArray.length;i++)\n                 dos.writeInt(myArray[ i ]);\n              dos.close();\n              System.out.println(\"Have written binary file ints.dat\");\n            }\n            catch(IOException ioe){\n                System.out.println(\"IO Exception\");\n            }\n     }\n}\n在程序下划线处填入正确选项是______。",
"optionA":"myArray ",
"optionB":"dos ",
"optionC":"ioe",
"optionD":"ints",
"answer":"B",
"explain":"    本题考查的是输入与输出。\n    在程序中，首先定义一个整型数组myArray，其中包含四个元素。文件输入流FileOutputStream用于对磁盘文件涉及的数据流进行输出处理，在本程序中，即向ints.dat中写入数据。DataOutputStream类具备数据类型或格式转换的功能，即向流中写入数据时，可以实现对二进制字节数据的编码功能。本题中可以看出，在for循环中，writeInt(myArray[i])把对应的数组元素按四个字节，二进制形式写到输出流里，此处是文件输出流。根据\"dos.writeInt(myArray[i]);\"可以判断填空处应该填对象\"dos\"。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":268,
"title":"下列可用作switch(expression)语句参数的是______。",
"optionA":"String s",
"optionB":"Integer i ",
"optionC":"boolean b",
"optionD":"int i",
"answer":"D",
"explain":"    本题考查的是多分支语句。\n    在switch语句中，表达式expression只能返回这几种类型的值：int、byte、short和char。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":269,
"title":"Java类库中，将信息写入内存的类是______。",
"optionA":"java.io.FileOutputStream",
"optionB":"java.io.ByteArrayOutputStream",
"optionC":"java.io.BufferedOutputStream",
"optionD":"java.io.DataOutputStream",
"answer":"B",
"explain":"    本题考查的是输入输出及文件操作。\n    FileOutputStream：用于对磁盘文件涉及的数据流进行输出处理，即向一个文件对象中写入数据。\n    ByteArrayOutputStream：字节数组输出流。这个类将一个字节数组作为输出流，而任何内存块都可以以字节数组的形式使用，故利用该类可以对内存进行写入操作。\n    BufferedOutputStream：缓冲区优化了字节数据传送。\n    DataOutputStream：进行字节输出的基本数据类型判断。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":270,
"title":"阅读下列程序片段\npublic void test() {\n   try {\n     sayHello();\n     System.out.println(\"Hello\");\n   } catch (ArrayIndexOutOfBoundsException e) {\n    System.out.println(\"ArrayIndexOutOfBoundsException \");\n   } catch(Exception e) {\n       System.out.println(\"Exception\");\n   } finally {\n      System.out.println(\"finally\");\n   }\n}\n如果sayHello()方法正常运行，则test()方法的运行结果将是______。",
"optionA":"Hello",
"optionB":"ArrayIndexOutOfBoundsException",
"optionC":"Exception\nfinally ",
"optionD":"Hello\nfinally ",
"answer":"D",
"explain":"    本题考查的是自定义异常类。\n    当异常已被定义时，必须通过try-catch-finally语句处理它，其语法如下：\ntry\n{\n  可能出现异常的程序代码\n}\ncatch(异常类名1 异常对象名1)\n{\n  异常类名1对应的异常处理代码\n}\ncatch(异常类名2 异常对象名2)\n{\n  异常类名2对应的异常处理代码\n}\n   .\n   .\n   .\nfinally\n{\n  必须执行的代码\n}\n    说明：\n    1）将可能发生异常的程序代码放置在try程序块中。程序运行过程中，如果该块内的代码没有出现任何异常，将正常执行，后面的各catch块不起任何作用。但如果该块内的代码出现了异常，系统将终止try块代码的执行，自动跳转到所发生的异常类对应的catch块中，执行该块中的代码。\n    2）其中的finally块是个可选项，如果包含有finally块，无论异常是否发生，finally块的代码必定执行。如果没有异常的出现，当执行完try块内的代码后，将执行finally块。如果出现了异常，执行完对应异常类的catch块后，将执行finally块。\n    3）一个try块可以对应多个catch块，用于对多个异常类进行捕获。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":271,
"title":"下列为窗口事件的是______。",
"optionA":"MouseEvent",
"optionB":"WindowEvent",
"optionC":"ActionEvent",
"optionD":"KeyEvent",
"answer":"B",
"explain":"    本题考查的是AWT事件。\n    AWT有关的所有事件都放置在java.awt.event包中。选项A）MouseEvent表示鼠标事件；选项B）WindowEvent表示窗口事件；选项C）ActionEvent表示动作事件；选项D）KeyEvent表示键盘事件。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":272,
"title":"下列代码将对象写入的设备是______。\n  ByteArrayOutputStream bout=new ByteArrayOutputStream();\n  ObjectOutputStream out=new ObjectOutputStream(bout);\n  out.writeObject(this);\n  out.close();",
"optionA":"内存 ",
"optionB":"硬盘 ",
"optionC":"屏幕 ",
"optionD":"网络 ",
"answer":"A",
"explain":"    本题考查的是Java中包含的输入\/输出流的类。\n    ByteArrayOutputStream，字节数组输出流。这个类将一个字节数组作为输出流。这个用于存储输出数据的内部字节数组长度可以按照需要增长。\n    ObjectOutputStream既继承了OutputStream抽象类，又实现了ObjectOutput接口，这是Java用接口技术代替双重继承例子，其构造方法参数是串行化了的对象。\n    在java.io中，ByteArrayOutputStream是OutputStream的子类，可以直接访问内存。用ByteArrayOutputStream可以向字节数组（缓冲区）写入数据。\n    所以，本题代码段的作用是将对象写入内存。",
"type":"运算符和表达式运算",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":273,
"title":"与Applet生命周期相关的方法的数量是______。",
"optionA":"4种 ",
"optionB":"3种 ",
"optionC":"2种 ",
"optionD":"5种 ",
"answer":"A",
"explain":"    本题考查的是Applet生命周期概念。\n    在Applet程序序中有如下几个方法与其生命周期相关：init()方法用来在加载Applet时完成初始化工作；start()方法用来启动Applet的执行；stop()用来停止Applet的执行，例如，用户离开Applet页面或浏览器；destory()用来完成撤消清理工作，准备卸载。因此在与Applet生命周期相关的方法的数量为四个。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":274,
"title":"下列______内容是异常的含义。",
"optionA":"程序的语法错",
"optionB":"程序编译或运行中所发生的异常事件",
"optionC":"程序预定义好的异常事件 ",
"optionD":"程序编译错误",
"answer":"B",
"explain":"    本题考查的是异常的概念。\n    对程序语言而言，编写程序时出现错误是不可避免的，一般有编译错和运行错两类。Java语言认为那些可预料和不可预料的编译和运行时的出错称为异常。在Java语言中，把异常也作为一种对象，它在程序运行出错时被创建，异常控制是Java语言处理程序出错的有效机制。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":275,
"title":"自定义的异常类可从下列______类继承。",
"optionA":"Error类",
"optionB":"AWTError",
"optionC":"VirtualMachineError",
"optionD":"Exception及其子类",
"answer":"D",
"explain":"    本题考查的是异常类。\n    Java语言的类库中提供一个Throwable类，所有的异常对象都必须是它的实例或它子类的实例。Throwable类又分为Error和Exception两子类，Error类包括动态连接失败、硬件设备和虚拟机出错等，通常的Java应用程序不会捕获和抛出这类异常，而是捕获和抛出Exception这类异常。\n    所以自定义的异常是从Exception及其子集继承的。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":276,
"title":"______是将一个十六进制值赋值给一个long型变量。",
"optionA":"long number=345L;",
"optionB":"long number=0345;",
"optionC":"long number=0345L; ",
"optionD":"long number=0x345L;",
"answer":"D",
"explain":"    本题考查的是变量的初始化。\n    十六进制数以0x开头，long型数以L（大小写均可，一般使用大写，因为小写的l和数字1不易区分）。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":277,
"title":"下列关于for循环和while循环的说法中______是正确的。",
"optionA":"while循环能实现的操作，for循环也都能实现",
"optionB":"while循环判断条件一般是程序结果，for循环判断条件一般是非程序结果",
"optionC":"两种循环任何时候都可替换",
"optionD":"两种循环结构中循环体都不可以为空",
"answer":"A",
"explain":"    本题考查的是循环语句的使用。\n    for循环的一般形式为：\n    for(<初始化>; <条件表过式>; <增量>) \n          语句; \n    初始化总是一个赋值语句，它用来给循环控制变量赋初值；条件表达式是一个关系表达式，它决定什么时候退出循环；增量定义循环控制变量每循环一次后按什么方式变化。这三个部分之间用\";\"分开。 \n    例如：\n    for(i=1; i<=10; i++) \n        语句; \n    上例中先给i赋初值1，判断i是否小于等于10，若是则执行语句，之后值增加1。再重新判断，直到条件为假，即i>10时，结束循环。 \n    注意：\n    1、for循环中语句可以为语句体，但要用\"{\"和\"}\"将参加循环的语句括起来。 \n    2、for循环中的\"初始化\"、\"条件表达式\"和\"增量\"都是选择项，即可以缺省，但\";\"不能缺省。省略了初始化，表示不对循环控制变量赋初值。省略了条件表达式，则不做其它处理时便成为死循环。省略了增量，则不对循环控制变量进行操作，这时可在语句体中加入修改循环控制变量的语句。与for循环一样，while循环总是在循环的头部检验条件，这就意味着循环可能什么也不执行就退出。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":278,
"title":"下列方法中可以用来创建一个新线程的是______。",
"optionA":"实现java.lang.Runnable接口并重写start()方法",
"optionB":"实现java.lang.Runnable接口并重写run()方法",
"optionC":"继承java.lang.Thread类并重写run()方法",
"optionD":"继承java.lang.Thread类并重写start()方法",
"answer":"C",
"explain":"    本题考查的是Java语言中线程的创建方法。\n    java.lang中的Thread类的典型构造方法为：\n    public Thread(ThreadGroup group,Runnable target,String name)\n    接口Runnable定义了run()方法；而Thread类本身也实现了Runnable接口，故创建线程有两种方法：\n     1、用实现Runnable接口的类的实例作target参数生成Thread类的实例\n     2、编写继承Thread类的类，并重写（override）run()方法",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":279,
"title":"Swing构件必须添加到Swing顶层容器相关的______。",
"optionA":"选项板上",
"optionB":"复选框内  ",
"optionC":"内容面板上",
"optionD":"分隔板上",
"answer":"C",
"explain":"    本题考查的是Swing构件。\n    在Swing中用轻量级的构件替代了AWT中的重量级的构件，而且Swing的替代构件中都包含有一些其他的特性。与AWT构件不同，Swing构件不能直接添加到顶层容器中，它必须添加到一个与Swing顶层容器相关联的内容面板（contentPane）上。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":280,
"title":"下列选项中，不是APPLET标记的是______。",
"optionA":"PARAM",
"optionB":"BODY",
"optionC":"CODEBASE",
"optionD":"ALT",
"answer":"B",
"explain":"    本题考察的是APPLET标记。\n    PARAM：在HTML文件中定义参数；\n    CODEBASE=codebaseURL：这个可选的属性指定Applet的URL地址，该URL是包含了Applet代码的目录。如果这个属性没有给出，就采用<APPLET>标记所在的HTML文件URL地址；\n    ALT=alternateText。这个可选属性指定了一些文字，当浏览器能够理解<Applet>标记但不能运行Java Applet时，将显示这些文字。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":281,
"title":"可以使当前同级线程重新获得运行机会的方法是______。",
"optionA":"sleep()",
"optionB":"join()",
"optionC":"yield()",
"optionD":"interrupt()",
"answer":"C",
"explain":"    本题考的是线程的概念和使用。\n    yield()：调用该方法后，可以使具有与当前线程相同优先级的线程有运行的机会。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":282,
"title":"下列叙述中，错误的是______。",
"optionA":"Java中没有检测和避免死锁的专门机制",
"optionB":"程序中多个线程互相等待对方持有的锁，可能形成死锁",
"optionC":"为避免死锁，Java程序中可先定义获得锁的顺序，解锁是按加锁的反序释放",
"optionD":"为避免死锁，Java程序中可先定义获得锁的顺序，解锁是按加锁的正序释放",
"answer":"D",
"explain":"    本题考的是死锁的防治。\n    如果程序中多个线程互相等待对方所持有的锁，而在得到对方锁之前都不会释放自己的锁，这就造成了双方都无法得到想得到资源，线程不能继续运行，这就是死锁。Java中没有检测与避免死锁的专门机制，为了避免死锁，应用程序可以采用的一般做法是：如果程序要访问多个共享数据，则首先要从全局考虑定义一个获得锁的顺序，并且在整个程序中都遵守这个顺序。解锁时，要按加锁的反序释放。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":283,
"title":"阅读下面程序\npublic class Test4{\n    public static void main(String args[]){\n        int i=10,j=3;\n        float m=213.5f ,n=4.0f;\n        System.out.println(i%j);\n        System.out.println(m%n);\n    }\n}\n程序运行的结果是______。",
"optionA":"1.0和1.5 ",
"optionB":"1和1.5",
"optionC":"1.0和2.5",
"optionD":"1和2.5",
"answer":"B",
"explain":"    本题考查的是取模运算在整数和浮点数中的应用。\n    在Java中，取模（求余）运算符%属于二元算术运算符，对于二元算术运算符，其表达式结果的类型归纳为以下几类情况：\n    （1）操作数全为整型，那么，只要其中有一个为long型，则表达式结果为long型；\n    （2）两个操作数全是byte型或short型，表达式结果为int型；\n    （3）操作数为浮点型，只要其中有一个为double型，表达式结果就是double型；\n    （4）两个操作数全是float型或其中一个是float型，而另外一个是整型，则表达式结果为float型。\n    本题表达式\"10%3\"中的操作数均为整型，所以结果为整数1；表达式\"213.5%4.0\"中的操作数均为浮点型，所以结果为浮点数1.5。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":284,
"title":"阅读下面程序\npublic class Test2 ______{\n  public static void main(String[] args){\n    Thread t=new Test2();\n     t.start();\n  }\n public void run(){\n    System.out.println(\"How are you.\"); \n }\n}\n在程序下划线处填入正确选项是______。",
"optionA":"implements Thread",
"optionB":"extends Runnable",
"optionC":"implements Runnable",
"optionD":"extends Thread",
"answer":"D",
"explain":"    本题考查的是多线程。\n    该程序实现了线程的创建。\n    在JAVA中，创建线程的方法有两种：一种是通过创建Thread类的子类来实现，另一种方法是通过实现Runnable接口的类来实现。\n    通过继承Thread类实现多线程的方法是首先设计Thread的子类，然后根据工作需要重新设计线程的run方法，再使用start方法启动线程，将执行权转交到run。\n    通过Runable接口实现多线程的方法是首先设计一个实现Runnable接口的类，然后根据工作需要重新设计线程的run方法；再建立该类的对象，以此对象为参数建立Thread类的对象；调用Thread类对象的start方法启动线程，将执行权转交到run方法。\n    根据语句\"Thread t=new Test2();\"可以判断出下划线处填入\"extends Thread\"。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":285,
"title":"当浏览器重新返回到包含Applet的页面时调用的方法是______。",
"optionA":"start()",
"optionB":"init()",
"optionC":"stop()",
"optionD":"destroy()",
"answer":"A",
"explain":"    本题考查的是Applet的生命周期。\n    当浏览器重新返回Applet所在页面时，Applet类的start()方法将被调用。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":286,
"title":"阅读下列Java语句\nObjectOutputStream out =\n        new ObjectOutputStream(new ______(\"employee.dat\"));\n在下划线处，应填的正确选项是______。",
"optionA":"File ",
"optionB":"FileWriter ",
"optionC":"FileOutputStream",
"optionD":"OutputStream",
"answer":"C",
"explain":"    本题考查的是输入输出及文件操作。\n    ObjectOutputStream：既继承了OutputStream抽象类，又实现了ObjectOutput接口，这是Java用接口技术代替双重继承例子，其构造方法参数是串行化了的对象。\n    FileOutputStream：用于对磁盘文件涉及的数据流进行输出处理，即向一个文件对象中写入数据。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":287,
"title":"为使Java程序独立于平台，Java虚拟机把字节码与各个操作系统及硬件______。",
"optionA":"分开",
"optionB":"结合",
"optionC":"联系",
"optionD":"融合",
"answer":"A",
"explain":"    本题考查的是Java语言实现的机制。\n    Java语言的执行模式是半编译和半解释型。Java编写好的程序首先由编译器转换为标准字节代码，然后由Java虚拟机去解释执行。字节代码也是一种二进制文件，但不能直接在操作系统上运行，它可看作虚拟机的机器码。虚拟机把字节代码程序与各操作系统和硬件分开，使Java程序独立于平台。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":288,
"title":"用鼠标点击菜单项（MenuItem）产生的事件是______。",
"optionA":"MenuEvent",
"optionB":"ActionEvent",
"optionC":"KeyEvent ",
"optionD":"MouseEvent",
"answer":"B",
"explain":"    本题考查的是语义事件ActionEvent。\n    ActionEvent指示发生了组件定义的动作的语义事件。当特定于组件的动作（比如按钮点击、菜单选择、选择列表项、在文本域中键入enter）发生时，由组件生成此高级事件。事件被传递给每一个ActionListener对象，这些对象是使用组件的addActionListener方法注册的，用以接收这类事件。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":289,
"title":"为使下列代码正常运行，应该在下划线处填入的选项是______。\n  int[] numbers=new int[n];\n  for(int i=0;i<numbers.______;i++)\n      numbers[i]=i+1;",
"optionA":"size",
"optionB":"length",
"optionC":"dimension",
"optionD":"measurement",
"answer":"B",
"explain":"    本题考察的是数组。\n    初始化了数组后，如果想知道其元素个数，可以通过属性length获得，其格式为：数组名.length。本题程序的作用是对数组numbers内的每个元素赋初值。",
"type":"数组和字符串",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":290,
"title":"下列属于正则表达式的是______。",
"optionA":"一个数组 ",
"optionB":"一组二进制数据",
"optionC":"一个字符串",
"optionD":"一个公式",
"answer":"D",
"explain":"    本题考查的是正则表达式。\n    正则表达式必须对字符串进行匹配，因此选项A是错误的，对于任一二进制串，正则表达式也无法匹配，对于一个回文字串，正则表达式无法匹配，故选取项A、B、C也都是错误的，对于一个公式，由于其符合3型文法标准，故必能与正则表达式相匹配。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":291,
"title":"当方法遇到异常又不知如何处理时，下列______做法是正确的。",
"optionA":"捕获异常",
"optionB":"抛出异常",
"optionC":"声明异常",
"optionD":"嵌套异常",
"answer":"C",
"explain":"    本题考查的是异常的声明。\n    在Java语言中，有时一个方法生成一个异常，但该方法并不能确定如何处理此异常，如找不到文件之类的异常，必须将异常传递给调用方法，由调用它的方法来处理，这种时候方法用声明异常抛出，让异常对象可从调用栈向后传递，直至有相应的方法捕获它为止。所以当方法遇到异常又不知如何处理时，应声明异常。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":292,
"title":"对于catch子句的排列，下列______是正确的。",
"optionA":"父类在先，子类在后",
"optionB":"子类在先，父类在后",
"optionC":"有继承关系的异常不能在同一个try程序段内",
"optionD":"先有子类，其他如何排列都无关",
"answer":"B",
"explain":"    本题考查的是异常的捕获。\n    在Java中提供了结构化的异常处理功能，其主要是通过try...catch语句来实现的。在Java中可以将可能产生异常的代码放入到try子句中，如果产生异常，将会执行catch子句。如果有多个异常，则应先处理子类异常，再处理父类异常，否则后面的异常处理，将得不到执行。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":293,
"title":"下面的______程序片断可能导致错误。",
"optionA":"String s = \"Gone with the wind\";\nString t = \" good \";\nString k = s + t; ",
"optionB":"String s = \"Gone with the wind\";\nString t;\nt = s[3] + \"one\"; ",
"optionC":"String s = \"Gone with the wind\";\nString standard = s.toUpperCase(); ",
"optionD":"String s = \"home directory\";\nString t = s + 3; ",
"answer":"B",
"explain":"    本题考查的是字符串类型数据的使用。\n    选项A：String类型可以直接使用+进行连接运算。\n　  选项B：String是一种Object，而不是简单的字符数组，不能使用下标运算符取其值的某个元素，错误。\n　  选项C：toUpperCase()方法是String对象的一个方法，作用是将字符串的内容全部转换为大写并返回转换后的结果（String类型）。\n　  选项D：String类型可以和数字进行加运算。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":294,
"title":"下列关于Java Application与Java Applet程序的差别描述正确的是______。",
"optionA":"运行方式不同，程序结构相同，运行工具不同，受到的限制相同",
"optionB":"运行方式相同，程序结构不同，运行工具不同，受到的限制相同",
"optionC":"运行方式相同，程序结构相同，运行工具不同，受到的限制也不同",
"optionD":"运行方式不同，程序结构不同，运行工具不同，受到的限制也不同",
"answer":"D",
"explain":"    本题考查的是程序的结构中Java Application和Java Applet的区别。\n    Java语言是一种半编译半解释的语言。Java的用户程序分为两类：Java Application和Java Applet。这两类程序在组成结构和执行机制上都有一定的差异，主要体现在以下几方面：\n（1）运行方式不同。Java Application是完整的程序，可以独立运行；Java Applet程序不能单独运行，它必须嵌入到用HTML语言编写的Web页面中，通过与Java兼容的浏览器来控制执行。\n（2）运行工具不同。Java Application程序被编译以后，用普通的Java解释器就可以使其边解释边执行，而Java Applet必须通过网络浏览器或者Applet观察器才能执行。\n（3）程序结构不同。每个Java Application程序必定含有一个并且只有一个main方法，程序执行时，首先寻找main方法，并以此为入口点开始运行。含有main方法的那个类，常被称为主类，也就是说，Java Application程序都含有一个主类。而Applet程序则没有含main方法的主类，这也正是Applet程序不能独立运行的原因。尽管Applet没有含main方法的主类，但Applet一定有一个从java.applet.Applet派生的类，它是由Java系统提供的。\n（4）受到的限制不同。Java Application程序可以设计成能进行各种操作的程序，包括读／写文件的操作，但是 Java Applet 对站点的磁盘文件既不能进行读操作，也不能进行写 操作。然而，由于Applet的引入，使Web页面具有动态多媒体效果和可交互性能，这使由名为超文本、实为纯文本的HTML语言编写成的Web页面真正具有了超文本功能，不但可以显示文本信息，而且还可以有各种图片效果和动态图形效果，从而使页面显得生动美丽；另外，Applet使Web页面增加了按钮等功能，从而增加了交互性。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":295,
"title":"下列关于Java Application与Applet的说法中，正确的是______。",
"optionA":"都包含main()方法",
"optionB":"都通过\"appletviewer\"命令执行",
"optionC":"都通过\"javac\"命令编译",
"optionD":"都嵌入在HTML文件中执行",
"answer":"C",
"explain":"    本题考查的是Java Application和Applet。\n    Java Application本身是一个类，该类必须有且只有一个main()方法（不能多载）；Java Applet本身不能独立运行，必须由支持Applet的浏览器或其它软件加载运行。但Java Application和Java Applet都是通过javac编译的。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":296,
"title":"查找随机文件的记录时，应使用的方法是______。",
"optionA":"readInt()    ",
"optionB":"readBytes(int n)",
"optionC":"seek(long l)  ",
"optionD":"readDouble()",
"answer":"C",
"explain":"    本题考查的是文件操作。\n    文件操作中经常需要的是随机访问，Java中的RandomAccessFile类提供随机访问文件的功能，其中的seek方法实现了查找随机文件记录的功能，格式如下：\n    void seek( long pos ); \/\/用于移动文件指针到指定的位置",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":297,
"title":"在Java中，与数据库连接的技术是______。",
"optionA":"ODBC",
"optionB":"JDBC",
"optionC":"数据库厂家驱动程序",
"optionD":"数据库厂家的连接协议",
"answer":"B",
"explain":"    本题考察的是JDBC的概念。\n    JDBC(Java DataBase Connectivity)是Java程序与数据库连接的一种机制，用JDBC写的程序能够自动地将SQL语句传送给相应的数据库管理系统。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":298,
"title":"阅读下面程序\n1  public class Try extends Thread{\n2      public static void main(String args[]){\n3         Try t=new Try();\n4         t.start();\n5     }\n6\n7  public void run(int j){\n8     int i=0;\n9      while(i<5){\n10         System.out.println(\"祝你成功！\");\n11         i++;\n12 }\n13    }\n14  }\n该程序要求打印5行\"祝你成功！\"，必须改正程序中的某行代码，程序才能完成。选择正确的修改是______。",
"optionA":"将第1行的extends Thread改为implements Runnable",
"optionB":"将第3行的new Try()改为 new Thread()",
"optionC":"将第4行t.start()改为start(t)",
"optionD":"将第7行的public void run(int j)改为public void run()",
"answer":"D",
"explain":"    本题考的是线程的创建。\n    Java中的线程体是由线程类的run()方法定义，在该方法中定义线程的具体行为。该程序通过继承Thread类，重写其中的run()方法，run()方法中不能带参数。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":299,
"title":"请阅读下面程序\npublic class ThreadTest{\n   public static void main(String args[]) throws Exception{\n      int i=0;\n      Hello t=new Hello();\n      ______;\n      while(true){\n          System.out.println(\"Good Morning\"+i++);\n          if(i==2&&t.isAlive()){\n              System.out.println(\"Main waiting for Hello!\");\n             t.join(); \/\/等待t运行结束\n        }\n      if(i==5) break;}\n   }\n}\nclass Hello extends Thread{\n  int i;\n  public void run(){\n     while(true){\n       System.out.println(\"Hello\"+i++);\n       if(i==5) break;}}}\n为使该程序正确执行，下划线处的语句应是______。",
"optionA":"t.sleep()",
"optionB":"t.yield()",
"optionC":"t.interrupt()",
"optionD":"t.start()",
"answer":"D",
"explain":"    本题考的是线程的调度与控制。\n    sleep()：该方法使一个线程暂停运行一段固定的时间，在其休眠时间内，让优先级比其低的线程运行；\n    yield()：该方法使具有与当前线程相同优先级的线程有运行的机会；\n    interrupt()：如果一个线程在调用sleep()，join()，wait()等方法被阻塞时，则interrupt()方法将中断其阻塞状态，并且该线程将接收到InterruptException异常；\n    start()：新建的线程不会自动运行，必须调用该方法。调用该方法把嵌入在线程中的虚拟CPU置为可运行状态，意味着它可以被调度，但并不意味着该线程会立刻执行。\n    根据程序可知，在ThreadTest类中，当i=2且线程t已启动，则在输出\"Main waiting for Hello!\"后暂停当前线程，执行线程t。若线程t未通过\"t.start();\"语句启动，则当i=2时也不会执行线程t，所以横线处应填启动线程t的语句，开始运行线程t，当t运行5次结束后，继续调用i线程将剩下的循环调用3次结束。所以，在创建Hello类的对象t后，应该调用start()方法使其进入可运行状态，等待被调用。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":300,
"title":"阅读下面程序\nimport java.io.*;\npublic class ByteStreamTest{\n    public static void main(String[] a){\n        int [] myArray = {10,20,30,40};\n        try{\n DataOutputStream dos = new DataOutputStream\n            (new _________________(\"ints.dat\"));\n for(int i=0;i<myArray.length;i++)\n            dos.writeInt(myArray[i]);\n        dos.close();\n System.out.println(\"Have written binary file ints.dat\");\n        }\n        catch (IOException ioe){\n        System.out.println(\"IO Exception\");\n        }\n    }\n}\n为保证程序正确运行，在程序中下划线处应填入的代码是______。",
"optionA":"FileOutputStream",
"optionB":"ByteArrayOutputStream ",
"optionC":"BufferedOutputStream ",
"optionD":"FileWriter ",
"answer":"A",
"explain":"    本题考查的是构造函数。\n    本题中A选项的格式和内容是正确的；B选项，其构造函数的正确格式应该为：ByteArrayOutputStream(int)，构造函数为一个整型变量或不带参数，不能是字符串；C选项，其构造函数正确格式为：BufferedOutputStream(OutputStream)或BufferedOutputStream(OutputStream,int)，它不接受字符串作为其构造函数；D选项，其构造函数正确格式为：FileWriter(File)或，FileWriter(String)，但FileWriter只用来对字符流进行操作，不满足DataOutputStream的要求。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":301,
"title":"阅读下面程序\npublic class Test implements Runnable{\n  public static void main (String[] args){\n     ______\n     t.start();\n   }\n   public void run(){\n     System.out.println(\"Hello!\");\n   }\n}\n在程序下划线处填入正确选项是______。",
"optionA":"Test t=new Test();",
"optionB":"Thread t=new Thread(); ",
"optionC":"Thread t=new Thread(new Test()); ",
"optionD":"Test t=new Thread(); ",
"answer":"C",
"explain":"    本题考查的是多线程。\n    该程序实现了线程的创建。\n    在JAVA中，创建线程的方法有两种：一种是通过创建Thread类的子类来实现，另一种方法是通过实现Runnable接口的类来实现。\n    通过继承Thread类实现多线程的方法是首先设计Thread的子类，然后根据工作需要重新设计线程的run方法，再使用start方法启动线程，将执行权转交到run。\n    通过Runable接口实现多线程的方法是首先设计一个实现Runnable接口的类，然后根据工作需要重新设计线程的run方法；再建立该类的对象，以此对象为参数建立Thread类的对象；调用Thread类对象的start方法启动线程，将执行权转交到run方法。\n    根据\"public class Test implements Runnable\"可以判断出下划线处填入\"Thread t=new Thread(new Test());\"。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":302,
"title":"阅读下列代码\npublic class Test{\n  public static void main (String args[]){\n    System.out.println((2<0)?10:8);\n    }\n}\n其运行结果是______。",
"optionA":"2",
"optionB":"0",
"optionC":"10",
"optionD":"8",
"answer":"D",
"explain":"    本题考查的是条件运算符与条件表达式。\n    \"?:\"是条件运算符，条件运算符是三元运算符。\n    三元条件表达式的一般形式为：\n    expressinon1?expression2:expression3\n    其中表达式expression1应该是关系或布尔表达式，其计算结果为布尔值。如果该值为true，则计算表达式expression2，并将计算结果作为整个表达式的结果；如果为false，则计算表达式expression3，将计算结果作为条件表达式的结果。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":303,
"title":"使新创建的线程参与运行调度的方法是______。",
"optionA":"run()",
"optionB":"start()",
"optionC":"init()",
"optionD":"resume()",
"answer":"B",
"explain":"    本题考查的是线程状态与生命周期。\n    线程的生命周期主要分为如下几个状态：新建状态、可运行状态、运行状态、阻塞状态、终止状态。\n    用new关键字和thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":304,
"title":"Java中的基本数据类型int在不同的操作系统平台的字长是______。",
"optionA":"不同的",
"optionB":"32位",
"optionC":"64位",
"optionD":"16位",
"answer":"B",
"explain":"    本题考查的是整型数据。\n    int类型是最常用的整数类型，它存储时占32位bit，能表示的数据范围比较大，是-2147483648～+2147483647。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":305,
"title":"下列不属于逻辑运算符的是______。",
"optionA":"!",
"optionB":"||",
"optionC":"&&",
"optionD":"|",
"answer":"D",
"explain":"    本题考查的是逻辑运算符。\n    逻辑运算符用于布尔逻辑运算。逻辑与运算符（&&）、逻辑或运算符（||）、逻辑非运算符（!）能生成一个布尔值（true或false）。选项A）为逻辑非运算符，选项B）为逻辑或运算符，选项C）为逻辑与运算符，选项D）为按位或运算符，属于位运算符。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":306,
"title":"为使下列代码正常运行，应该在下划线处填入的选项是______。\n  abstract class Person{\n      public Person(String n){\n          name=n;\n      }\n      public ______ String getDescription();\n      public String getName(){\n          return name;\n      }\n      private String name;\n  }",
"optionA":"static",
"optionB":"private ",
"optionC":"abstract",
"optionD":"final",
"answer":"C",
"explain":"    本题考察的是修饰符的使用。\n    用abstract修饰的方法表示抽象方法，抽象方法没有方法体。程序中的getDescription()没有方法体，符合abstract的使用规则。",
"type":"Java语言的基本语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":307,
"title":"下列关于线程调度的叙述中，错误的是______。",
"optionA":"调用线程的sleep()方法，可以使比当前线程优先级低的线程获得运行机会",
"optionB":"调用线程的yield()方法，只会使与当前线程相同优先级的线程获得运行机会",
"optionC":"当有比当前线程的优先级高的线程出现时，高优先级线程将抢占cpu并运行 ",
"optionD":"具有相同优先级的多个线程的调度一定是分时的",
"answer":"D",
"explain":"    本题考查的是线程的相关知识。\n    Java的线程调度策略是一种基于优先级的抢先式调度。这种调度策略的含义是：Java基于线程的优先级选择高优先级的线程进行运行。该线程（当前线程）将持续运行，直到它中止运行或其它更高优先级程成为可运行时。所以选项C的叙述是正确的。在线程的几种基本控制方法中，sleep()方法使比其低的优先级线程运行；yield()方法只让给同优先级运行。所以选项A、B的叙述均是正确的。\n    抢先式调度可能是分时的，即每个池中的轮流运行；也可能不是，即线程逐个运行。所以即使具有相同优先级的多个线程的调度也不一定是分时的，它的运行方式是由具体JVM而定的。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":308,
"title":"计算机中的流是______。",
"optionA":"流动的字节",
"optionB":"流动的对象",
"optionC":"流动的文件",
"optionD":"流动的数据缓冲区",
"answer":"D",
"explain":"    本题考查的是流的概念。\n    流，最早从C语言中引入的。其可以看成是一个流动的数据缓冲区。数据从数据源方向经过缓冲区流向数据的目的地。在传送的过程中，其传送方式是串行的。在Java中的java.io包中定义了Java中常见流的接口与类。其中包括两个最基本的流的抽象类，它们分别是OutputStream与InputStream。其余的流都分别从这两个基本类中继承而来。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":309,
"title":"当输入一个字节流时，要______。",
"optionA":"实现DataInput接口",
"optionB":"实现ObjectInput接口",
"optionC":"实现Serializable接口",
"optionD":"继承Reader抽象类",
"answer":"A",
"explain":"    本题考查的是字节流。\n    在Java中，输入一个字节流时，要实现DataInput接口。该接口定义在java.io包中。处理字节流的DataInputStream类实现了该接口。同时，DataOutput接口提供了字节输出流的功能，RandomAccessFile类实现了DataInput与DataOutput这两种接口。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":310,
"title":"Java Application程序执行的入口点main()方法的返回类型是______。",
"optionA":"void",
"optionB":"int",
"optionC":"static",
"optionD":"boolean",
"answer":"A",
"explain":"    本题考查的是main函数的结构。 \n    main()方法是一个特殊的方法，它是所有的Java Application程序执行的入口点，所以任何一个Java Application方法必须有且只能有一个main()方法，而且这个main()方法的方法头必须按照下面的格式书写：\n    public static void main(String args[])\n    或public static void main(String[] args)\n    因为对于一个方法来讲，它是由方法头和方法体组成，其中方法头的一般格式如下：\n    修饰符1 修饰符2 ……返回值类型 方法名（形式参数列表）throw[异常列表]\n    所以，main()方法头中的public、static属于修饰符，void是返回类型，main为方法名，String args[]是形式参数。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":311,
"title":"下列______选择项的注释是错误的。",
"optionA":"\/\/int a,b,c",
"optionB":"\/** int a,b ,c *\/",
"optionC":"{int a,b,c}\n*\/",
"optionD":"\/*\nint a,b\nString a *\/ ",
"answer":"C",
"explain":"    本题考查的是注释符的使用。\n    在Java语方中有3种注释语句：第1种是以\/\/符开始的单行注释语句；第2种是由\/*开始，*\/结束的多行注释语句，例如选项D；第3种是由\/**开始，以*\/结束的可生成帮助文档的注释语句。可以用来注释多行，{ }是用于表示程序段的符号。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":312,
"title":"当启动Applet程序时，首先调用的方法是______。",
"optionA":"stop()",
"optionB":"init()",
"optionC":"start() ",
"optionD":"destroy()",
"answer":"B",
"explain":"    本题考查的是Applet的生命周期。\n    Applet从被加载到卸载，其被调用的方法依次如下：\n    init()、start()、stop()、destroy()",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":313,
"title":"自定义表格类中的model部分应实现的接口是______。",
"optionA":"AbstractTableModel",
"optionB":"JTable",
"optionC":"TableModel ",
"optionD":"TableModelable",
"answer":"A",
"explain":"    本题考查的是自定义表格类。\n    自定义表格类中的model部分应实现接口AbstractTableModel。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":314,
"title":"下列命题中，错误的是______。",
"optionA":"Java 编程时，要求应尽量多用公共变量 ",
"optionB":"Java 编程时，要求应尽量少用公共变量 ",
"optionC":"Java 编程时，要求应尽量不用公共变量 ",
"optionD":"Java 编程时，要求应尽量使用私有变量",
"answer":"A",
"explain":"    本题考察的是编程技巧。\n    由于公共变量在获取与设置时，不能够进行有效的安全性检查，在java中的一般做法是将其设置成私有变量，然后通过接口方法对这些变量进行读取或赋值，这样就可以检查用户所赋的值或在返回用户所需要的值时执行必要的代码。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":315,
"title":"下列事件监听器中，无法对TextField对象进行事件监听和处理的是______。",
"optionA":"ActionListener ",
"optionB":"FocusListener",
"optionC":"MouseMotionListener ",
"optionD":"ChangeListener ",
"answer":"D",
"explain":"    本题考的是AWT与Swing比较。\n    单行文本输入区（TextField）是AWT构件库中的基本构件之一，ActionListener、FocusListener、MouseMotionListener都属于AWT事件监听器，而ChangeListener属于Swing事件监听器。\n    ChangeListener事件监听器可以处理的事件源有AbstractButton、DefaultCaret、JProgessBar、JSlider、JTabbedPane、JViewport。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":316,
"title":"Panel类的默认布局管理器是______。",
"optionA":"BorderLayout",
"optionB":"CardLayout",
"optionC":"FlowLayout",
"optionD":"GridBagLayout",
"answer":"C",
"explain":"    本题考的是布局管理器。\n    FlowLayout是Panel和Applet的默认布局管理器。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":317,
"title":"要在HTML文件中嵌入Applet，在<applet>标记中必须定义的是______。",
"optionA":"Applet字节码文件的URL",
"optionB":"Applet显示区域的高度和宽度",
"optionC":"Applet字节码的文件名",
"optionD":"B和C",
"answer":"D",
"explain":"    本题考查Applet的使用。\n    将Applet嵌入在htm1文件中，必须使用特殊的htm1标记＜Applet＞，实现Applet的运行。该标记中必须定义CODE、WIDTH和HEIGHT三个属性。CODE属性指定包含Applet字节码的文件名；WIDTH和HEIGHT属性定义了Applet显示区以像素为单位ide高度和宽度。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":318,
"title":"下列关于Applet中加载图像的说法，错误的是______。",
"optionA":"可以使用Applet类的getImage()方法获得图像对象 ",
"optionB":"程序员必须自行定义获得图像以及显示图像的类和方法",
"optionC":"图像由一个java.Image类的对象来表示",
"optionD":"可以使用Graphics类的drawImage()方法显示图像 ",
"answer":"B",
"explain":"    本题考查的是Applet的多媒体支持。\n    在Applet中有丰富的多媒体支持功能，主要包括显示图像、动画和声音。\n    在程序中图像由一个java.Image类的对象来表示。在Applet中加载图像使用Applet类提供的getImage()方法，获得包含该图像的一个Image类的对象。显示图像使用的是Graphics类的drawImage()方法，Graphics类定义了4种drawImage()方法，它们都返回一个布尔值，如果图像完全加载并且显示出来返回true，否则返回false。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":319,
"title":"阅读下列代码\npublic class Arrays{\n  public static void main(String[] args){\n    int[] a=new int[5];\n    for(int i=0;i<a.length;i=i+1){\n      a[i]=10+i;\n    }\n    for(int i=0;i<a.length;i=i+1){\n      System.out.println(a[i]);\n    }\n    String[] s={\"Frank\",\"Bob\",\"Jim\"};\n    for(int i=0;i<s.length;i=i+1){\n      System.out.println(s[i]);\n    }\n    s[2]=\"Mike\";\n    System.out.println(s[2]);\n    }\n}\n代码运行结果正确的是______。",
"optionA":"10\n11\n12\n13\n14\nMike\nBob\nFrank\nJim ",
"optionB":"11\n12\n13\n14\n15\nFrank\nBob\nMike\nJim ",
"optionC":"10\n11\n12\n13\n14\nFrank\nBob\nJim\nMike ",
"optionD":"11\n12\n13\n14\n15\nMike\nJim\nBob\nFrank ",
"answer":"C",
"explain":"    本题考查的是数组。\n    程序首先初始化一个包含5个元素int类型的数组a，并通过第一个for循环为其赋值，然后再通过第二个for循环，将赋值后的a[i]依次输出；再第一、二个for循环运行结束后，程序又初始化了一个String类型包含三个元素的数组s，并通过第三个for循环依次输出，运行结束后，程序通过赋值语句\"s[2]=\"Mike\";\"为数组中的s[2]元素赋值，在这里\"s[2]\"可以看作是一个普通的变量，通过\"System.out.println(s[2]);\"语句，将赋值后的s[2]输出。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":320,
"title":"Java中的线程模型由三部分组成，与线程模型组成无关的是______。",
"optionA":"虚拟的CPU",
"optionB":"程序代码",
"optionC":"操作系统的内核状态",
"optionD":"数据",
"answer":"C",
"explain":"    本题考查的是Java中的线程模型。\n    Java中的线程模型包含3部分：\n    1、一个虚拟的CPU。\n    2、该CPU执行的代码。\n    3、代码所操作的数据。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":321,
"title":"String、StringBuffer都是______类，都不能被继承。",
"optionA":"static",
"optionB":"abstract",
"optionC":"final",
"optionD":"private",
"answer":"C",
"explain":"    本题考查的是字符串操作。\n    在Java中，字符串是作为对象出现的，由java.lang.String和java.lang.StringBuffer定义，分别用来处理长度不变和长度可变字符串，这两类都被定义为final，即参考数据类型。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":322,
"title":"当使用SomeThread t = new SomeThread()创建一个线程时，下列叙述中正确的是______。",
"optionA":"SomeThread类是包含run()方法的任意Java类 ",
"optionB":"SomeThread类一定要实现Runnable接口",
"optionC":"SomeThread类是Thread类的子类 ",
"optionD":"SomeThread类是Thread类的子类并且要实现Runnable接口 ",
"answer":"C",
"explain":"    本题考查的是线程的创建。\n    线程是彼此相互独立的、能独立运行的子任务，并且每个线程都有自己的调用栈。创建线程有两种方法。一种方法是将类声明为Thread的子类，使用继承创建线程，通过new命令创建一个线程对象后，该线程对象就处于创建状态。创建一个新的线程对象语句为SomeThread t=new SomeThread()。创建线程的另一种方法是声明实现Runnable接口的类。线程的所有活动都是通过线程体来实现的，类Thread是在java.lang包中定义的，创建一个新的线程对象语句为SomeThread t=new SomeThread(ThreadGroup group,Runnable target,String name)。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":323,
"title":"下列能够正确创建线程的方法是______。\nⅠ.继承java.lang.Thread类，并重写run()方法\nⅡ.继承java.lang.Runnable类，并重写start()方法\nⅢ.实现java.lang.Thread接口，并实现run()方法\nⅣ.实现java.lang.Runnable接口，并实现run()方法",
"optionA":"Ⅰ,Ⅲ ",
"optionB":"Ⅱ,Ⅳ ",
"optionC":"Ⅱ,Ⅲ ",
"optionD":"Ⅰ,Ⅳ ",
"answer":"D",
"explain":"    本题考查的是线程的创建与启动。\n    线程的创建有两种方法：实现Runnable接口和继承Thread类。\n    （1）通过实现Runnable接口创建线程：当实现Runnable接口的类的对象用来创建线程后，该线程的启动将使得对象的run()方法被调用。通过这种方式创建线程的过程是：Runnable的一个实例作为参数传递给Thread类的一个构造方法，该实例对象提供线程体run()。\n    （2）通过继承Thread类创建线程：Thread类本身实现了Runnable接口，所以在java.lang的Thread类的定义中可以发现run()方法。因此，可以通过继承Thread类，并重写其中的run()方法定义线程体，然后创建该子类的对象，从而创建线程。",
"type":"表达式语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":324,
"title":"调用线程的下列方法，不会改变该线程的生命周期中状态的方法是______。",
"optionA":"yield()",
"optionB":"wait()",
"optionC":"sleep()",
"optionD":"isAlive()",
"answer":"D",
"explain":"    本题考查的是线程状态与生命周期。\n    线程的生命周期主要分为如下几个状态：新建状态、可运行状态、运行状态、阻塞状态、终止状态。\n    假设当前线程处于运行状态，则会改变线程当前状态的操作总结如下：\n    （1）当前线程执行了yield()，或当前线程因调度策略（执行过程中，有一个更高优先级的线程进入可运行状态，这个线程立即被调度执行，当前线程占有的CPU被抢占；或在分时方式时，当前执行线程执行完当前时间片）从而导致当前线程进入可运行状态。\n    （2）线程调用了sleep()方法、join()方法、wait()方法时，线程进入阻塞状态。\n    其中yield()方法的作用是暂停当前线程的执行，从而允许与它具有相同优先级的线程执行，如果不存在可执行且与它同优先级的线程，则继续执行当前线程。\n    当某线程需要在synchronized块中等待共享数据状态改变时，调用wait()方法，这样该线程等待并暂时释放共享数据对象的锁，其它线程可以获得该对象的锁，并进入synchronized块对共享数据进行操作，而此线程则放入wait pool中，转入阻塞状态，当其它线程对共享数据操作完后，只要调用notify()方法就可以通知正在等待的线程重新占有锁，并运行。\n    sleep方法的作用是让当前线程处于休眠状态，并持续一定的时间，该时间的长短由sleep()方法的参数决定。sleep()方法结束后，线程将进入可运行状态。\n    所以对选项A、B、C的调用都会改变线程生命周期中的状态，而isAlive()方法的作用是测试线程，以确定线程是否活着。此方法并不会改变线程生命周期中的状态。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":325,
"title":"当检索一个压缩文件时，首先要建立压缩文件输入流对象。该对象______。",
"optionA":"以选中的压缩文件为参数",
"optionB":"以FileInputStream对象为参数 ",
"optionC":"以InputStreamReader对象为参数",
"optionD":"以BufferedReader对象为参数",
"answer":"B",
"explain":"    本题考查的是压缩文件。\n    在java.io包中提供了对压缩文件进行操作的能力。它是通过压缩文件输入流与压缩文件输出流来实现的，其分别继承自InflaterInputStream与DeflaterOutputStream。在创建压缩文件输入流时，其初始化参数是一个FileInputStream类的实例。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":326,
"title":"为读取的内容进行处理后再输出，需要使用下列______流。",
"optionA":"File stream",
"optionB":"Pipe stream",
"optionC":"Random stream",
"optionD":"Filter stream",
"answer":"D",
"explain":"    本题考查的是流的概念。\n    过滤流为I\/O访问提供了同步处理机制。保证在某时刻只能有一个线程访问一个I\/O流。要保证读取的内容进行处理后能够正确的输出，要使用过滤流（Filter stream），否则不能保证输出数据的正确性。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":327,
"title":"给出下面的代码\nif (x>0) { System.out.println(\"first\"); }\n　　else if (x>-3) { System.out.println(\"second\"); }\n　　else { System.out.println(\"third\"); }\nx的取值在______范围内时将打印字符串\"second\"。 ",
"optionA":"x>0",
"optionB":"x>-3",
"optionC":"x<=-3",
"optionD":"x<=0 && x>-3 ",
"answer":"D",
"explain":"    本题考查的是条件语句。\n    x>0时打印\"first\"，x>-3&&x<=0时打印\"second\"，x<=-3时打印\"third\"。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":328,
"title":"Java目前支持图象文件格式是______。",
"optionA":".gif和.jpeg",
"optionB":".bmp和.jpg",
"optionC":".gif和.bmp",
"optionD":".tiff和.jpg",
"answer":"A",
"explain":"    本题考查的是Applet的多媒体支持。\n    在java.applet、java.awt、java.awt.image包中，包含了许多图象支持的类和方法。在程序中图像由一个java.Image类的对象来表示。目前Java所支持的图像格式有：GIF、JPEG、和PNG3种。其中PNG格式是JDK1.3以上版本支持的一种光栅图像格式，它的显示方法与其他两格式相同。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":329,
"title":"下列关于线程优先级的说法中，正确的是______。",
"optionA":"线程的优先级是不能改变的",
"optionB":"线程的优先级是在创建线程时设置的",
"optionC":"在创建线程后的任何时候都可以设置",
"optionD":"B和C",
"answer":"C",
"explain":"    本题考查的是Java语言中线程的优先级。\n    Java语言中线程的优先级是用一个介于MIN_PRIORITY 和MAX_PRIORITY之间的整数来表示的。可以在创建线程后的任何时候修改线程的优先级。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":330,
"title":"下列关于Applet的叙述中，正确的是______。",
"optionA":"Applet是Java类，所以可以由JDK中的解释器java直接解释运行",
"optionB":"Applet的主类不一定要定义为java.aplet.Applet类或JApplet类的子类",
"optionC":"Applet与Application的主要区别在执行方式上",
"optionD":"Applet不能在浏览器中运行",
"answer":"C",
"explain":"    本题考查的是Applet的概念。\n    Java Applet是能够嵌入到HTML页面中，并能够在浏览器中运行的Java类。Applet与Application的主要区别在于执行方式上：Application以main()方法为入口点运行，而Applet要在浏览器或appletviewer中运行，运行过程要比Application复杂。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":331,
"title":"若特快订单是一种订单，则特快订单类和订单类的关系是______。",
"optionA":"使用关系",
"optionB":"包含关系",
"optionC":"继承关系",
"optionD":"无关系",
"answer":"C",
"explain":"    本题考察的是继承的概念。\n    继承是面向对象程序设计的一个重要特征。它是通过继承原有类的基础，派生出新类。新开发的对象既有新定义的行为特征，又包含原有类定义的行为特征。\n    特快订单是一种订单，它既有订单类的属性，又具有自己特快的属性，因此，两者之间是继承关系。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":332,
"title":"Swing的选项面板是______。",
"optionA":"JTabbedPane",
"optionB":"JLayeredPane",
"optionC":"JScrollPane",
"optionD":"JSplitPane",
"answer":"A",
"explain":"    本题考的是Swing简介。\n    JTabbedPane提供一组可供用户选择的带有标签或图标的选项，每个选项下面都可以显示一个构件；\nJLayeredPane是分层面板；\nJScrollPane是带滚动条的面板；\nJSplitPane是分隔板，用于分隔两个构件。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":333,
"title":"下列叙述中，错误的是______。",
"optionA":"JButton类和标签类可显示图标和文本",
"optionB":"Button类和标签类可显示图标和文本",
"optionC":"AWT构件能直接添加到顶层容器中 ",
"optionD":"Swing构件不能直接添加到顶层容器中",
"answer":"B",
"explain":"    本题考的是构件和容器。\n    按钮是一个常用构件，Swing的按钮（JButton）和标签可显示图标和文本，而AWT的按钮（Button）和标签只能显示文本。在构件方面，与AWT构件不同，Swing构件不能直接添加到顶层容器中，它必须添加到一个与Swing顶层容器相关联的内容面板上。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":334,
"title":"如果要在Applet中显示特定的文字、图形等信息，可以在用户定义的Applet类中重写的方法是______。",
"optionA":"paint() ",
"optionB":"update() ",
"optionC":"drawString() ",
"optionD":"drawLine()",
"answer":"A",
"explain":"    本题考查的是Applet的关键方法。\n    paint()方法：Applet的paint()方法具体执行Applet的绘制，该方法定义如下：\n    public void paint(Graphics g)\n    paint()方法有一个参数g是Graphics类的实例，该实例对象由浏览器生成，它包含了Applet的图形上下文信息，通过它向Applet中显示信息，该对象相当于Applet的画笔。在调用paint()方法时，由浏览器将该对象传递给paint()方法。\n    update()方法格式：public void update(Graphics g)\n用于更新Applet的显示。该方法将首先清除背景，再调用paint()方法完成Applet的具体绘制。用户定义的Applet一般不用重写该方法。\n    drawString()方法格式：public abstract void drawString(String str，int x，int y)，此方法是Graphics类显示文本方法的一种。\n    drawLine画线：此方法是Graphics类绘制图形方法的一种。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":335,
"title":"下列带下划线的标识符符合Java命名约定的是______。",
"optionA":"package com.Bi.hr ",
"optionB":"public class xyz",
"optionC":"int I",
"optionD":"void setCustomerName()",
"answer":"D",
"explain":"    本题考查的是Java命名约定。\n    包的名字应该都是由小写单词组成。它们全都是小写字母，即便中间的单词亦是如此，所以A选项错误。\n    类名的第一个字母一定要大写，所以B选项错误；\n    变量的第一个字母应该为小写，所以C选项错误；\n    与属性相对应的get、set方法为：set(get)+属性名，属性名第一个字母为大写，所以D选项正确。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":336,
"title":"下列方法能够用来实现线程之间通信的是______。",
"optionA":"notify()",
"optionB":"run()",
"optionC":"sleep()",
"optionD":"join()",
"answer":"A",
"explain":"    本题考查的是线程间的交互。\n    Java引入的wait()和notify()，是Java.lang.object类的方法，是实现线程通信的两个方法。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":337,
"title":"当Applet需要更新显示内容时，应该调用的方法是______。",
"optionA":"paint()",
"optionB":"update()",
"optionC":"start()",
"optionD":"repaint()",
"answer":"D",
"explain":"    本题考查的是Applet的显示。\n    repaint()方法主要用于Applet的重新显示，它调用update()方法实现对Applet的更新。Applet程序可以在需要显示更新时调用该方法，通知系统刷新显示。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":338,
"title":"下列程序的功能是统计字符串中\"array\"的个数，在程序的空白处应填入的正确选项是______。\npublic class FindKeyWords{\n   public static void main (String[] args) {\n     String text = \"An array is a data structure that stores a collection of \"+\"values of the same type.You access each individual value\"+\"through an integer index.For example,if a is an array\"+\"of integers,then a[i] is the ith integer in the array.\";\n     int arrayCount = 0;\n     int index = -1;\n     String arrayStr = \"array\";\n     index = text.indexOf(arrayStr);\n     while(index ______ 0){\n       ++arrayCount;\n       index+=arrayStr.length();\n       index=text.indexOf(arrayStr,index);\n }\n System.out.println(\"The text contains \"+arrayCount+\" arrays\");\n   }\n}",
"optionA":"<",
"optionB":"=",
"optionC":"<=",
"optionD":">=",
"answer":"D",
"explain":"    本题考查的是字符串操作。\n    语句\"String text = \"An array is a data structure that stores a collection of \"+\"values of the same type.You access each individual value\"+\"through an integer index.For example,if a is an array\"+\"of integers,then a[i] is the ith integer in the array.\";\"的作用是将四段字符串连接成一个完整的字符串，也就是说程序需要统计的字符串为\"An array is a data structure that stores a collection of values of the same type.You access each individual valuethrough an integer index.For example,if a is an arrayof integers,then a[i] is the ith integer in the array.\"。定义int类型变量arrayCount，并为其赋初值0，该变量用于存放统计结果，即字符串中\"array\"的个数。int类型的变量index是控制程序中while循环的条件，它的初始值为-1。indexOf()方法的作用是在字符串中查询指定字符或子串，如果查询成功，返回所查字符或子串的位置，这里语句\"index = text.indexOf(arrayStr);\"的意思，就是在字符串text中查询String类型变量arrayStr表示的字符串\"array\"，并将该子串的地址赋给变量index。由于变量index的初始值为-1，所以当它的值大于或等于0时，则代表在字符串text中找到了子串\"array\"的位置，所以while循环的条件应该为：index >= 0。当while循环条件满足时，首先为变量arrayCount的值加1，后面语句\"index+=arrayStr.length();\"则是在找到的地址上加上\"array\"字符串的长度，这样执行语句\"index=text.indexOf(arrayStr,index);\"时，变量index就可以接着往下查找，而不是停留在第一个发现的\"array\"字符串的位置了。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":339,
"title":"在程序的下划线处应填入的选项是______。\npublic class Test ______ {\n  public static void main(String args[]){\n    Test t = new Test();\n    Thread tt = new Thread(t);\n    tt.start();\n  }\n\n  public void run(){\n    for(int i=0;i<5;i++){\n      System.out.println(\"i=\"+i);\n    }\n  }\n}",
"optionA":"implements Runnable ",
"optionB":"extends Thread ",
"optionC":"implements Thread ",
"optionD":"extends Runnable ",
"answer":"A",
"explain":"    本题考查的是线程的创建与启动。\n    创建线程有两种方法。一种方法是将类声明为Thread的子类；另一种方法是声明实现Runnable接口的类。\n①继承Thread：\nclass PrimeThread extends Thread {\n         long minPrime;\n         PrimeThread(long minPrime) {\n             this.minPrime = minPrime;\n         }\n         \n         public void run() {\n             \/\/ compute primes larger than minPrime\n             ……        \n }\n     }\n然后，下列代码会创建并启动一个线程： \n     PrimeThread p = new PrimeThread();\n     p.start();\n\n② 实现Runnable接口\nclass PrimeRun implements Runnable {\n         long minPrime;\n         PrimeRun(long minPrime) {\n             this.minPrime = minPrime;\n         }\n \n         public void run() {\n             \/\/ compute primes larger than minPrime\n              ……\n         }\n     }\n    然后，下列代码会创建并启动一个线程： \n     PrimeRun p = new PrimeRun();\n     new Thread(p).start();",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":340,
"title":"下列线程状态转换序列，在线程实际运行中可能出现的序列是______。",
"optionA":"新建→运行→阻塞→终止 ",
"optionB":"……运行→阻塞→可运行→终止 ",
"optionC":"……可运行→运行→阻塞→运行…… ",
"optionD":"新建→可运行→运行→阻塞→可运行……",
"answer":"D",
"explain":"    本题考查的是线程状态与生命周期。\n    线程的生命周期主要分为如下几个状态：新建、可运行、运行、阻塞、终止。\n    阻塞状态需要依次经过可运行状态和运行状态，才能到达终止状态，所以选项A）、B）和C）错误。",
"type":"条件语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":341,
"title":"在下面附属类方法中的下划线处，应填入的正确参数是______。\npublic void writeData(      ) throws IOException\n{\n     GregoranCalendar calendar=new GregorianCalendar()\n     calendar.setTime(hireDay);\n     out.println(name+\"|\"\n     +salary+\"|\"\n     +calendar.get(Calendar.YEAR)+\"|\"\n     +(calendar.get(Calendar.MONTH)+1)+\"|\")\n}",
"optionA":"Employee[] e ",
"optionB":"\"employee.dat\" ",
"optionC":"PrintWriter out ",
"optionD":"BufferedWriter ",
"answer":"c",
"explain":"    本题考查的是方法参数列表的格式。\n    参数列表的各项间用逗号隔开，每项中包含类型及变量两部分，因此选项B,D是错误的，由于在方法的主体中出现了out实例，但没有它的定义存在，所以其定义应该在参数列表中。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":342,
"title":"如果希望所有的控件在界面上呈网格状布局，应使用下列______布局管理器。",
"optionA":"CardLayout",
"optionB":"GridLayout",
"optionC":"BorderLayout",
"optionD":"FlowLayout",
"answer":"B",
"explain":"    本题考查的是布局管理器。\n    1、CardLayout布局管理器能够帮助用户处理两个以至更多的成员共享同一显示空间，它把容器分成许多层，每层的显示空间占据整个容器的大小，但是每层只允许放置一个构件，当然每层都可以利用Panel来实现复杂的用户界面。\n    2、GridLayout布局管理器使容器中各个构件呈网格状布局，平均占据容器的空间。即使容器的大小发生变化，每个构件还是平均占据容器的空间。构件在往容器中放置的时候，是按照从上到下、从左到右的规律进行的。\n    3、BorderLayout布局管理器把容器分成5个区域：North,South,East,West和Center，每个区域只能放置一个构件。\n    4、FlowLayout：构件在容器中的放置规律是从上到下、从左到右进行放置，如果容器足够宽，第一个构件先添加到容器中第一行的最左边，后续的构件依次添加到上一个构件的右边，如果当前行已放置不下该构件，则放置到下一行的最左边。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":343,
"title":"对JFrame添加构件有______种方式。",
"optionA":"一种",
"optionB":"两种",
"optionC":"三种",
"optionD":"四种",
"answer":"B",
"explain":"    本题考查的是JFrame框架。\n    对JFrame添加构件有两种方式：\n    1、用getContentPane()方法获得JFrame的内容面板，再对其加入构件frame.getContentPane().add(childComponent)。\n    2、建立一个Jpanel或JDesktopPane之类的中间容器，把构件添加到容器中，再用setContentPane()方法把该容器置为JFrame的内容面板：\n    Jpanel contentPane=new Jpanel()；\n    …\/\/把其他构件添加到Jpanel中\n    frame.setContentPane(contentPane)；\/\/把contentPane对象设置成为frame的内容面板。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":344,
"title":"给出以下关于一个使用适当的字符间距的字体的TextField的表达式TextField t = new TextField(\"they are good\",40);以下说法中______是正确的。",
"optionA":"被显示的字符串可以使用多种字体",
"optionB":"一行中最大的字符数是40",
"optionC":"显示的宽度正好是40个字符宽",
"optionD":"用户可以编辑字符",
"answer":"D",
"explain":"    本题考查的是TextField的使用方法。\n    对于TextField的该种形式的构造函数来说，前一个参数是文本域中初始的字符串的显示值，而后一个是推荐的显示宽度，以列数表示，在构造文本域的时候会将这个大小设置为最佳大小，如果容器的限制使得文本域不能显示这么多也没有办法，一般来说是比这个大小大的，而且即使宽度很小，你也可以在文本域的一行中输入很长的字符串，只要不使用回车，在超过显示宽度后文本域会自动出现水平滚动条（没有被设置为关闭，缺省是不关闭的），而文本域的缺省编辑方式是可编辑的，一个文本域只能使用一种字体，这个字体可以在运行的过程中动态的改变，但是文本域中的所有字符串都将使用这个字体显示。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":345,
"title":"要编写一个独立运行的Java Application必须包含______方法。",
"optionA":"run",
"optionB":"main",
"optionC":"start",
"optionD":"init",
"answer":"B",
"explain":"本题考查的是Java的应用。\n每个Java Application程序可以包括许多方法，但必须有且只能有一个main方法，格式统一为public static void main(String args[])，它是程序的入口，如果没有设计main方法，在程序运行的时候会提示没有找到main方法的错误信息。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":346,
"title":"按照Java的标识符命名规范，下列表示一个类的标识符正确的是______。",
"optionA":"Helloworld ",
"optionB":"HelloWorld ",
"optionC":"helloworld ",
"optionD":"helloWorld ",
"answer":"B",
"explain":"    本题考查的是Java的命名约定。\n    Java的命名约定的基本原则如下：\n（1）_、$不作为变量名、方法名开头。\n（2）变量名、方法名首单词小写，其余单词只有首字母大写。如myVariable，myMethod。\n（3）接口名、类名的单词首字母大写。如MyInterface，MyClass。\n（4）常量名的每个字母都大写。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":347,
"title":"下列代码中，将引起编译错误的行是______。\n1）public class Exercise{\n2）   public static void main(String args[]){\n3）       float f=0.0;\n4）       f+=1.0;\n5）      }\n6）  }",
"optionA":"第2行 ",
"optionB":"第3行 ",
"optionC":"第4行",
"optionD":"第6行",
"answer":"B",
"explain":"    本题考查的是Java程序结构。\n    float定义变量赋值时，需要在数值后面加f以标识它为浮点型，让系统知道该给它精确到多少位。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":348,
"title":"若数组a定义为int[][] a=new int[3][4]，则a是______。",
"optionA":"一维数组",
"optionB":"二维数组",
"optionC":"三维数组",
"optionD":"四维数组",
"answer":"B",
"explain":"    本题考察的是二维数组的定义。\n    由于Java将二维数组当作一维数组来处理，所以在进行初始化的时候，可以各行单独进行，也允许各行的元素个数不同。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":349,
"title":"每个Java小应用程序必须定义为______。",
"optionA":"Applet类或JApplet类的子类 ",
"optionB":"JFrame类的子类",
"optionC":"Frame的子类",
"optionD":"Window的子类 ",
"answer":"A",
"explain":"    本题考的是小应用程序概念。\n    Applet（小应用程序）是Java与Web相结合而引入的一种重要的Java应用形式。JApplet是一个使Applet能够使用Swing构件的类。JApplet类是java.applet.Applet类的子类，包含Swing构件的Applet必须是JApplet类的子类。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":350,
"title":"下列叙述中，错误的是______。",
"optionA":"Applet的默认布局管理器是FlowLayout",
"optionB":"JApplet中增加构件是加到JApplet的内容面板上，不是直接加到JApplet中",
"optionC":"JApplet的内容面板的默认布局管理器是BorderLayout",
"optionD":"JApplet的内容面板的默认布局管理器是FlowLayout",
"answer":"D",
"explain":"    本题考的是布局管理器。\n    向JApplet中增加构件，是把构件添加到Swing Applet的内容面板中；对JApplet设置布局管理器，是对Swing Applet的内容面板进行设置，Swing Applet的内容面板的默认布局管理器是BorderLayout，所以，JApplet的内容面板的默认布局管理器是BorderLayout；而Applet的默认布局管理器是FlowLayout。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":351,
"title":"如果用户定义的Applet类中没有init()方法，则该程序______。",
"optionA":"必须定义一个main()方法",
"optionB":"无法通过编译",
"optionC":"可以通过编译，但运行时将出错",
"optionD":"可以通过编译，并且能够正常运行",
"answer":"D",
"explain":"    本题考查的是Applet中的init()方法。\n    Applet的关键方法init()，Applet运行时，首先由浏览器调用init()方法，通知该Applet已被加载到浏览器中，使Applet执行一些基本初始化。该方法经常被重写，实现设置布局管理器、数据初始化、放置一些构件等功能。但是，每个Applet必须至少实现init()、start()和paint()中的一个方法。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":352,
"title":"RandomAccessFile是java.io包中的一个兼有输入输出功能的类。由于它是随机访问，所以文件读写一个记录的位置是______。",
"optionA":"起始 ",
"optionB":"终止",
"optionC":"任意 ",
"optionD":"固定 ",
"answer":"C",
"explain":"    本题考查的是随机文件流。\n    文件操作中经常需要的是随机访问，Java中的RandomAccessFile类提供了随机访问文件的功能，它继承了Object类，用DataInput和DataOutput接口来实现。接口中定义了从流中读\/写基本类型的数据方法。因此也可以随机读入字节数据文件的记录。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":353,
"title":"下列关于线程的说法中，正确的是______。",
"optionA":"一个线程一旦被创建，就立即开始运行 ",
"optionB":"使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行",
"optionC":"当运行状态的线程因为调用了yield()方法而停止运行，它一定被放在可运行线程队列的前面",
"optionD":"当因等待对象锁而被阻塞的线程获得锁后，将直接进入运行状态",
"answer":"B",
"explain":"    本题考查的是线程间的交互。\n    一个线程创建以后并不马上启动，此时线程处于新建状态。所以选项A错误。yield()方法的功能是线程暂停，让出CPU，使同优先级的其他线程运行，如果不存在有机会运行的线程，yield()方法将直接返回，线程继续；所以线程调用了yield()方法还有可能继续为运行状态，所以选项C错误。当因等待对象锁而被阻塞的线程获得锁后，将进入可运行状态，而不是运行状态，所以选项D错误。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":354,
"title":"向Applet传递参数的正确描述是______。",
"optionA":"<param name=age,value=20>",
"optionB":"<applet code=Try.class width=100,height=100,age=33>",
"optionC":"<name=age,value=20>",
"optionD":"<applet code=Try.class name=age,value=20>",
"answer":"A",
"explain":"    本题考查的是Applet参数。\n    Applet获取参数是通过在HTML文件中采用<PARAM>标记定义参数。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":355,
"title":"构造方法名必须与______相同，它没有返回值，用户不能直接调用它，只能通过new调用。",
"optionA":"类名",
"optionB":"对象名",
"optionC":"包名",
"optionD":"变量名",
"answer":"A",
"explain":"    本题考查的是构造方法。\n    构造方法是一个类方法中方法名与类名相同的类方法，当使用new关键字创建一个对象时，Java系统将自动调用构造方法去初始化这个新建对象，构造方法是一种特殊的方法。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":356,
"title":"为了支持压栈线程与弹栈线程之间的交互与同步，在程序的下划线处依次填入的语句是______。\npublic class IntStack{\n   private int idx = 0;\n   private int[] data = new int[8];\n   public ______ void push(int i){\n       data[idx]=i;\n       idx++;\n       ______\n   }\n   ……\n}",
"optionA":"synchronized()\nnotify() ",
"optionB":"synchronized\nthis.wait() ",
"optionC":"synchronized\nthis.notify()",
"optionD":"Serializable\nsleep() ",
"answer":"C",
"explain":"    本题考查的是线程并发控制。\n    synchronized关键字可用来检测和获得对象锁，并设定临界区。为了防止对共享数据的访问发生错误，应该将访问共享数据的代码使用synchronized关键字设置成临界区。这样加锁进行保护。线程间的交互，wait()和notify()，线程调用x.wait()，则该线程将被放入对象x的wait pool，并且将释放x的对象锁。线程调用x.notify()，则对象x的wait pool中的一个线程将移入lock pool，等待x的对象锁，一旦获得便可以运行。\n本题部分程序代码如下：\npublic class IntStack{\n……\npublic synchronized void push(int i){ \/\/加上互斥锁\n……\nthis.notify();\/\/通知其它线程把数据出栈\n}\n}",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":357,
"title":"为了支持压栈线程与弹栈线程之间的交互与同步，应在下划线处填入的选项是______。\npublic class StackTest{\n    private int idx=0;\n    private int[] data=new int[8];\n    public void push(int i){\n        synchronized(this){\n            ______;\n            data[idx]=i;\n            idx++;\n        }\n    }\n    ……\n}",
"optionA":"this.notify() ",
"optionB":"interrupt() ",
"optionC":"this.wait() ",
"optionD":"sleep() ",
"answer":"A",
"explain":"    本题考查的是线程并发控制。\n    synchronized关键字可用来检测和获得对象锁，并设定临界区。为了防止对共享数据的访问发生错误，应该将访问共享数据的代码使用synchronized关键字设置成临界区。这样加锁进行保护。线程间的交互，wait()和notify()，线程调用x.wait()，则该线程将被放入对象x的wait pool，并且将释放x的对象锁。线程调用x.notify()，则对象x的wait pool中的一个线程将移入lock pool，等待x的对象锁，一旦获得便可以运行。",
"type":"循环语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":358,
"title":"下面程序段：\n boolean a=false;\n boolean b=true;\n boolean c=(a&&b)&&(!b);\n boolean result =(a&b)&(!b);\n执行完后，正确的结果是______。",
"optionA":"c=false;result=false",
"optionB":"c=true;result=true",
"optionC":"c=true;result=false",
"optionD":"c=false;result=true",
"answer":"A",
"explain":"    本题考查的是逻辑运算符。\n    由于逻辑运算符\"&&\"采用的是\"短路\"方式进行计算的，即若左边表达式为false，则不会再对运算符右边的表达式求值，整个逻辑表达式的结果确定为false。所以对于a&&b，由于a的值为false，所以不需要考虑b的值，直接返回a&&b这个表达式的值为false；而对于整个表达式，又是一个关于&&的运算，所以对整个表达式的值的运算继续采用\"短路\"的方法，返回false，故布尔型变量c的值为false。\n    对于result的结果，由于两个\"&\"运算符的两侧均为布尔值，故在这里\"&\"是布尔逻辑运算符，其与普通的逻辑运算符&&相比较，除了&&会发生短路外，其余功能都是相同的。在执行a&b操作时，false & true=false，!b=false，false & false=false，故reslut=false。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":359,
"title":"一个Java Application运行后，在系统中是作为一个______。",
"optionA":"线程",
"optionB":"进程",
"optionC":"进程或线程",
"optionD":"不可预知",
"answer":"B",
"explain":"    本题考查的是Java Application。\n    一个Java Application运行后在系统中作为一个独立的进程参与系统调度，但在该进程中可以通过创建Thread类的实例的方法来创建多个线程。在一个进程中的各个线程之间拥有共同的上下文环境。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":360,
"title":"对象状态持久化是通过______。",
"optionA":"文件",
"optionB":"管道",
"optionC":"串行化",
"optionD":"过滤器",
"answer":"C",
"explain":"    本题考查的是对象的永久化概念。\n    将Java程序中的对象保存在外存中，称为对象永久化。对象永久化的关键是将它的状态以一种串行格式表示出来，以便以后读该对象时能够把它重构出来。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":361,
"title":"下面关于继承的描述正确的是______。",
"optionA":"在Java中只允许单一继承 ",
"optionB":"在Java中一个类只能实现一个接口",
"optionC":"在Java中一个类不能同时继承一个类和实现一个接口 ",
"optionD":"Java的单一继承使代码不可靠 ",
"answer":"A",
"explain":"    本题考查的是继承的含义。\n    在Java中一个类只能有一个直接父类，但是可以实现多个接口，在继承的同时可以实现接口，之所以取消多继承的原因是多继承使得代码产生很多问题，而使用单一继承则可以使代码更可靠。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":362,
"title":"假设有String a=\"A\";char b='A';int c=65，下面选项中______是正确的。",
"optionA":"if(a==b) \n{\nSystem.out.print(\"Equal\")\n}",
"optionB":"if(c==b) \n{\nSystem.out.print(\"Equal\")\n} ",
"optionC":"if(a==c) \n{\nSystem.out.print(\"Equal\")\n} ",
"optionD":"if(c=b) \n{\nSystem.out.print(\"Equal\")\n} ",
"answer":"B",
"explain":"    本题考查的是条件语句和变量类型。\n    由于Java是强类型语言，String不能和char，int类型变量直接进行对比。但如果char和int两类型在同一个表达式中运算，系统是可以进行自动类型转换的，因此这两个类型的变量可以比较。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":363,
"title":"下列代码中，将引起一个编译错误的行是______。\n1)public class Test{\n2) int m,n;\n3) public Test(){}\n4) public Test(int a){m=a;}\n5) public static void main(String args[]){\n6)  Test t1,t2;\n7)  int j,k;\n8)  j=0;k=0;\n9)  t1=new Test();\n10)  t2=new Test(j,k);\n11) }\n12) }",
"optionA":"第3行 ",
"optionB":"第5行 ",
"optionC":"第6行 ",
"optionD":"第10行",
"answer":"D",
"explain":"    本题考查的是类的构造方法的调用。\n    第10行代码中的参数数目比类Test的任何一个构造方法声明的形参都多，因此引起编译错误。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":364,
"title":"为了向一个Applet传递参数，可以在HTML文件的APPLET标志中使用PARAM选项。在Applet程序中获取参数时，应使用的方法是______。",
"optionA":"getParameter() ",
"optionB":"getDocumentBase()",
"optionC":"getCodeBase()",
"optionD":"getImage()",
"answer":"A",
"explain":"    本题考查的是Applet参数。\n    HTML标记方法用于获取HTML文件中关于Applet的信息，具体方法有：\n    URL getDocumentBase()：返回包含Applet的HTML文件的URL；\n    URL getCodeBase()：返回Applet主类的URL，它可以不同于包含Applet的HTML文件的URL；\n    String getparameter(string name)：返回定义在HTML文件的<\/PARAM>标记中指定参数的值。\n    所以，Applet取得参数是通过java.applet.Applet.getParameter方法。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":365,
"title":"Java语言使用的字符码集是______。",
"optionA":"ASCll ",
"optionB":"BCD",
"optionC":"DCB",
"optionD":"Unicode",
"answer":"D",
"explain":"    本题考察的是Java基础。\n    Java采用Unicode字符码集。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":366,
"title":"在Applet的init()方法被调用后，接下来最先被调用的方法是______。",
"optionA":"run()",
"optionB":"start()",
"optionC":"stop()",
"optionD":"destroy()",
"answer":"B",
"explain":"    本题考的是Applet执行过程。\n    在init()方法完成后，将调用start()方法，使Applet成为激活状态。Applet的生命周期中各方法的调用次序为：init()、start()、stop()、destroy()（其中start()和stop()可重复执行）。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":367,
"title":"在定制Applet的绘图功能时，应该使用的方法是______。",
"optionA":"init()",
"optionB":"start()",
"optionC":"paintComponent()",
"optionD":"paint()",
"answer":"D",
"explain":"    本题考的是Applet的图形绘制。\n    Applet是工作在图形方式下的，向Applet中绘图、显示字符串，都要用paint()方法，paint()方法具体执行Applet的绘制功能。init()方法实现设置布局管理器、数据初始化、放置一些构件等功能，该方法在Applet运行时首先由浏览器调用，使Applet执行一些基本初始化。start()方法使Applet成为激活状态，该方法在Applet每次显示时都要调用。paintComponent()方法位于JComponent类，该方法与paint()方法类似，但通常在Swing中使用其绘图。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":368,
"title":"阅读下面程序\nclass Test implements Runnable{\n    public static void main(String[] args){\n        Test t = new Test();\n        t.start();\n    }\n    public void run(){ }\n}\n下列关于上述程序的叙述正确的是______。",
"optionA":"程序不能通过编译，因为start()方法在Test类中没有定义",
"optionB":"程序编译通过，但运行时出错，提示start()方法没有定义",
"optionC":"程序不能通过编译，因为run()方法没有定义方法体",
"optionD":"程序编译通过，且运行正常",
"answer":"A",
"explain":"    本题考查的是Java程序错误分析。\n    Java中成员方法只在类中定义，用来处理该类数据。本题程序中并没有定义t.strat()方法，所以运行时就会报出start()没定义的错误。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":369,
"title":"阅读下面Applet程序\nimport javax.swing.*;\nimport java.awt.*;\n  public class SwingApplet extends JApplet{\n     JLabel l=new JLabel(\"This is a Swing Applet.\");\n     public void init(){\n      ______\n     }\n}\n在程序下划线处填入正确选项是______。",
"optionA":"Container contentPane=getContentPane(); contentPane.add(l); ",
"optionB":"JPanel contentPane=new JPanel(); contentPane.add(l); ",
"optionC":"contentPane.add(l); ",
"optionD":"add(l);",
"answer":"A",
"explain":"    本题考查的是基于Swing的Applet用户界面。\n    JApplet是顶层的Swing容器，其内部用一个隐含的根面板（JRootPanel）作为惟一的直接后代，而根面板中的内容面板（Content Pane）才是JApplet除菜单条外所有构件的双亲。由于内容面板的存在，通常对JApplet添加构件有两种方式：\n    1、用getContentPane()方法获得JApplet的内容面板，再向内容面板中添加构件：\n    Container contentPane=getContentPane(); contentPane.add(SomeComponent);\n    2、建立一个JPanel之类的中间容器，把构件添加到容器中，再用setContentPane()方法把该容器置为JApplet的内容面板：\n    JPanel contentPane=new JPanel(); contentPane.add(SomeComponent); setContentPane(contentPanel);",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":370,
"title":"下列概念中不包括任何实现，与存储空间没有任何关系的是______。",
"optionA":"类",
"optionB":"接口",
"optionC":"抽象类",
"optionD":"对象",
"answer":"B",
"explain":"    本题考查的是接口。\n    接口是一种只含有抽象方法或常量的一种特殊的抽象类，因为接口不包括任何实现，所以与存储空间没有任何关系。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":371,
"title":"Applet的默认布局管理器是______。",
"optionA":"BorderLayout",
"optionB":"FlowLayout",
"optionC":"GridLayout",
"optionD":"PanelLayout",
"answer":"B",
"explain":"    本题考查的是布局管理器。\n    FlowLayout是Panel和Applet的默认布局管理器。构件在容器中的放置规律是从上到下、从左到右进行放置，如果容器足够宽，第一个构件先添加到容器中第一行的最左边，后续的构件依次添加到上一个构件的右边，如果当前行已放置不下该构件，则放置到下一行的最左边。构件的大小不随容器的大小改变而改变。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":372,
"title":"在多线程并发程序设计中，能够给对象x加锁的语句是______。",
"optionA":"x.wait()",
"optionB":"synchronized(x)",
"optionC":"x.notify()",
"optionD":"x.synchronized()",
"answer":"B",
"explain":"    本题考查的是并发控制。\n    Java中对共享数据操作的并发控制是采用传统的封锁技术。一个程序中单独的、并发的线程对同一个对象进行访问的代码段，称为临界区。在Java语言中，临界区可以是一个语句块或是一个方法，并且用\"synchronized\"关键字标识。Java平台将每个由synchronized(Object)语句指定的对象设置一个锁，称为对象锁。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":373,
"title":"如果线程正处于阻塞状态，不能够使线程直接进入可运行状态的情况是______。",
"optionA":"sleep()方法的时间到",
"optionB":"获得了对象的锁",
"optionC":"线程在调用t.join()方法后，线程t结束",
"optionD":"wait()方法结束",
"answer":"D",
"explain":"    本题考查的是线程的调度。\n    阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。根据产生的原因可分为对象锁阻塞、等待阻塞和其他阻塞。状态相应变迁如下：线程调用了sleep()方法、join()方法时，线程进入其他阻塞状态；由于调用sleep()方法而进入其他阻塞状态的线程，睡眠时间到时将进入可运行状态；由于调用t.join()方法而进入其他阻塞状态的线程，当t线程结束或等待时间到时，进入可运行状态；对象锁阻塞状态下的线程当获得对象锁后，将进入可运行状态。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":374,
"title":"对下列程序的叙述中，正确的是______。\n1:public class X extends Thread implements Runnable{\n2: public void run(){\n3:   System.out.println(\"this is run()\");\n4:  }\n5:  public static void main(String args[]) {\n6:    Thread t=new Thread(new X());\n7:    t.start();\n8:  }\n9: }",
"optionA":"第1行会产生编译错误 ",
"optionB":"第6行会产生编译错误",
"optionC":"第6行会产生运行错误",
"optionD":"程序正常运行",
"answer":"D",
"explain":"    本题考查的是线程的创建与启动。\n    一个类可以继承一个父类，并可实现多个接口。所以，程序第一行不会产生编译错误。\n    创建线程有两种方法。第一种方法是将类声明为Thread的子类；第二种方法是声明实现Runnable接口的类。本题采用的是第二种方法，通过实现Runnable接口创建线程：当实现Runnable接口的类的对象用来创建线程后，该线程的启动将使得对象的run()方法被调用。通过这种方式创建线程的过程是：Runnable的一个实例作为参数传递给Thread类的一个构造方法，该实例对象提供线程体run()。在本题中，类X实现了Runnable接口，并在主函数中创建并启动了一个线程，执行了run()方法。编译执行本程序，输出：this is the run()。",
"type":"注释语句",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":375,
"title":"在匹配器（Matcher）类中，用于输入字符串与模式串比较的方法是______。",
"optionA":"static boolean matches()",
"optionB":"boolean matcher.find()",
"optionC":"int matcher.start()",
"optionD":"int matcher.end()",
"answer":"A",
"explain":"    本题考查的是Matcher类。\n    在J2SE1.4中的正则表达式包中存在一个匹配器类。该类用于将一个输入字符串与模式串进行比较，在这个类中通过matches方法用来对输入字符串与模式串的比较，如果匹配成功则返回true否则返回false；matcher.find()方法用来寻找下一模式匹配串；matcher.start()用来返回匹配串的一个起始索引整数值；matcher.end()用来返回匹配串的终止索引整数值。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":376,
"title":"要串行化某些类的对象，这些类就必须实现______。",
"optionA":"Serializable接口",
"optionB":"java.io.Externalizable接口",
"optionC":"java.io.DataInput接口",
"optionD":"DataOutput接口",
"answer":"A",
"explain":"    本题考查的是对象的串行化。\n    对Java对象的读、写的过程被称为对象串行化。任何一个对象只有它所对应的类实现了Serializable接口时，才是可串行化的。因此如果要串行化某些类的对象，这些类就必须实现Serializable接口。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":377,
"title":"实现一个线程有______种方法。",
"optionA":"一种",
"optionB":"三种",
"optionC":"二种",
"optionD":"四种",
"answer":"C",
"explain":"    本题考查的是线程的实现。\n    在Java中可通过两种方法来产生一个线程。在Java中，可以通过继承类Thread来构造线程，即通过继承Thread类并覆盖其中的run方法来生成一个线程。同时也可以通过建立一个实现了Runnable接口的对象，并以其作为线程的目标对象来建立一个线程，通过这种方法可以打破Java中单一继承类方式的限制，在这种方法中，所有实现了Runnable接口的对象都是以线程方式在运行。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":378,
"title":"下面______不是java的原始数据类型。",
"optionA":"short",
"optionB":"Boolean",
"optionC":"unit",
"optionD":"float",
"answer":"C",
"explain":"    本题考查的是变量的类型。\n    Java的原始数据类型一共就八个，分别是：byte，short，int，long，boolean，char，float，double。注意这些是大小写敏感的，如Boolean是boolean的封装类（wrapper class）。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":379,
"title":"假设a=1，b=2，执行语句++a*b++的结果是______。",
"optionA":"2",
"optionB":"3",
"optionC":"4",
"optionD":"6",
"answer":"C",
"explain":"    本题考查的是表达式的运算。\n    增量运算符\"++\"是将操作数加1。对++x与x++的运算结果均为x=x+1，但若将增量运算表达式再作为其他表达式的操作数使用时，i++与++i是有区别的：i++在使用i之后，使i的值加1，因此执行表达式时是以i的值参加表达式的运算的，执行完后，i本身的值变为i+1；而++i是在使用i之前，使i的值加1，因此执行表达式时是以i+1的值参加运算的，执行完后i自身的值也为i+1。\n    本题先算++a，再乘以b，这是因为前加运算符的优先级高于*，而*号运算的优先级高于后++。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":380,
"title":"下列程序的功能是在监控台上每隔一秒钟显示一个字符串\"Hello!\"，能够填写在程序中下划线位置，使程序完整并能正确运行的语句是______。\npublic class Test implements Runnable{\n  public static void main(String args[]){\n      Test t=new Test();\n      Thread tt=new Thread(t);\n      tt.start();\n  }\n  public void run(){\n      for(;;){\n         try{\n             ____________;\n  }catch(____________ e){}\n      System.out.println(\"Hello!\");\n      }\n  }\n}",
"optionA":"sleep(1000)\nInterruptedException ",
"optionB":"t.sleep(1000)\nInterruptedException ",
"optionC":"Thread.sleep(1000)\nRuntimeException ",
"optionD":"Thread.sleep(1000)\nInterruptedException ",
"answer":"D",
"explain":"    本题考查的是线程的使用。\n    Thread的sleep方法的原型如下：\n    public static void sleep(long millis)throws InterruptedException\nsleep()的功能是使当前执行的线程睡眠（暂时停止）指定时间。sleep()是Thread的static成员，且抛出InterruptedException。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":381,
"title":"线程在生命周期中要经历5种状态，如果线程当前是新建状态，则它可到达的下一个状态是______。",
"optionA":"运行状态 ",
"optionB":"阻塞状态 ",
"optionC":"阻塞状态 ",
"optionD":"阻塞状态 ",
"answer":"C",
"explain":"    本题考查的是线程状态。\n    新线程态(New Thread)：产生一个Thread对象就生成一个新线程，当线程处于\"新线程\"状态时，仅仅是一个空线程对象，它还没有分配到系统资源，因此只能启动或终止它，任何其他操作都会引发异常。 \n　　可运行态(Runnable)：start()方法产生运行线程所必须的资源，调度线程执行，并且调用线程的run()方法，在这时线程处于可运行态，该状态不称为运行态是因为这时的线程并不总是一直占用处理机。特别是对于只有一个处理机的PC而言，任何时刻只能有一个处于可运行态的线程占用处理机。Java通过调度来实现多线程对处理机的共享。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":382,
"title":"在程序读入字符文件时，能够以该文件作为直接参数的类是______。",
"optionA":"FileReader",
"optionB":"BufferedReader",
"optionC":"FileInputStream",
"optionD":"ObjectInputStream",
"answer":"C",
"explain":"    本题考察的是输入输出流。\n    FileInputStream和FileOutputStream是在文件系统上进行操作的输入输出流，所以它是能以文件作为直接参数的类。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":383,
"title":"下列关于Applet的安全限制的叙述中，错误的是______。",
"optionA":"通常情况下，禁止Applet读、写本地文件系统",
"optionB":"通常情况下，禁止Applet向Applet源主机之外的任何主机建立网络连接",
"optionC":"通常情况下，禁止Applet读取系统信息",
"optionD":"通常情况下，禁止Applet加载本地库或方法",
"answer":"C",
"explain":"    本题考的是Applet的安全机制。\n    Applet的安全限制：\n    1）Applet不能运行任何本地可运行程序；\n    2）禁止加载本地库或方法。Applet只能使用自身的代码或Applet浏览器提供的Java API；\n    3）禁止读、写本地计算机的文件系统；\n    4）禁止向提供Applet之外的任何主机建立网络连接；\n    5）不能读取某些系统信息；\n    6）由一个Applet弹出的窗口外观上与一个Application弹出的窗口不同，Applet弹出的窗口中将会有警告提示信息，以帮助用户区分Applet窗口与可信的Application窗口。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":384,
"title":"下列叙述中，错误的是______。",
"optionA":"Applet事件处理机制与Java Application相同 ",
"optionB":"JApplet事件处理机制采用监听器方式 ",
"optionC":"JApplet事件处理机制采用监听器方式 ",
"optionD":"JApplet事件处理机制不是采用监听器方式 ",
"answer":"D",
"explain":"    本题考的是Applet事件处理。\n    Applet事件处理机制与Java Application相同，采用监听器方式，JApplet也是采用相同的技术。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":385,
"title":"如果使用Thread t=new Test()语句创建一个线程，则下列叙述正确的是______。",
"optionA":"Test类一定要实现Runnable接口 ",
"optionB":"Test类一定是Thread类的子类",
"optionC":"Test类一定是Runnable的子类",
"optionD":"Test类一定是继承Thread类并且实现Runnable接口",
"answer":"D",
"explain":"    本题考查的是线程创建的方法。\n    线程的创建有两种方法：实现Runnable接口和继承Thread类。\n    （1）通过实现Runnable接口创建线程：当实现Runnable接口的类的对象用来创建线程后，该线程的启动将使得对象的run()方法被调用。通过这种方式创建线程的过程是：Runnable的一个实例作为参数传递给Thread类的一个构造方法，该实例对象提供线程体run()。\n    （2）通过继承Thread类创建线程：Thread类本身实现了Runnable接口，所以在java.lang的Thread类的定义中可以发现run()方法。因此，可以通过继承Thread类，并重写其中的run()方法定义线程体，然后创建该子类的对象，从而创建线程。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":386,
"title":"在Java中，\"目录\"被看作是______。",
"optionA":"文件 ",
"optionB":"流 ",
"optionC":"数据",
"optionD":"接口",
"answer":"A",
"explain":"    本题考查的是目录的概念。\n    目录在Java中作为一种特殊文件，即文件名的列表，通过类File所提供的方法，可得到文件或目录的描述信息（包括名字、路径、长度、可读、可写等），也可以生成新文件、目录、修改文件和目录，查询文件属性，重命名文件或者删除文件。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":387,
"title":"阅读下列一个支持多线程并发操作的堆栈类代码段\npublic class MyStack{\n  private int idx=0;\n  private int[] data=new int[8];\n  public ______ void push(int i){\n     data[idx]=i;\n     idx++;\n  }\n  ……\n}\n在下划线处应填入的是______。",
"optionA":"synchronized ",
"optionB":"wait ",
"optionC":"blocked ",
"optionD":"interrupt ",
"answer":"A",
"explain":"    本题考查的是多线程并发操作。\n    Java中对共享数据操作的并发控制是采用传统的封锁技术。一个程序中单独的、并发的线程对同一个对象进行访问的代码段，称为临界区（Critical Sections）。在Java语言中，临界区可以是一个语句块或是一个方法，并且用\"synchronized\"关键字标识。Java平台将每个由synchronized(Object)语句指定的对象设置一个锁，成为对象锁（monitor），其是一种独占的排他锁（exclusive locks），这种锁的含义是，当一个线程获得了对象锁后，便拥有该对象的操作权，其他任何线程不能对该对象进行任何操作。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":388,
"title":"阅读下列代码\nclass Test implements Runnable{\n    public int run(){\n        int i = 0;\n        while (true){\n            i++;\n            System.out.println(\"i=\"+i);\n        }\n    }\n}\n上述代码的编译结果是______。",
"optionA":"程序通过编译并且run()方法可以正常输出递增的i值",
"optionB":"程序通过编译，调用run()方法将不显示任何输出",
"optionC":"程序不能通过编译，因为while的循环控制条件不能为\"true\"",
"optionD":"程序不能通过编译，因为run()方法的返回值类型不是void",
"answer":"D",
"explain":"    本题考查的是多线程。\n    run()方法必须是public访问权限，返回值类型为void。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":389,
"title":"Java中类ObjectOutputStream支持对象的写操作，这是一种字节流，它的直接父类是______。",
"optionA":"Writer ",
"optionB":"DataOutput ",
"optionC":"OutputStream",
"optionD":"ObjectOutput ",
"answer":"C",
"explain":"    本题考查的是Java中包含的输入\/输出流的类。\n    非字符输出流都是OutputStream抽象类的子类。其中ObjectOutputStream既继承了OutputStream抽象类，又实现了ObjectOutput接口，这是Java用接口技术代替双重继承例子，其构造方法参数是串行化了的对象。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":390,
"title":"当一个Applet被加载，后续对Applet生命周期方法的调用中，可能存在的次序是______。",
"optionA":"start(),stop(),destroy()",
"optionB":"init(),start(),stop(),start(),stop(),destroy()",
"optionC":"start(),init(),stop(),destroy()",
"optionD":"init(),start(),destroy()",
"answer":"B",
"explain":"    本题考查的是Applet的生命周期。\n    在Java Applet的生命周期中，共有四种状态和四种方法分别为初始态、运行态、停止态和消亡态四种状态以及init()、start()、stop()和destroy()四种方法。\n    当一个Applet被加载，后续对Applet生命周期方法的调用中，存在的次序如下：浏览器生成该Applet的一个实例，调用init()方法执行一些初始化操作。执行完毕后，浏览器调用start()方法启动Applet。当退出当前主页时，浏览器调用stop()方法终止start()方法中启动的线程。接着执行destroy()方法释放Applet所占的资源。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":391,
"title":"下列关于Applet的叙述中，正确的是______。",
"optionA":"Applet不仅可以嵌入到浏览器中运行，还可以独立运行 ",
"optionB":"Applet的主类要定义为Applet类或JApplet类的子类",
"optionC":"同一个页面中的Applet之间不能通信",
"optionD":"Applet不支持多线程",
"answer":"B",
"explain":"    本题考查的是Applet的概念。\n    Applet是能够嵌入到HTML页面中，并能够在浏览器中运行的Java类。Applet自身不能运行，必须嵌入在其他应用程序中运行，所以选项A错误；任何嵌入在Web页面中或appletviewer中的Applet必须是Java中Applet类的子类，而JApplet是Applet类的扩展，它增加了对JFC\/Swing构件结构的支持，因此选项B正确；同一个页面中的Applet之间可以通信，所以选项C错误；Applet程序是Java语言编写的小应用程序，符合Java语言的特点，因此也支持多线程，所以选项D错误。",
"type":"异常处理",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":392,
"title":"下列情况中，不会使线程返还所持有的对象锁的是______。",
"optionA":"当synchronized()语句块执行完毕",
"optionB":"当调用了线程的suspend()方法",
"optionC":"当在synchronized()语句块中出现异常(exception)",
"optionD":"当持有锁的线程调用该对象的wait()方法",
"answer":"B",
"explain":"    本题考查的是线程的同步问题。\n    对象锁在如下几种情况下由持有线程返还：\n    （1）当synchronized()语句块执行完后。\n    （2）当在synchronized()语句块中出现例外(exception)。\n    （3）当持有锁的线程调用该对象的wait()方法。此时该线程将释放对象的锁，而被放入对象的wait pool中，等待某事件的发生。\n    而suspend()方法只是基本线程控制方法，在一个线程中调用t.suspend()，将使t暂停执行，要想恢复线程，必须由其他线程调用t.resume()恢复t的执行。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":393,
"title":"Swing构件的程序不具有______。",
"optionA":"本地代码",
"optionB":"标签",
"optionC":"菜单",
"optionD":"容器",
"answer":"A",
"explain":"    本题考查的是Swing构件。\n    随着发展的需要，Swing出现了，Swing组件几乎都是轻量组件，与重量组件相比，没有本地的对等组件，不像重量组件要在它们自己的本地不透明窗体中绘制，轻量组件在它们的重量组件的窗口中绘制。\n    Swing是由100%纯Java实现的，Swing组件是用Java实现的轻量级（ light-weight）组件，没有本地代码，不依赖操作系统的支持，这是它与AWT组件的最大区别。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":394,
"title":"下列命令中，______命令是Java的编译命令。",
"optionA":"javac",
"optionB":"java",
"optionC":"javadoc",
"optionD":"appletviewer",
"answer":"A",
"explain":"    本题考查的是Java运行过程。\n    Java有两类应用程序，Java Application和Java Applet。它们编译源代码时运用应用程序相同，即javac.exe。\n    java.exe是用于Java Application程序解释执行的，若执行成功，显示结果；若执行有错，则显示错误报告。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":395,
"title":"下列不属于java.io包中的抽象类的是______。",
"optionA":"InputStream",
"optionB":"FilterOutputStream",
"optionC":"Reader",
"optionD":"Serializable",
"answer":"D",
"explain":"本题考查的是流的概念。\n选项A、B、C都属于java.io包中的抽象类，其中InputStream是用于处理字节流的抽象类；FilterOutputStream是用于处理过滤流的抽象类；Reader类是用于处理字符流的抽象类；而Serializable是一个接口，用来处理对象流。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":396,
"title":"设有下面两个类的定义：\nclass  Person {\n}\nclass  Student  extends  Person {\n  long  id; \n  int   score; \n  String name;\n  int    getScore(){\n       return score;\n      }\n  }\n上面两个类之间的关系是______。",
"optionA":"包含关系 ",
"optionB":"继承关系 ",
"optionC":"关联关系 ",
"optionD":"无关系，上述类定义有语法错 ",
"answer":"B",
"explain":"    本题考查的是类的继承。\n    对一个类的继承是指在现有类（父类）的基础上构建一个新类（子类），子类重用（继承）了父类的方法和状态，同时还可以向新类中增添新的方法和状态。Java中创建子类是通过在类声明中加入extends子句来实现的。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":397,
"title":"阅读下列代码后\npublic class Person{\n    int arr[]=new int[10];\n    public static void main(String args[]){\n        System.out.println(arr[1]);\n    }\n}\n正确的说法是______。",
"optionA":"编译时将产生错误",
"optionB":"编译时正确，运行时将产生错误",
"optionC":"输出为零",
"optionD":"输出为空",
"answer":"A",
"explain":"    本题考查的是数组的使用。\n    由于数组arr声明时未用static关键字，而main()方法直接引用arr（而非通过Person的实例引用），将产生\"非静态变量不能从静态上下文中引用\"（non-static variable cannot be referenced from a static context）的编译错误。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":398,
"title":"下列关于Java多线程并发控制机制的叙述中，错误的是______。",
"optionA":"Java中对共享数据操作的并发控制是采用加锁技术",
"optionB":"线程之间的交互，提倡采用suspend()\/resume()方法 ",
"optionC":"共享数据的访问权限都必须定义为private",
"optionD":"Java中没有提供检测与避免死锁的专门机制，但应用程序员可以采用某些策略防止死锁的发生",
"answer":"B",
"explain":"        本题考查的是并发控制。\n    1）Java中对共享数据操作的并发控制是采用传统的封锁技术。一个程序中单独的、并发的线程对同一个对象进行访问的代码段，称为临界区。在Java语言中，临界区可以是一个语句块或是一个方法，并且用\"synchronized\"关键字标识。Java平台将每个由synchronized（Object）语句指定的对象设置一个锁，称为对象锁。\n    2）共享数据的所有访问都必须作为临界区，使用\"synchronized\"进行加锁控制。用\"synchronized\"保护的数据也必须是私有的，使线程不能直接访问这些数据，必须通过对象的方法。\n    3）Java中没有检测与避免死锁的专门机制，因此完全由程序进行控制，防止死锁的发生。\n    4）有时，某个线程进入\"synchronized\"块后，共享数据的状态并不一定满足线程的需要，它要等待其他线程将共享数据改变为它需要的状态后才能继续执行，但由于此时它占有了该对象的锁，其他线程无法对共享数据进行操作，为此Java引入wait()和notify()，这两个方法使java.lang.object类的方法，使实现线程通信的两个方法。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":399,
"title":"java.io包的File类是______。",
"optionA":"字符流类",
"optionB":"字节流类",
"optionC":"对象流类",
"optionD":"非流类",
"answer":"D",
"explain":"    本题考察的是文件操作的概念。\n    文件类File是java.io包中的一个重要的非流类。File以一种系统无关的方式表示一个文件对象的属性。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":400,
"title":"下列标识符（名字）命名原则中，正确的是______。",
"optionA":"类名的首字母小写",
"optionB":"变量和方法名的首字母大写",
"optionC":"接口名的首字母小写",
"optionD":"常量完全大写",
"answer":"D",
"explain":"    本题考查的是Java的命名约定。\n    Java的命名约定的基本原则如下：\n（1）_、$不作为变量名、方法名开头。\n（2）变量名、方法名首单词小写，其余单词只有首字母大写。如myVariable，myMethod。\n（3）接口名、类名的单词首字母大写。如MyInterface，MyClass。\n（4）常量名的每个字母都大写。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":401,
"title":"为保护本地主机，对Applet安全限制中正确的是______。",
"optionA":"Applet可加载本地库或方法",
"optionB":"Applet可读、写本地计算机的文件系统",
"optionC":"Applet可向Applet之外的任何主机建立网络连接 ",
"optionD":"Applet不能运行任何本地可执行程序 ",
"answer":"D",
"explain":"    本题考的是Applet的安全限制。\n    许多浏览器为了保护本地主机，对Applet作了如下安全限制：\n1、Applet不能运行任何本地可运行程序；\n2、禁止加载本地库或方法；\n3、禁止读、写本地计算机的文件系统；\n4、禁止向提供Applet之外的任何主机建立网络连接；\n5、不能读取某些系统信息，除了Java版本号、操作系统名或版本号、文件分隔符、路径分隔符以及行分隔符之外，Applet不能获得与本地计算机有关的任何信息，如：用户名、电子邮件地址等；\n6、由一个Applet弹出的窗口外观上与一个Application弹出的窗口不同，Applet弹出的窗口中将会有警告提示信息，以帮助用户区分Applet窗口与可信的Application窗口。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":402,
"title":"下列方法中，声明抛出InterruptedException类型异常的方法是______。",
"optionA":"suspend()",
"optionB":"resume()",
"optionC":"sleep()",
"optionD":"start()",
"answer":"C",
"explain":"    本题考查的是声明异常。\n    在Java语言中，有时一个方法生成一个异常，但该方法并不能确定如何处理异常，如找不到文件之类的异常，必须将异常传递给调用方法，由调用它的方法来处理，这时候方法用声明异常抛出，让异常对象可从调用栈向后传递，直到有相应的方法捕获它为止。\n    sleep()方法是使一个线程暂停运行一段固定的时间。在休眠时间内，线程将不运行。当一个线程正在等待、休眠或暂停了较长时间，而另一个线程用Thread类中的interrupt方法中断它时抛出该异常。 ",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":403,
"title":"阅读下面实现堆栈类并发控制的部分代码\npublic class DataStack{\n  private int idx=0;\n  private int[] data=new int[8];\n  public void push(int i){\n  ______{\n    data[idx]=i;\n    idx++;\n  }\n }\n  … …\n}\n在程序下划线处填入正确选项是______。",
"optionA":"synchronized",
"optionB":"synchronized(this)",
"optionC":"synchronized()",
"optionD":"synchronized(idx)",
"answer":"B",
"explain":"    本题考查的是对象的加锁及其操作。\n    一个程序中单独的、并发的线程对同一个对象进行访问的代码段，称为临界区（Critical Sections）。在Java语言中，临界区可以是一个语句块或是一个方法，并且用\"synchronized\"关键字标识。Java平台将每个由synchronized(Object)语句指定的对象设置一个锁，成为对象锁（monitor），其是一种独占的排他锁（exclusive locks），这种锁的含义是，当一个线程获得了对象锁后，便拥有该对象的操作权，其他任何线程不能对该对象进行任何操作。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":404,
"title":"阅读下列代码\npublic class Test implements Runnable{\n  public void run(Thread t){\n    System.out.println(\"Running.\");\n  }\npublic static void main(String[] args){\n  Thread tt=new Thread(new Test());\n    tt.start();\n  }\n}\n代码运行结果是______。",
"optionA":"将抛出一个异常 ",
"optionB":"没有输出并正常结束",
"optionC":"输出\"Running\"并正常结束",
"optionD":"程序第2行将出现一个编译错误",
"answer":"D",
"explain":"    本题考查的是多线程。\n    程序运行提示：Test不是抽象类，并且未覆盖java.lang.Runnable中的抽象方法run()。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":405,
"title":"如果线程调用下列方法，不能保证使该线程停止运行的是______。",
"optionA":"sleep()",
"optionB":"stop()",
"optionC":"yield()",
"optionD":"wait()",
"answer":"C",
"explain":"    本题考查的是线程状态。\n    sleep()方法的作用是让当前线程处于休眠状态，并持续一定的时间，该时间的长短由sleep()方法的参数决定。sleep()方法结束后，线程将进入可运行状态。\n    stop()方法的作用是当线程完成运行并结束后，将不再运行。\n    yield()方法的作用是暂停当前线程的执行，从而允许与它具有相同优先级的线程执行，如果不存在可执行且与它同优先级的线程，则继续执行当前线程。\n    wait()方法的作用是，当某线程需要在synchronized块中等待共享数据状态改变时，调用wait()方法，这样该线程等待并暂时释放共享数据对象的锁，其它线程可以获得该对象的锁，并进入synchronized块对共享数据进行操作，而此线程则放入wait pool中，转入阻塞状态。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":406,
"title":"在下列程序的空白处，应填入的正确选项是______。\nimport java.io.*;\npublic class ObjectStreamTest{\n  public static void main(String args[]) throws IOException {\n     ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"serial.bin\"));\n     java.util.Date d = new java.util.Date();\n     oos.______(d);\n     ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"serial.bin\"));\n     try{\n         java.util.Date restoredDate = (java.util.Date) ois.readObject();\n         System.out.println(\"read Object back from serial.bin file: \"+restoredDate);\n     }\n     catch(ClassNotFoundException cnf) {\n      System.out.println(\"class not found\");\n     }\n  }\n}",
"optionA":"WriteObject ",
"optionB":"write ",
"optionC":"BufferedWriter",
"optionD":"writeObject",
"answer":"D",
"explain":"    本题考查的是输入输出及文件操作。\n    ObjectOutputStream.writeObject()的作用是把一个实例的对象以二进制形式编写的文件保存到磁盘上。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":407,
"title":"在HTML文件的<applet>标志中作为可选属性的是______。",
"optionA":"Applet主类的文件名",
"optionB":"Applet显示区域的宽度",
"optionC":"Applet主类的路径",
"optionD":"Applet显示区域的高度",
"answer":"C",
"explain":"    本题考查的是HTML的Applet标记。\n    对于支持Java的浏览器，如果在解析一个HTML文件时遇到<applet>标记，就按照width和height属性的值，为Applet保留一定大小的显示空间，并根据code指定Applet的字节码文件，用户可以通过网络获得该文件。最简单的HTML文件为<HTML><applet code=Example.class width=260px height=300px ><\/applet><\/HTML>。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":408,
"title":"当一个Applet所在的Web页面被其他页面覆盖后，不可能被调用的Applet方法是______。",
"optionA":"destroy()",
"optionB":"init()",
"optionC":"stop()",
"optionD":"start()",
"answer":"B",
"explain":"    本题考查的是Applet类的生命周期方法。\n    Applet类提供了生命周期不同阶段响应主要事件的4种方法：init()、start()、stop()和destory()。\n    在Applet装载时，调用init()通知该Applet已被加载到浏览器中，使Applet执行－些基本初始化操作。\n    void destroy()，在关闭浏览器Applet从系统中撤出时调用。\n    stop()总是在此前被调用。",
"type":"Java编程技术基础",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":409,
"title":"java中对Applet设置了严格的安全限制。下列关于Applet在Java2中安全限制叙述正确的是______ 。",
"optionA":"根本无法解除",
"optionB":"只有部分限制可以解除，而其它限制无法解除",
"optionC":"可以在安全策略的控制下解除",
"optionD":"已经缺省地全部解除",
"answer":"C",
"explain":"    本题考查的是Applet的安全限制。\n    在Java1.0中，沙箱对Applet限制根本无法排除，而在Java2中可以通过策略文件来授予Applet所需的权限，该文件可以通过文本编辑器进行编辑，也可以通过图形化工具来编辑。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":410,
"title":"在Java API文档中下面的______部分不被包括在内。",
"optionA":"类及用途的描述",
"optionB":"父类的方法的列表",
"optionC":"成员变量的列表",
"optionD":"类层次 ",
"answer":"B",
"explain":"    本题考查的是API包的内容。\n    类文档的内容主要是：类层次、类及用途描述、成员变量列表、构造方法列表、成员方法列表、从类层次上继承的方法列表、成员变量的详细说明、构造方法详细说明、成员方法详细说明。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":411,
"title":"设有下面的两个类定义：\nclass  AA {  \n  void  Show(){ System.out.println(\"我喜欢Java!\");}\n}\nclass  BB extends  AA { \n  void  Show(){ System.out.println(\"我喜欢C++!\");}\n} \n则顺序执行如下语句后输出结果为______。\nAA   a=new AA();\nBB   b=new BB();\na.Show();\nb.Show(); ",
"optionA":"我喜欢Java! \n我喜欢C++! ",
"optionB":"我喜欢C++!\n我喜欢Java!  ",
"optionC":"我喜欢Java! \n我喜欢Java! ",
"optionD":"我喜欢C++!\n我喜欢C++! ",
"answer":"A",
"explain":"    本题考查的是Java语言中类的层次和函数的调用。\n    由于程序先执行a.Show()函数，这个函数的输出是\"我喜欢Java!\"，再执行b.Show()函数，由于BB中重载了Show方法的输出\"我喜欢C++!\"。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":412,
"title":"下列操作中，不属于Applet安全限制的是______。",
"optionA":"加载本地库",
"optionB":"读写本地文件系统",
"optionC":"运行本地可执行程序   ",
"optionD":"与同一个页面中的Applet通信",
"answer":"D",
"explain":"    本题考查的是Applet的安全限制。\n    Java平台为了防范恶意程序的攻击，使用了安全管理器，安全管理器执行系统资源的访问控制。许多浏览器为了保护本地主机，对Applet作了如下安全限制：\n    1）Applet不能运行任何本地可运作程序。\n    2）禁止加载本地库或方法。Applet只能使用自身的代码或Applet浏览器提供的Java API。\n    3）禁止读、写本地计算机的文件系统。\n    4）禁止向提供Applet之外的任何主机建立网络连接等等。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":413,
"title":"下列描述，正确的是______。",
"optionA":"在serializable接口中定义了抽象方法",
"optionB":"在Serializable接口中定义了常量",
"optionC":"在Serializable接口中没有定义抽象方法，也没有定义常量",
"optionD":"在serializable接口中定义了成员方法",
"answer":"C",
"explain":"    本题考察的是Serializable接口。\n    在JAVA中很多类都实现Serializable接口，这个接口用来处理对象流，可是这个接口是没有方法和属性的。Serializable会为每个类生成一个序列号，生成依据是类名、类实现的接口名、public和protected方法。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":414,
"title":"提供showDocument()方法，使Applet能够请求浏览器访问特定URL的类是______。",
"optionA":"Applet",
"optionB":"AppletContext",
"optionC":"JApplet",
"optionD":"URL",
"answer":"B",
"explain":"    本题考的是Applet与工作环境的通信。\n    通过AppletContext的showDocument()方法，Applet可以通知浏览器在哪个窗口中显示哪个URL中的文件。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":415,
"title":"J2SDK基本命令中能生成C语言头文件的命令是______。",
"optionA":"javah",
"optionB":"javap",
"optionC":"jar",
"optionD":"java",
"answer":"A",
"explain":"    本题考的是J2SDK的操作命令。\n    Javah，生成C头文件和Stub文件；\n    Javap，Java类文件解析器，用于解析类文件；\n    Jar，Java类文件归档命令，可将多个文件合并为单个JAR归档文件；\n    Java，Java语言的解释器，解释运行Java字节码。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":416,
"title":"如果线程正处于运行状态，可使该线程进入阻塞状态的方法是______。",
"optionA":"yield()",
"optionB":"start()",
"optionC":"wait()",
"optionD":"notify()",
"answer":"C",
"explain":"    本题考查的是线程进入阻塞的方法。\n    yield()方法：调用该方法后，可以使具有与当前线程相同优先级的线程有运行的机会。如果有其他的线程与当前线程具有相同的优先级并且是可运行的，该方法将把调用yield()方法的线程放入可运行的线程池，并允许其他线程运行。所以A选项不正确。\n    start()方法不会自动运行，它是在新进程创建后调用的，所以也不选B。\n    wait()方法和notify()方法在线程交互时使用，线程调用wait()方法时，线程由运行状态进入阻塞状态；当线程调用notify()方法时，则对象的wait pool中的一个线程将移入lock pool，在lock pool中线程将等待锁，一旦获得便可运行。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":417,
"title":"下列关于对象串行化的说法中错误的是______。",
"optionA":"Java中，默认所有类的对象都可串行化",
"optionB":"在对象串行化时，不保存对象所属类的构造方法",
"optionC":"在实现Serializable接口的类中，用transient关键字可使某些数据不被串行化 ",
"optionD":"ObjectInputStream和ObjectOutputStream类都支持对象的读和写",
"answer":"A",
"explain":"    本题考查的是对象的串行化。\n    一个类只有实现了Serializable接口，它的对象才是可串行化的。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":418,
"title":"阅读下列代码\npublic class Test{\n  String s=\"One World One Dream\";\n  public static void main(String args[]){\n    System.out.println(s);\n  }\n}\n其运行结果是______。",
"optionA":"args",
"optionB":"One World One Dream",
"optionC":"s",
"optionD":"编译时出错",
"answer":"D",
"explain":"    本题考查的是变量的声明。\n    main方法是程序执行的入口，在本程序中main方法中的语句\"System.out.println(s);\"无法调用在main方法外声明的变量，所以编译时出错。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":419,
"title":"Class类的对象由______自动生成，隐藏在.class文件中，它在运行时为用户提供信息。",
"optionA":"Java编译器",
"optionB":"Java解释器",
"optionC":"Java new关键字",
"optionD":"Java类分解器",
"answer":"A",
"explain":"    本题考查的是Java程序编写及运行的过程。\n    二进制字节码文件.class文件是由编译器自动生成。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":420,
"title":"如果应用程序要在Applet上显示输出，则必须重写的方法是______。",
"optionA":"Graphics.drawString()",
"optionB":"repaint()",
"optionC":"paint()",
"optionD":"update()",
"answer":"C",
"explain":"    本题考查的是Applet的图形绘制。\n    Applet中有几个与显示图形相关的方法，这些方法是由Component类提供的，且作用各不相同。它们分别是paint()方法、update()方法和repaint()方法。①paint()方法用于进行绘图的具体操作。但是Component类只提供了paint()方法，而没有实现任何操作，如果希望在组件中绘图，必须重写paint()方法，编写自己的程序段。②update()方法用于更新图形。它首先清除背景，然后设置前景，再调用paint()方法完成组件中的具体绘图。③repaint()方法用于重绘图形。在组件外形发生变化，即大小改变或位置移动时，repaint()方法立即被系统自动调用。它调用update()方法以实现对组件的更新。repaint()方法有几种重装的方法，分别调用不同的repaint()方法，可实现对组件的局部进行重绘、延时重绘等功能。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":421,
"title":"要向Applet传递参数，应该在下列drawing.html文件的下划线处填入的选项是______。\n……\n<applet code=DrawImage.class width=100 height=100>\n______\n<\/applet>\n……",
"optionA":"<param image,\"flower.gif\"> ",
"optionB":"<param image value=flower.gif> ",
"optionC":"<param name=image value=\"flower.gif\"> ",
"optionD":"<param name=\"image\" value=\"flower.gif\"> ",
"answer":"C",
"explain":"    本题考查的是<APPLET>标记。\n    <APPLET>标记的一般格式为：\n    <APPLET CODE=……>\n    [<PARAM NAME=appletParameter1 VALUE=value>]\n    [<PARAM NAME=appletParameter2 VALUE=value>]\n    ……\n    [alternateHTML]\n    <\/APPLET>\n    程序中flower.gif是一个图像文件。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":422,
"title":"下列关于面向对象的论述中，正确的是______。",
"optionA":"面向对象是指以对象为中心，分析、设计和实现应用程序的机制 ",
"optionB":"面向对象是指以功能为中心，分析、设计和实现应用程序的机制",
"optionC":"面向对象仅适用于程序设计阶段",
"optionD":"面向对象是一种程序设计语言",
"answer":"A",
"explain":"    本题考查的是Java语言的特点。\n    面向对象的语言将客观世界看成由各种对象组成，对象客观实体可定义成大的结构-类(class)，每个类有自己的特性（属性）和操作（方法）。面向对象技术使复杂的问题可以分解化，大大提高了软件的重用性。与其他面向对象语言相比，Java利用面向对象技术更彻底。它把所有的Java应用和Applet都看做对象，按类封装，其封装性实现了模块化和信息隐藏，继承性实现了代码重用，让用户可以自由地定义数据类型，建立自己的类库。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":423,
"title":"语句\"Hello\".equals(\"hello\");的正确执行结果是______。",
"optionA":"true",
"optionB":"false",
"optionC":"0",
"optionD":"1",
"answer":"B",
"explain":"    本题考查的是字符串对象的比较运算。\n    equals()是Object的方法，和\"==\"一样，功能是比较两个操作数是否是同一个对象，但类库中许多子类重写了equals()方法，使其变为比较两个操作数的内容是否一样，两串相等则返回ture，否则返回false。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":424,
"title":"下列关于Java源程序结构的论述中，正确的是______。",
"optionA":"一个文件包含的import语句最多1个",
"optionB":"一个文件包含的public类最多1个",
"optionC":"一个文件包含的接口定义最多1个",
"optionD":"一个文件包含的类定义最多1个",
"answer":"B",
"explain":"    本题考查的是Java程序结构。\n    Java规定，源文件中最多只能有一个public类。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":425,
"title":"下列不属于Java关键字的是______。",
"optionA":"this",
"optionB":"super",
"optionC":"finally",
"optionD":"NULL",
"answer":"D",
"explain":"    本题考查的是Java的关键字。\n    Java中，this、super和finally是Java关键字，而常量null是小写，所以NULL不属于Java关键字。",
"type":"线程的概念和使用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":426,
"title":"在堆栈类SharedStack的定义中，为了保证堆栈在并发操作中数据的正确性，应在下划线处填入的修饰符是（两个下划线的填写内容相同）。\npublic class SharedStack{\n   ______ int idx =0;\n   ______ char[] data = new char[10];\n   public synchronized void push (char c){……}\n   public synchronized void pop() {……}\n}",
"optionA":"public ",
"optionB":"不使用修饰符",
"optionC":"private",
"optionD":"protected",
"answer":"C",
"explain":"    本题考查的是线程并发控制。\n    synchronized关键字可用来检测和获得对象锁，并设定临界区。为了防止对共享数据的访问发生错误，应该将访问共享数据的代码使用synchronized关键字设置成临界区。这样加锁进行保护。\n    本题程序定义了一个简单的堆栈类，该类中定义了长度为10的字符数组作为堆栈的数据区，并且定义了整型变量idx为栈顶指针，idx指向栈顶的空单元。用synchronized保护的共享数据必须是私有的，将共享数据定义为私有的，使线程不能直接访问这些数据，必须通过对象的方法。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":427,
"title":"下列代码的执行结果是______。\nint length =\"Hello\".length();\nSystem.out.println(length);",
"optionA":"5",
"optionB":"2",
"optionC":"10",
"optionD":"6",
"answer":"A",
"explain":"    本题考查的是字符串操作。\n    String类包括的方法有：length()、charAt()、indexOf()、lastIndexOf()、getChars()、getBytes()、toCharArray()等，其中，提取字符串长度的方法是\"length()\"。\n    本题程序可以理解为：\n    String greeting=\"Hello\";\n    int length=greeting.length(); \/\/返回字符串的字符个数n=5\n    System.out.println(length);\n    也就是将字符串\"Hello\"的字符个数赋值给整型变量length，并输出。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":428,
"title":"下列选项中能实现循环功能的语句是______。",
"optionA":"break",
"optionB":"if",
"optionC":"continue",
"optionD":"for",
"answer":"D",
"explain":"    本题考查的是循环语句。\n    break语句用来在执行完一个case分支后，使程序跳出switch语句，从switch结构后面的第一条语句开始执行。在Java中，还可以用break语句退出循环，并从紧跟该循环结构的第一条语句处开始执行。\n    if语句用于检查一个条件是真或假（true或false）。\n    continue语句是跳过循环体中下面尚未执行的语句，回到循环体的开始继续下一轮的循环。\n    当事先知道了循环会被重复执行多少次时，可以选择Java提供的确定循环结构--for循环。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":429,
"title":"下列代码中的短路逻辑运算符是______。\npublic class MyShortCut{\n  public static void main(String[] args){\n    int a=5,b=10;\n      if((a!=5)&&(b<30))\n         System.out.println(\"ok\");\n  }\n}",
"optionA":"=",
"optionB":"!=",
"optionC":"&&",
"optionD":"<",
"answer":"C",
"explain":"    本题考查的是运算符。\n    短路：在逻辑表达式中，如果能通过逻辑运算符左边表达式的值就能推算出整个表达式的值，那么将不再执行逻辑运算符右边的表达式。\n    Java中的&&、||运算采用\"短路\"方式进行计算，先求出运算符左边的表达式的值，如果该值为true，对于||运算来说，则整个布尔逻辑表达式的结果必然为true，从而不再对||运算符右边的表达式进行运算；同样，对&&运算，如果左边表达式的值为false，则不会再对运算符右边的表达式求值，整个布尔逻辑表达式的结果为false。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":430,
"title":"下列方法中，可以正确加入类SubX中且父类的方法不会被覆盖的是______。\nclass X{\n   public int F(int a,int b){\n      int s;\n      s=a+b;\n      return s;\n   }\n}\nclass SubX extends X{}",
"optionA":"int F(int a,int b){}",
"optionB":"public void F(){}",
"optionC":"public int F(int a,int b) throws MyException {}",
"optionD":"public float F(int a,int b,float b=1.0){}",
"answer":"B",
"explain":"    本题考查的是方法的重载。\n    如果子类继承了父类，而没有定义与父类中同名的方法，那就是简单的继承父类的方法。\n    如果子类中定义了与父类中同名但参数不同的方法，那就是重载，当用子类的对象调用该方法时，将根据参数来决定是调用在父类中定义的方法，还是调用在子类中定义的方法。\n    如果子类中定义了与父类中同名且参数个数和类型都相同的方法，那就是覆盖，当用子类的对象来调用该方法时，只能是调用在子类中定义的方法，因为父类中的方法被覆盖了。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":431,
"title":"下列代码中的窗口事件类是______。\npublic class MyWindow extends WindowAdapter{\n    public void windowClosing(WindowEvent e){}\n    public void windowClosed(WindowEvent e){}\n    public void windowOpened(WindowEvent e){}\n}",
"optionA":"windowClosing",
"optionB":"windowClosed",
"optionC":"WindowEvent",
"optionD":"windowOpened",
"answer":"C",
"explain":"    本题考查的是窗口事件类。\n    本题程序中，窗口事件类是WindowEvent。windowClosing、windowClosed和windowOpened是方法名。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":432,
"title":"下列方法调用后，将会改变线程生命周期状态的是______。\nI.   join() \nII.  isAlive()\nIII. sleep()\nIV.  notify()",
"optionA":"I和II",
"optionB":"III和IV",
"optionC":"I和III",
"optionD":"II和IV",
"answer":"C",
"explain":"    本题考查的是线程状态与生命周期。\n    线程的生命周期主要分为如下几个状态：新建状态、可运行状态、运行状态、阻塞状态、终止状态。\n    假设当前线程处于运行状态，则会改变线程当前状态的操作总结如下：\n    （1）当前线程执行了yield()，或当前线程因调度策略（执行过程中，有一个更高优先级的线程进入可运行状态，这个线程立即被调度执行，当前线程占有的CPU被抢占；或在分时方式时，当前执行线程执行完当前时间片）从而导致当前线程进入可运行状态。\n    （2）线程调用了sleep()方法、join()方法、wait()方法时，线程进入阻塞状态。\n    其中yield()方法的作用是暂停当前线程的执行，从而允许与它具有相同优先级的线程执行，如果不存在可执行且与它同优先级的线程，则继续执行当前线程。\n    当某线程需要在synchronized块中等待共享数据状态改变时，调用wait()方法，这样该线程等待并暂时释放共享数据对象的锁，其它线程可以获得该对象的锁，并进入synchronized块对共享数据进行操作，而此线程则放入wait pool中，转入阻塞状态，当其它线程对共享数据操作完后，只要调用notify()方法就可以通知正在等待的线程重新占有锁，并运行。\n    sleep方法的作用是让当前线程处于休眠状态，并持续一定的时间，该时间的长短由sleep()方法的参数决定。sleep()方法结束后，线程将进入可运行状态。\n    而isAlive()方法的作用是测试线程，以确定线程是否活着。此方法并不会改变线程生命周期中的状态。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":433,
"title":"下列不属于面向对象技术特点的是______。",
"optionA":"封装",
"optionB":"继承",
"optionC":"多态",
"optionD":"多线程",
"answer":"D",
"explain":"    本题考查的是面向对象技术。\n    面向对象技术的基本特征主要有抽象性、封装性、继承性和多态性。\n    Java语言的一个重要的特性是在语言级上支持多线程的程序设计。多线程是指一个程序中包含多个执行流，多线程是实现并发的一种有效手段。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":434,
"title":"下列程序的运行结果是______。\npublic class Java_1 {\n   public static void main(String[] args){\n      int[][] a={{1,2,3,4},{5,6,7,8},{9,10,11,12}};\n      int s=0;\n      for(int i=0;i<a.length;i++)\n        s+=a[i][i];\n      System.out.println(s);\n   }\n}",
"optionA":"15",
"optionB":"18",
"optionC":"24",
"optionD":"78",
"answer":"B",
"explain":"    本题考查的数组。\n    本程序中定义了一个int型的二维数组，并对其初始化，程序中利用\"for(int i=0;i<a.length;i++)\"对二维数组中符合条件的数组元素的值进行求和。\n    循环运行过程如下：\n    第1轮循环，i=0时，条件为真，s=0+a[0][0]=0+1=1；\n    第2轮循环，i=1时，条件为真，s=1+a[1][1]=1+6=7；\n    第3轮循环，i=2时，条件为真，s=7+a[2][2]=7+11=18；\n    第4轮循环，i=3时，i<a.length条件不满足，退出循环。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":435,
"title":"若要使类TestClass不能派生子类，则正确的定义是______。",
"optionA":"public class TestClass{ }",
"optionB":"class TestClass{ }",
"optionC":"final class TestClass { }",
"optionD":"abstract class TestClass{ }",
"answer":"C",
"explain":"    本题考查的是final关键字。\n    final关键字用来修饰：\n    （1）数据。一个永不改变的量。\n    （2）方法。不可覆盖的方法。\n    （3）类。不可被继承的类。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":436,
"title":"下列选项中能正确创建一个InputStreamReader对象的是______。",
"optionA":"new InputStreamReader(new FileInputStream(\"hello.txt\"));",
"optionB":"new InputStreamReader(new FileReader(\"hello.txt\"));",
"optionC":"new InputStreamReader(new BufferedReader(\"hello.txt\"));",
"optionD":"new InputStreamReader(\"hello.txt\");",
"answer":"A",
"explain":"    本题考查的是文件和文件I\/O。\n    InputStreamReader是字节流通向字符流的桥梁，它的构造方法：InputStreamReader(InputStream in)，创建一个使用默认字符集的InputStreamReader。\n    FileInputStream的构造方法：FileInputStream(File file)，用来从文件中读取字节流。\n    因此，创建一个InputStreamReader对象为\"new InputStreamReader(new FileInputStream(\"hello.txt\"));\"。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":437,
"title":"下列程序的功能是在屏幕上每隔0.5秒显示一个字符串\"Hi!\"，但程序中存在编译错误，错误语句的行号是______。\n1 public class Test implements Runnable{\n2  public static void main(String[] args){\n3     Test t = new Test();\n4     t.start();\n5  }\n6\n7 public void run(){\n8   for(; ;){\n9   try {\n10     Thread.sleep(500);\n11     }catch(InterruptedException e){};\n12    System.out.println(\"Hi!\");\n13   }\n14  }\n15 }",
"optionA":"1",
"optionB":"3",
"optionC":"4",
"optionD":"8",
"answer":"C",
"explain":"    本题考查的是线程。\n    本程序中的run()方法的功能是在屏幕上每隔0.5秒显示一个字符串\"Hi!\"。在main()方法中，\"Test t = new Test();\"创建一个线程对象，行4需要调用run()方法，完成题目中的要求，则行4\"t.start();\"是错误语句，应修改为\"t.run();\"。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":438,
"title":"下列能生成Java文档的命令是______。",
"optionA":"java",
"optionB":"javaprof",
"optionC":"jdb",
"optionD":"javadoc",
"answer":"D",
"explain":"    本题考查的是JDK工具。\n    javadoc.exe是Java文档生成器，对Java源文件和包以MML格式产生AP文档。执行命令的格式：javadoc[选项]包名或javadoc[选项]文件名。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":439,
"title":"下列程序的运行结果是______。\npublic class Test{\n   public static void main(String[] args){\n      int percent=10;\n      tripleValue(percent); \n      System.out.println(percent);\n   }\n   public static void tripleValue(int x){\n      x=3*x;\n   }\n}",
"optionA":"40",
"optionB":"30",
"optionC":"20",
"optionD":"10",
"answer":"D",
"explain":"    本题考查的是参数的按值传递。\n    按值传递：指每次传递参数时，把参数的原始数值拷贝一份新的，把新拷贝出来的数值传递到方法内部，在方法内部修改时，修改的是拷贝出来的值，而原始的值不发生改变。\n    在Java语言中，对于基本数据类型是按值传递的。在本题中变量percent类型是int，属于按值传递，所以在tripleValue方法内部修改参数的值时percent的原始的值不发生改变。main函数中的输出语句\"System.out.println(percent);\"输出的是main函数为变量percent的定义的初值，即：10。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":440,
"title":"抽象类是______。",
"optionA":"不能派生子类的类",
"optionB":"不能实例化的类 ",
"optionC":"所有方法都是抽象方法的类 ",
"optionD":"方法体为空的类 ",
"answer":"B",
"explain":"    本题考查的是抽象类。\n    在Java语言中，用abstract修饰符定义的类称为抽象类，在其中的方法称为抽象方法。abstract类必须被继承，abstract方法必须被重写，abstract类不能实例化。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":441,
"title":"下列实现了动态数组的是______。",
"optionA":"Vector和ArrayList",
"optionB":"Map和Set",
"optionC":"Vector和Map",
"optionD":"ArrayList和Set",
"answer":"A",
"explain":"    本题考查的是动态数组。\n    Java动态数组是一种可以任意伸缩数组长度的对象，在Java中比较常用的是ArrayList，Vector等。\n    java.util.Vector提供了向量(Vector)类以实现类似动态数组的功能。\n    java.util.ArrayList（数组列表）在运行时能动态自动调整数组的大小。ArrayList类在定义数组时，不必限定数组的大小。在数组列表初始化时，可用add()方法将数组元素赋值。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":442,
"title":"下列程序的运行结果是______。\npublic class Test extends Thread{\n   public static void main(String[] args){\n      Thread t=new Thread();\n      t.start();\n   }\n   public void run(){\n      System.out.println(\"Hello\");\n   }\n}",
"optionA":"程序不能通过编译，因为没有import语句将Thread类引入",
"optionB":"程序不能通过编译，因为Test类没有实现Runnable接口",
"optionC":"程序通过编译，且运行正常，没有任何输出",
"optionD":"程序通过编译，且运行正常，打印出一个\"Hello\"",
"answer":"C",
"explain":"    本题考查的是多线程。\n    该程序实现了线程的创建。\n    在JAVA中，创建线程的方法有两种：一种是通过创建Thread类的子类来实现，另一种方法是通过实现Runnable接口的类来实现。\n    通过继承Thread类实现多线程的方法是首先设计Thread的子类，然后根据工作需要重新设计线程的run方法，再使用start方法启动线程，将执行权转交到run。\n    本题中，程序虽然继承了Thread类，并且重写了run方法，但是语句\"Thread t=new Thread();\"调用的还是Thread类的run方法，所以，程序通过编译，且运行正常，但没有任何输出。\n    如果想要打印出一个\"Hello\"，则需要将语句\"Thread t=new Thread();\"修改为\"Thread t=new Test();\"。",
"type":"同步与共享",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":443,
"title":"关于下列代码编译或执行结果的描述中，正确的是______。\npublic class Test{\n   public static void main(String args[]){\n      TestThread pm1 = new TestThread(\"One\");\n      pm1.start();\n      TestThread pm2 = new TestThread(\"Two\");\n      pm2.start();\n   }\n}\nclass TestThread extends Thread{\n  private String sTname=\" \";\n  TestThread(String s){\n     sTname = s;\n   }\n  public void run(){\n    for(int i=0;i<2;i++){\n  try{\n     sleep(1000);\n  }catch(InterruptedException e){}\n     System.out.print(sTname+\" \");\n  }\n }\n}",
"optionA":"不能通过编译，TestThread类中不能定义变量和构造方法",
"optionB":"输出One One Two Two",
"optionC":"输出Two One One Two",
"optionD":"选项B或C都有可能出现",
"answer":"D",
"explain":"    本题考查的是线程的使用。\n    Thread的sleep方法的原型如下：\n    public static void sleep(long millis)throws InterruptedException\n    sleep()的功能是让当前线程处于休眠状态，并持续一定的时间，该时间的长短由sleep()方法的参数决定。sleep()方法结束后，线程将进入可运行状态。sleep()是Thread的static成员，且抛出InterruptedException。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":444,
"title":"下列代码的编译或执行结果是______。\npublic class MyVal {\n   public static void main(String args[]) {\n      MyVal m = new MyVal();\n      m.aMethod();\n   }\n   public void aMethod(){\n      boolean b[] = new Boolean[5];\n      System.out.println(b[0]);\n    }\n}",
"optionA":"1",
"optionB":"null",
"optionC":"0",
"optionD":"编译错误",
"answer":"D",
"explain":"    本题考查的是Java语言关键字。\n    首先，需要了解初始化数组格式可以为：类型标识符 数组名[]=new 类型标识符[元素个数]。\n    Java语言关键字是区分字母大小写的，在本题中，\"boolean b[]=new Boolean[5];\"编译时不能识别\"Boolean[]\"，所以编译不能通过。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":445,
"title":"下列方法名的定义中，不符合Java命名约定的是______。\nI.showMessage() \nII.ShowMessage()  \nIII.showmessage() \nIV.$showMessage()",
"optionA":"I，II",
"optionB":"IV",
"optionC":"II，III，IV",
"optionD":"I，II，III，IV",
"answer":"C",
"explain":"    本题考查的是Java的命名约定。\n    Java中方法名的命名约定的基本原则如下：\n    （1）_、$不作为方法名开头。\n    （2）方法名首字母小写，每个后面连续的单词的首字母都大写。如myVariable，myMethod。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":446,
"title":"下列程序运行后，能显示\"xyz345\"的行是______。\n1   public class OperatorsAndExpressions{\n2      public static void main(String[] args){\n3         int x=3,y=4,z=5;\n4         String s=\"xyz\";\n5         System.out.println(x+y+z);\n6         System.out.println(s+x+y+z);\n7         System.out.println(x+y+z+s); \n8      }\n9    }",
"optionA":"4",
"optionB":"5",
"optionC":"6",
"optionD":"7",
"answer":"C",
"explain":"    本题考查的是字符串的连接和运算符运算顺序。\n    变量x、y、z都是整型，x+y+z是将三个变量的值相加，即x+y+z=3+4+5=12。\n    字符串用+号连接整型时，是将整型变量转化成字符串，然后再将字符串连接起来。s+x+y+z是先运算s+x得结果为\"xyz3\"，再将\"xyz3\"与y值相加得结果为\"xyz34\"，然后将\"xyz34\"与z值相加得结果为\"xyz345\"。\n    x+y+z+s是先运算x+y，即x+y=3+4=7，再将7与z值相加得12，然后将12与字符串\"xyz\"相加得结果为\"12xyz\"。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":447,
"title":"下列程序执行后的结果是______。\nclass Animal{\n   public Animal(){\n      System.out.print(\"animal\");\n   }\n   public Animal(int n){\n      this();\n      System.out.print(\" \"+ n );\n   }\n}\nclass Dog extends Animal{\n   public Dog(){\n      super(12);\n      System.out.print(\" dog\");\n   }\n}\npublic class Test{\n   public static void main(String[] args) {\n    Animal animal=new Dog();\n   }\n}",
"optionA":"animal 12 dog",
"optionB":"animal dog",
"optionC":"dog animal 12",
"optionD":"dog animal",
"answer":"A",
"explain":"    本题考查的是类的构造方法的重载。\n    构造方法可以重载实现不同的初始化方法，调用时按参数决定调用哪个方法。this用来引用当前对象，super用来引用当前对象的父类。\n    本题首先通过new关键字实例化一个对象，它调用了对象的构造方法，即Dog()。在Dog()中，执行super(12);，引用了当前对象父类的构造方法，根据参数决定调用的构造方法是Animal(int n)，在Animal(int n)中，首先执行this();，根据参数决定调用的构造方法是Animal()，所以首先输出animal，然后执行System.out.print(\" \"+ n );，输出： 12，再执行System.out.print(\" dog\");，输出： dog。所以输出结果为：animal 12 dog。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":448,
"title":"下列语句的功能是向文件score.dat中写入对象流。在下划线处应填入的是______。\n……\nObjectOutputStream out=new ObjectOutputStream(new ______(\"score.dat\"));\nout.writeObject(fenshu);\nout.close();\n……",
"optionA":"ObjectOutputStream",
"optionB":"ObjectInputStream",
"optionC":"FileOutputStream",
"optionD":"FileInputStream",
"answer":"C",
"explain":"    本题考查的是数据流对内存的操作。\n    FileOutputStream用于对磁盘文件涉及的数据流进行输出处理，即向一个文件对象中写入数据。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":449,
"title":"为了使下列程序正常运行并且输出10行i的值，在下划线处应填入的是______。\nclass Test2 ______{\n    int i=0;\n    public static void main(String[] args){\n        Thread t=______();\n        t.start();\n    }\n\n    public void run(){\n        while(i++<10)\n           System.out.println(\"i = \"+i);\n    }\n}",
"optionA":"implements Thread,new Thread ",
"optionB":"extends Thread,new Thread ",
"optionC":"implements Runnable,new Test2 ",
"optionD":"extends Thread,new Test2 ",
"answer":"D",
"explain":"    本题考查的是通过继承Thread类创建线程。\n    Thread类本身实现了Runnable接口，所以在java.lang的Thread类的定义中可以发现run()方法。因此，可以通过继承Thread类，并重写其中的run()方法定义线程体，然后创建该子类的对象创建线程。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":450,
"title":"若有语句int a=2,b=2;则下列表达式中值为4的是______。",
"optionA":"(++a)*(++b)",
"optionB":"(a++)*(b++)",
"optionC":"(a++)*(++b)",
"optionD":"(++a)*(b++)",
"answer":"B",
"explain":"    本题考查的是表达式的运算。\n    增量运算符\"++\"是将操作数加1。对++x与x++的运算结果均为x=x+1，但若将增量运算表达式再作为其他表达式的操作数使用时，i++与++i是有区别的：i++在使用i之后，使i的值加1，因此执行表达式时是以i的值参加表达式的运算的，执行完后，i本身的值变为i+1；而++i是在使用i之前，使i的值加1，因此执行表达式时是以i+1的值参加运算的，执行完后i自身的值也为i+1。\n    选项A表达式的值为9；选项B表达式的值为4；选项C表达式的值为6；选项D表达式的值为6。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":451,
"title":"下列带下划线的标识符中，符合Java命名约定的是______。",
"optionA":"void SetCustomerName()",
"optionB":"char ch",
"optionC":"package Bom.hr",
"optionD":"class timer",
"answer":"B",
"explain":"class timer ",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":452,
"title":"若已有如下类定义：\nclass Animal { }\nclass Cat extends Animal { }\nclass PetCat extends Cat { }\n则下列语句中正确的是______。",
"optionA":"Cat cat=new Animal(); ",
"optionB":"PetCat cat=new Animal();",
"optionC":"Animal animal=new PetCat();",
"optionD":"PetCat cat=new Cat();",
"answer":"C",
"explain":"    本题考查的是类的继承。\n    本题程序中，Cat类继承Animal类，PetCat类继承Cat类，即PetCat也继承自Animal类。选项C：Animal animal=new PetCat();，表示父类引用animal指向子类PetCat对象，创建对象时则自动调用子类PetCat的构造方法。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":453,
"title":"若当前目录下不存在hello.txt文件，则下列程序运行后的结果是______。\nimport java.io.*;\npublic class Test{\n  public static void main(String[] args){\n    try{\n        PrintWriter out=new PrintWriter(new FileOutputStream(\"hello.txt\"));\n      String str=\"abcdefg\";\n      out.print(str);\n      out.close();\n    }\n    catch(Exception e){\n       System.out.println(\"文件没有被发现！\");\n    }\n  }\n}",
"optionA":"将在屏幕上输出\"文件没有被发现！\"",
"optionB":"生成hello.txt文件，并且文件的内容为\"abcdefg\"",
"optionC":"正常运行，但没有生成hello.txt文件",
"optionD":"生成hello.txt文件，但文件中无内容",
"answer":"B",
"explain":"    本题考查的是文件和文件I\/O。\n    FileOutputStream类的构造方法：FileOutputStream(File file)创建一个向指定File对象表示的文件中写入数据的文件输出流。PrintWriter类的构造方法：PrintWriter(OutputStream out)根据现有的OutputStream创建不带自动行刷新的新PrintWriter。\n    根据题意，当前目录下不存在hello.txt文件，语句\"PrintWriter out=new PrintWriter(new FileOutputStream(\"hello.txt\"));\"将生成一个名为hello.txt的文件，并创建一个指向hello.txt的文件输出流的打印对象的格式化表示形式。\n    \"String str=\"abcdefg\";\"创建String类的对象str，并指向字符串常量\"abcdefg\"。\"out.print(str);\"打印字符串。\n    因此，程序生成hello.txt文件，并且文件的内容为\"abcdefg\"。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":454,
"title":"下列情况中，不会使线程进入阻塞状态的是______。",
"optionA":"线程调用了sleep()方法",
"optionB":"线程中使用synchronized请求对象的锁",
"optionC":"线程调用了yield()方法",
"optionD":"线程调用了wait()方法",
"answer":"C",
"explain":"    本题考查的是线程状态与生命周期。\n    如果发生下面几种情况时，线程就进入阻塞状态：线程调用了sleep()方法、join()方法时，线程进入阻塞状态；线程调用wait()方法时，线程由运行状态进入阻塞状态；如果线程中使用synchronized来请求对象的锁未获得时，进入阻塞状态；如果线程中有输入输出操作，也将进入阻塞状态，待输入输出操作结束后，线程进入可运行状态。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":455,
"title":"下列不是Java位运算符的是______。",
"optionA":"~",
"optionB":"^",
"optionC":"|",
"optionD":"!",
"answer":"D",
"explain":"    本题考查的是位运算符。\n    位运算符包括：>>，<<，>>>，&，︱，^，~。\n    \"!\"是布尔逻辑运算符。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":456,
"title":"下列程序的运行结果是______。\nclass Shape{\n   public Shape(){\n      System.out.print(\"Shape\");\n   }\n}\nclass Circle extends Shape{\n   public Circle(){\n      System.out.print(\"Circle\");\n   }\n}\npublic class Test{\n   public static void main(String[] args){\n      Shape d=new Circle();\n   }\n}",
"optionA":"Shape",
"optionB":"Circle",
"optionC":"ShapeCircle",
"optionD":"程序有错误",
"answer":"C",
"explain":"    本题考查的是多态。\n    本题程序中，Circle类继承Shape类，父类和子类中都只有一个构造方法，公共类Test中的语句\"Shape d=new Circle();\"，表示父类引用d指向子类对象，创建对象时则自动调用构造方法，在调用子类构造方法前先调用父类构造方法，在父类构造方法中执行输出语句输出Shape，然后在子类构造方法中执行输出语句输出Circle。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":457,
"title":"字符输出流类的直接父类是______。",
"optionA":"Writer",
"optionB":"Reader",
"optionC":"File",
"optionD":"IOStream",
"answer":"A",
"explain":"    本题考查的是输入输出流。\n    字符输出流类都是Writer抽象类的子类。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":458,
"title":"运行下列程序时，若没有test.dat文件，则______。\nimport java.io.*;\npublic class Test{\n   public static void main(String[] args){\n      try{\n          RandomAccessFile raf=new RandomAccessFile(\"test.dat\",\"r\");\n          System.out.println(\"test.dat\");\n      }\n      catch(IOException ex){\n         System.out.println(\"exception\");\n      }\n   }\n}",
"optionA":"输出exception",
"optionB":"输出test.dat",
"optionC":"输出IOException",
"optionD":"无显示",
"answer":"A",
"explain":"    本题考查的是异常处理。\n    在Java中提供了结构化的异常处理功能，其主要是通过try...catch语句来实现的。在Java中可以将可能产生异常的代码放入到try子句中，如果产生异常，将会执行catch子句。\n    在本程序执行过程中，由于找不到\"test.dat\"，产生异常，转而执行catch子句，通过语句\"System.out.println(\"exception\");\"，输出：exception。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":459,
"title":"在多线程程序设计中，如果采用实现Runnable接口的方式创建线程，则需要实现的方法是______。",
"optionA":"start()",
"optionB":"run()",
"optionC":"sleep()",
"optionD":"resume()",
"answer":"B",
"explain":"    本题考查的是多线程。\n    线程的创建有两种方法：实现Runnable接口和继承Thread类。\n    通过实现Runnable接口创建线程：当实现Runnable接口的类的对象用来创建线程后，该线程的启动将使得对象的run()方法被调用。通过这种方式创建线程的过程是：Runnable的一个实例作为参数传递给Thread类的一个构造方法，该实例对象提供线程体run()。",
"type":"串行化概念和目的",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":460,
"title":"下列关于Applet的叙述中，正确的是______。",
"optionA":"为了使Applet在浏览器中运行，需要在HTML文件中嵌入相应的Applet类",
"optionB":"Applet不能从外部接收参数",
"optionC":"Applet不能使用javac命令进行编译",
"optionD":"Java Application与Applet都必须包含main()方法",
"answer":"A",
"explain":"    本题考查的是Applet的基础知识。\n    Applet是一类非常重要的Java程序，一般来说其嵌入在HTML语言中，它必须要通过其它程序调用执行，本身不能被直接解释执行，故A是正确的；在HTML中可以通过<PARAM>标记向Applet传递参数，所以选项B错误；Applet编译过程与Java Application应用程序相同，编译应用程序的java部分，编译命令是：javac 源文件全名（带扩展名.java），所以C选项错误；Application以main()方法为入口点运行，而Applet要在浏览器或appletviewer中运行，也就是说，Applet可以不包含main()方法，所以D选项错误。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":461,
"title":"若变量a是String类型的数据，那么表达式(a+a)的类型是______。",
"optionA":"char",
"optionB":"String",
"optionC":"int",
"optionD":"long",
"answer":"B",
"explain":"    本题考查的是表达式。\n    在本题中变量a是String类型的数据，运算符\"+\"在表达式(a+a)中的作用是将前后两个字符串连接起来，所以表达式(a+a)的类型是String。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":462,
"title":"若有语句int a=5,b=5;下列表达式中，结果为25的是______。",
"optionA":"(++a)*(--b)",
"optionB":"(a++)*(b--)",
"optionC":"(a++)*(--b)",
"optionD":"(++a)*(b--)",
"answer":"B",
"explain":"    本题考查的是一元算术运算符。\n    将增量运算符与减量运算符表达式再作为其他表达式的操作数使用时，a++与++a是有区别的：a++在使用a之后，使a的值加1，因此执行完a++后，整个表达式的值为a，而a的值变为a+1；++a在使用a之前，使a的值加1，因此执行完++a后，整个表达式和a的值均为a+1。b--和--b的区别与a++和++a的区别类似。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":463,
"title":"下列有关构造方法的描述中，不正确的是______。",
"optionA":"构造方法一定要有返回值",
"optionB":"一个类可以有多个构造方法",
"optionC":"构造方法和类有相同的名字",
"optionD":"构造方法总是和new一起使用",
"answer":"A",
"explain":"    本题考查的是构造方法。\n    构造方法名必须与类名相同，它没有返回值，用户不能直接调用它，只能通过new关键字自动调用，一个类中可以定义一个或多个构造方法。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":464,
"title":"抛出异常应使用的子句是______。",
"optionA":"catch",
"optionB":"throw",
"optionC":"try",
"optionD":"finally",
"answer":"B",
"explain":"    本题考查的是抛出异常。\n    抛出异常、生成异常对象都通过throw语句实现。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":465,
"title":"所有字节输入输出流类都继承自______。",
"optionA":"InputStream类和OutputStream类",
"optionB":"Reader类和Writer类",
"optionC":"object类",
"optionD":"Serializable接口",
"answer":"A",
"explain":"    本题考查的是字节流。\n    所有的字节输入流都从InputStream类继承，所有的字节输出流都继承于OutputStream类。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":466,
"title":"在下列类中，为了实现对计数器counter的并发控制，在下划线处应填入的是______。\npublic class Counter{\n    ______ int counter=0;\n    ______ void add(){\n        counter++;\n    }\n    ______ int get(){\n        counter--;\n        return counter;\n    }\n}",
"optionA":"synchronized,synchronized,synchronized",
"optionB":"private,synchronized,synchronized",
"optionC":"public,public,public",
"optionD":"private,synchronized,public",
"answer":"B",
"explain":"    本题考查的是多线程的并发控制。\n    为了实现对计数器counter的并发控制，add()和get()方法中对计数器的操作语句应是临界区，即当一个线程对计数器进行操作时，其他线程不能对该计数器进行操作，则Counter类中add()和get()方法需要用synchronized进行标记。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":467,
"title":"下列程序的运行结果是______。\npublic class MyTest{\n    public static void main (String[] args){\n        int i=0,j=0;\n        for(j=1;j<100;j++){\n            i+=j;\n        }\n        System.out.println(j);\n     }\n}",
"optionA":"1",
"optionB":"99",
"optionC":"100",
"optionD":"4950",
"answer":"C",
"explain":"    本题考查的是for循环的使用。\n    for循环执行时，首先执行初始化操作，然后判断终止条件是否满足，如果满足，则执行循环体中的语句，最后执行迭代部分。完成一次循环后，重新判断终止条件。\n    本程序中循环运行过程如下：\n    第1轮循环，首先执行j=1，1<100为真，则执行循环体中的语句i+=j，最后执行j++，j的值为2；\n    第2轮循环，因2<100为真，则继续执行循环体中的语句，执行j++，j的值为3；\n    第3轮循环，因3<100为真，则继续执行循环体中的语句，执行j++，j的值为4；\n    ……\n    第99轮循环，因99<100为真，则继续执行循环体中的语句，执行j++，j的值为100；\n    第100轮循环，因100<100为假，循环条件不满足，退出循环，此时j的值为100。程序使用\"System.out.println(j);\"语句对j的值进行输出。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":468,
"title":"下列定义中错误的是______。",
"optionA":"Integer value = 1;",
"optionB":"Integer value = new Integer(1);",
"optionC":"boolean value = 1;",
"optionD":"int value = 1;",
"answer":"C",
"explain":"    本题考查的是简单数据类型。\n    布尔型数据只有两个值：true（真）和false（假），它不对应任何数值，因此，它不能与数字进行相互转换。\n    布尔型变量定义举例如下：\n    boolean value = true;    \/\/定义value变量为布尔型，初值为true",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":469,
"title":"下列关于覆盖的描述中，正确的是______。",
"optionA":"覆盖是指子类与父类的方法具有相同名称、返回类型和参数，但功能不同 ",
"optionB":"覆盖是指子类与父类的方法具有相同名称、返回类型和功能，但参数不同 ",
"optionC":"覆盖是指子类与父类的方法具有相同名称、功能和参数，但返回类型不同",
"optionD":"覆盖是指子类与父类的方法具有相同功能、返回类型和参数，但名称不同",
"answer":"A",
"explain":"    本题考查的是覆盖方法。\n    如果某个子类定义的实例方法和其父类中的某个方法有相同的名称、返回类型和参数，但功能不同，则称这个方法覆盖了它的父类方法。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":470,
"title":"用于设置窗口是否可见的方法是______。",
"optionA":"getSize",
"optionB":"setVisible",
"optionC":"setTitle",
"optionD":"setMenubar",
"answer":"B",
"explain":"    本题考查的是图形用户界面。\n    设置窗口是否可见的方法是setVisible。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":471,
"title":"在下列类中，为了实现对共享变量sharedInt的并发控制，应在下划线处填入的代码是______。\npublic class LockTest{\n    ______ int sharedInt = 0;\n    synchronized void add(){\n        sharedInt ++;\n    }\n    synchronized int get(){\n       return sharedInt;\n    }\n}",
"optionA":"public",
"optionB":"private",
"optionC":"default",
"optionD":"synchronized",
"answer":"B",
"explain":"    本题考查的是线程并发控制。\n    synchronized关键字可用来检测和获得对象锁，并设定临界区。为了防止对共享数据的访问发生错误，应该将访问共享数据的代码使用synchronized关键字设置成临界区。这样加锁进行保护。\n    用synchronized保护的共享数据必须是私有的，将共享数据定义为私有的，使线程不能直接访问这些数据，必须通过对象的方法。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":472,
"title":"下列程序的运行结果是______。\npublic class Test {\npublic static void main (String[]  args){\n   float i = 3.0f;\n   int n=10;\n   System.out.print(i++);\n   System.out.println(\",\"+n*i++);\n   }\n}",
"optionA":"4.0,36.0",
"optionB":"3.0,40.0",
"optionC":"3.0,36.0",
"optionD":"4.0,40.0",
"answer":"B",
"explain":"    本题考查的是简单数据类型。\n    增量运算符\"++\"是将操作数加1。i++是指，在使用i之后，使i的值加1，因此执行表达式时是以i的值参加表达式的运算的，执行完后，i本身的值变为i+1。\n    执行第一个输出语句\"System.out.print(i++);\"时，i的值仍为3.0，当执行完该输出语句后，i的值变为4.0。\n    执行第二个输出语句\"System.out.println(\",\"+n*i++);\"时，先输出\",\"，然后输出表达式\"n*i++\"的值。此时变量i的值为4.0，类型为float型，变量n的值为10，类型为整型，根据自动类型转换原则，先将变量n的数据类型由int类型转换为float类型，然后进行计算，运算结果为：40.0。\n    因此，该程序输出结果为：3.0,40.0。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":473,
"title":"下列选项中，能实现对父类的getSalary方法重写的是______。\nclass Employee{\n   public double getSalary(){}\n}",
"optionA":"class Manager extends Employee{\n   public int getSalary(double x){}\n}",
"optionB":"class Manager extends Employee{\n   public double getSalary(int x,int y){}\n}",
"optionC":"class Manager extends Employee{\n   public double getSalary(){}\n} ",
"optionD":"class Manager extends Employee{\n   public int getSalary(int x,int y){ }\n} ",
"answer":"C",
"explain":"    本题考查的是继承。\n    当子类的成员方法与父类的成员方法名字、参数列表、返回值类型都相同时，子类的方法是父类的方法的重写（Override）。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":474,
"title":"继承是面向对象的一个重要特性，它可以______。",
"optionA":"优化程序的存储空间",
"optionB":"使代码重用，降低程序复杂性",
"optionC":"保证类和接口的安全",
"optionD":"更容易地实例化类的对象",
"answer":"B",
"explain":"    本题考查的是类的继承。\n    继承性是面向对象方法的一个重要基本特征，它使代码可重用，可降低程序复杂性。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":475,
"title":"下列代码的下划线处应填入的是______。\nimport java.io.*;\npublic class Chouti{\n   public static void main(String[] args) throws IOException{\n   InputStreamReader ir;\n   BufferedReader in;\n   ir=new ______(System.in);\n   in=new BufferedReader(ir);\n   System.out.println(\"请输入:\");\n   String str=in.readLine();\n   System.out.println(str);\n   }\n}",
"optionA":"BufferedReader ",
"optionB":"InputStreamReader",
"optionC":"InputStream",
"optionD":"OutputStream",
"answer":"B",
"explain":"    本题考查的是InputStreamReader类。\n    InputStreamReader和BufferedReader都是字符类输入流，都是抽象类Reader的子类。\n    本程序的作用是读取用户输入的一行字符，再输出，由于程序中同时用到InputStreamReader和BufferedReader类的对象，所以输入的字符将被输出两次。根据语句\"InputStreamReader ir;\"和语句\"in=new BufferedReader(ir);\"可知，下划线处填\"InputStreamReader\"。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":476,
"title":"下列程序的运行结果是______。\npublic class ArrayTest{\n   public static void main(String[] args){\n      int data[][]={{1,2,3,4,5},{11,22,33,44,55},{111,222,333,444,555}};\n      for(int i=0;i<data.length;i++){\n         if(i%2==0){\n            System.out.print(data[i][4]+\" \");\n         }\n      }\n   }\n}",
"optionA":"5 555 ",
"optionB":"5 55",
"optionC":"555",
"optionD":"55",
"answer":"A",
"explain":"    本题考查的是循环嵌套。\n    本程序中定义了一个int型的多维数组data[][]，程序中利用for循环\"for(int i=0;i<data.length;i++)\"判断并输出数组data[][]中的元素，当变量i的值不小于数组长度（数组长度为3）时，循环终止。循环中的判断语句\"if(i%2==0)\"用于判断输出的元素，符合条件则输入\"data[i][4] \"。\n    循环运行过程如下：\n    第1轮：当i=0时，i%2==0，条件为真，输出\"data[i][4] \"：5 ；\n    第2轮：当i=1时，i%2==0，条件为假，不执行输出语句；\n    第3轮：当i=2时，i%2==0，条件为真，输出\"data[i][4] \"：555 ；\n    第4轮：当i=3时，i<data.length条件不满足，退出循环。",
"type":"串行化方法",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":477,
"title":"下列代码的下划线处应填入的方法名是______。\nimport java.awt.*;\nimport java.applet.*;\npublic class Hello extends Applet{\n   public void ______ (Graphics g){\n      g.drawString{\"How are you!\",10,10};\n   }\n }",
"optionA":"repaint",
"optionB":"println",
"optionC":"paint",
"optionD":"show",
"answer":"C",
"explain":"    本题考查的是Applet显示。\n    Applet的paint()方法具体执行Applet的绘制，该方法定义如下：\n    public void paint(Graphics g)\n    paint()方法有一个参数g是Graphics类的实例，该实例对象由浏览器生成，它包含了Applet的图形上下文信息，通过它向Applet中显示信息，该对象相当于Applet的画笔。在调用paint()方法时，由浏览器将该对象传递给paint()方法。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":478,
"title":"Component类中用于刷新组件的方法是______。",
"optionA":"getFont()",
"optionB":"getName()",
"optionC":"update()",
"optionD":"paint()",
"answer":"C",
"explain":"    本题考查的是构件和容器。\n    getFont()，获得构件的字体；\n    getName()，获得构件的名字；\n    update()，刷新构件；\n    paint()，绘制构件。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":479,
"title":"下列选项中属于Java运算符的是______。",
"optionA":"**",
"optionB":"add",
"optionC":"#",
"optionD":"+=",
"answer":"D",
"explain":"    本题考查的是运算符。\n    赋值运算符\"=\"的扩展赋值运算符包括+=、-=、*=、\/=等。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":480,
"title":"若希望类定义中的数据成员被该类所有的对象共享，则需要用到的修饰符是______。",
"optionA":"static",
"optionB":"public",
"optionC":"private",
"optionD":"protected",
"answer":"A",
"explain":"    本题考查的是修饰符的含义。\n    static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":481,
"title":"下列程序执行后的结果是______。\npublic class Test{\n    public static void main(String[] args){\n         int[] a=new int[10];\n         int s=0;\n         for(int i=0;i<10;i++){\n           a[i]=i;\n         }\n         try{\n             for(int i=0;i<10;i++){\n             s=s+a[i+1]\/a[i];\n           }\n           System.out.print(\"No exception\");\n         } catch(ArrayIndexOutOfBoundsException e){\n           System.out.print(\"Exception 2\");\n         } catch(Exception e){\n           System.out.print(\"Exception 1\");\n         } \n    }\n}",
"optionA":"Exception 1",
"optionB":"Exception 2",
"optionC":"Exception 2 No exception",
"optionD":"Exception 1 No exception",
"answer":"A",
"explain":"    本题考查的是捕获异常。\n    本题通过for循环将数组a中元素初始化，其中a[0]=0。当执行s=s+a[i+1]\/a[i];时，出现算术异常ArithmeticException。try语句将生成的异常抛出，catch子句处理所抛出的异常事件。首先将抛出异常对象的类与第一个catch进行匹配，ArithmeticException类与ArrayIndexOutOfBoundsException类不匹配。然后与第二个catch进行匹配，因为ArithmeticException类是Exception类的子类，所有与第二个catch匹配，则去执行该catch后的程序段。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":482,
"title":"在java.io包的字节输入流中，过滤器输入流的基类是______。",
"optionA":"ByteArrayInputStream",
"optionB":"FileInputStream",
"optionC":"PipeInputStream",
"optionD":"FilterInputStream",
"answer":"D",
"explain":"    本题考查的是字节流抽象类。\n    ByteArrayInputStream以字节数组作为输入流。\n    FileInputStream可对一个磁盘文件涉及的数据进行处理。\n    PipedInputStream是实现线程之间通信的一个类。\n    FilterInputStream过滤器输入流本身也是一个抽象类。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":483,
"title":"下列代码包括一个HTML文件和一个定义Applet类的Java程序。为了使HTML文件在浏览器中运行时显示\"Hello!\"，在下划线处应填入的是______。\n\/*hello.html*\/\n<HTML>\n<HEAD>\n<TITLE>Hello<\/TITLE>\n<\/HEAD>\n<BODY>\n<APPLET CODE=\"______\" WIDTH=150 HEIGHT=25>\n<\/APPLET>\n<\/BODY>\n<\/HTML>\n\n\/*HelloApplet.java*\/\nimport java.awt.*;\nimport java.applet.*;\npublic class HelloApplet extends Applet{\n     public void ______(Graphics g){\n        g.drawString(\"Hello!\",25,25);\n     }\n}",
"optionA":"HelloApplet.class,paint ",
"optionB":"HelloApplet,update",
"optionC":"HelloApplet.java,start",
"optionD":"HelloApplet.class,repaint",
"answer":"A",
"explain":"    本题考查的是Java Applet应用程序。\n    Applet除了java程序的文件外，还有嵌入的Web页的HTML文件，其中关键是在<APPLET>和<\/APPLET>标记中的CODE：指明要嵌入HTML中的java字节码文件名以及Web页窗口的宽和高的尺寸。public void paint(Graphics g)是方法声明，Applet程序通过paint()方法向窗口输出，它要求g为参数。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":484,
"title":"下列程序的运行结果是______。\npublic class MyCase{\n      public static void main(String[] args){\n         char c='a';\n         switch(c){\n           case 'a':System.out.print(c);\n           case 'b':System.out.print('b');\n           case 'c':System.out.print('c');\n         }\n     }\n}",
"optionA":"a",
"optionB":"b",
"optionC":"cbc",
"optionD":"abc",
"answer":"D",
"explain":"    本题考查的是多分支语句switch。\n    switch语句根据表达式的值从多个分支中选择一个来执行。其一般格式为：\n    switch(expression){\n    case value1: statement1; break;\n    case value2: statement2; break;\n    ……\n    case valueN: statementN; break;\n    【default: defaultStatement;】\n    表达式expression只能返回这几种类型的值：int、byte、short和char。多分支语句把表达式返回的值依次与每个case子句中的值相比较。如果遇到匹配的值，则执行该case语句后的语句序列。break语句用来在执行完一个case分支后，使程序跳出switch语句的执行。\n    程序中对字符变量赋初值为字符'a'，执行switch语句。字符变量c与第一条case子句中的值'a'相匹配。输出字符变量c的值，即输出a。switch语句中不包含break语句，则无需跳出switch语句的执行，可继续执行下面两条case语句，依次输出b、c。\n    因此程序的运行结果为abc。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":485,
"title":"下列关于构造方法的描述中，错误的是______。",
"optionA":"构造方法的作用是用来初始化对象",
"optionB":"构造方法的返回类型是void",
"optionC":"构造方法不能被程序直接调用",
"optionD":"构造方法可以重载",
"answer":"B",
"explain":"    本题考查的是类的构造方法的特点。\n    构造方法有下列特点：\n    （1）构造方法名与类名必须相同，所以方法首字母小写规则对它不适用。\n    （2）构造方法是给对象赋初值，所以没有返回值，但不用void来声明。\n    （3）构造方法不能被程序直接调用，只能通过new自动调用。\n    （4）构造方法可由编程人员在类中定义，默认时由Java语言自动生成。但它是个空方法，变量被赋予该数据类型的默认值。\n    （5）构造方法可以重写，以实现不同的初始化方法。调用时按参数决定调用哪个方法。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":486,
"title":"下列不是Java关键字的是______。",
"optionA":"this",
"optionB":"interface",
"optionC":"enum",
"optionD":"include",
"answer":"D",
"explain":"    本题考查的是Java关键字。\n    Java有50个关键字，按用途分为：\n    （1）表示数据类型：boolean，byte，char，double，false，float，int，instandeof，long，new，null，short，true，void。\n    （2）表示语句：break，case，catch，continue，default，do，else，for，finally，if，return，switch，super，this，throw，try，while。\n    （3）用于修饰：abstract，final，native，private，protected，public，static，synchronized，transient，volatile。\n    （4）表示方法、类、接口和包：class，extend，implements，import，interface，package，throws。\n    （5）保留未用：const，goto。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":487,
"title":"下列代码中的鼠标事件类是______。\npublic class MyMouse extends MouseAdapter{\n   public void mouseExited(MouseEvent e){}\n   public void mouseEntered(MouseEvent e){}\n   public void mouseClicked(MouseEvent e){}\n}",
"optionA":"MyMouse",
"optionB":"MouseAdapter",
"optionC":"MouseEvent",
"optionD":"mouseClicked",
"answer":"A",
"explain":"    本题考查的是鼠标事件类。\n    MouseAdapter是接收鼠标事件的抽象适配器类，MyMouse继承MouseAdapter，并对此类中的抽象方法进行重写，因此MyMouse是鼠标事件类。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":488,
"title":"下列关于Applet的描述中，错误的是______。",
"optionA":"Applet自身不能运行，必须嵌入到其它应用程序（如浏览器）中运行 ",
"optionB":"可以使用Graphics类的drawImage()方法显示图像",
"optionC":"通过在HTML文件中采用<PARAM>标记可以向Applet传递参数 ",
"optionD":"Applet不支持多线程 ",
"answer":"D",
"explain":"    本题考查的是Applet的基本概念。\n    Applet自身不能运行，必须嵌入到其它应用程序（如浏览器）中运行。Applet可以使用Graphics类提供的方法满足显示的需求，drawImage()方法用来显示图像。Java Applet通过命令行将参数传给main()方法，而Applet获取参数是通过在HTML文件中采用<PRAM>标记定义参数。选项A、B、C正确。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":489,
"title":"下列程序的运行结果是______。\npublic class Test{\n   public static void main(String[] args){\n    int x=3,y=4,z=5;\n    if(x>3){\n       if(y<2)\n          System.out.println(\"show one\");\n       else\n          System.out.println(\"show two\");\n    }\n    else{\n         if(z>4)\n            System.out.println(\"show three\");\n         else    \n            System.out.println(\"show four\");\n          }\n   }\n}",
"optionA":"show one",
"optionB":"show two",
"optionC":"show three",
"optionD":"show four",
"answer":"C",
"explain":"    本题考查的是条件语句。\n    if-else结构：\n    if(条件)\n        statement1;或{block1}\n    else \n        statement2;或{block2}\n    执行过程如下：\n    在条件为真时，执行语句statement1（或代码块block1），然后跳过else和statement2（或代码块block2）执行下面的语句；在条件为假时，跳过语句statement1（或代码块block1）执行else后面的statement2（或代码块block2），然后继续执行下面的语句。\n    本题中变量x的值为3，则\"if(x>3)\"语句中的条件\"x>3\"为假，跳过下面的代码块，直接执行对应的else语句下的代码块。变量z的值为5，语句\"if(z>4)\"中的条件\"z>4\"为真，则执行语句\"System.out.println(\"show three\");\"。因此，输出结果为：show three。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":490,
"title":"Java中用来定义包的关键字是______。",
"optionA":"package",
"optionB":"import",
"optionC":"com",
"optionD":"class",
"answer":"A",
"explain":"    本题考查的是包。\n    定义一个包要用package关键字。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":491,
"title":"下列关于程序运行结果的描述中，错误的是______。\nimport javax.swing.*;\nimport java.awt.*;\npublic class Test{\n   public static void main(String[] args){\n      JFrame f=new JFrame();\n      JPanel p=new JPanel();\n      f.setLayout(new BorderLayout());\n      f.getContentPane().add(p,\"Center\");\n      p.setBackground(Color.blue);\n      f.setVisible(true);\n      f.setSize(200,200);\n   }\n}",
"optionA":"程序不能运行",
"optionB":"显示一个窗口",
"optionC":"窗口大小是200×200",
"optionD":"窗口背景为蓝色",
"answer":"A",
"explain":"    本题考查的是编写图形用户界面。\n    本题程序的功能是显示一个窗口，通过语句\"f.setSize(200,200);\"设置该窗口的大小为200×200，程序在顶层容器JFrame中加入面板JPanel，并将面板的背景色通过语句\"p.setBackground(Color.blue);\"设置为蓝色。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":492,
"title":"当一个包含Applet的Web页面被其他页面覆盖时，被调用的Applet方法是______。",
"optionA":"start()",
"optionB":"init()",
"optionC":"stop()",
"optionD":"destroy()",
"answer":"C",
"explain":"    本题考查的是Applet类的生命周期方法。\n    Applet类提供了生命周期不同阶段响应主要事件的4种方法：\n    ①void init()，在Applet被下载时调用，一般用来完成所有必需的初始化操作。\n    ②void start()，在Applet初始化之后以及Applet被重新访问时调用。\n    ③void stop()，在Applet停止执行时调用。一般发生在Applet所在的Web页被其他页覆盖时调用。\n    ④void destroy()，在关闭浏览器Applet从系统中撤出时调用。stop()总是在此前被调用。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":493,
"title":"如果要安全地终止一个线程t，可以采用的正确方法是______。",
"optionA":"调用t.stop()方法",
"optionB":"可以使用标志flag，通过设置flag通知线程t结束",
"optionC":"调用t.suspend()方法",
"optionD":"调用t.yield()方法",
"answer":"B",
"explain":"    本题考查的是线程的基本控制。\n    当线程完成运行并结束后，将不能再运行。除线程正常运行结束外，还可用其他方法控制其停止。可以用stop()方法强行终止线程，但不提倡使用这种方法，容易造成线程的不一致。可以使用标志flag，通过设置flag通知一个线程应该结束。",
"type":"串行化的举例",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":494,
"title":"下列变量的定义中，错误的是______。",
"optionA":"int x=3; ",
"optionB":"float f;d;",
"optionC":"String s=\"Hello!\";",
"optionD":"boolean b=true;",
"answer":"B",
"explain":"    本题考查的是变量的定义格式。\n    Java程序中的语句必须以英文状态下的分号结尾，B选项中，变量f为float型，但是变量d未定义，如果要同时将变量f和d定义为float型，则需要改为\"float f,d;\"，所以选项B错误。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":495,
"title":"鼠标在窗口中移动时，产生的事件是______。",
"optionA":"ActionEvent",
"optionB":"PrintEvent",
"optionC":"KeyEvent",
"optionD":"MouseEvent",
"answer":"D",
"explain":"    本题考查的是鼠标事件。\n    在Java中，当用户使用鼠标进行操作时，会产生鼠标事件MouseEvent。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":496,
"title":"下列程序执行后的结果是______。\npublic class MyBool{\n  public static void main(String[] args){\n    int i=0;\n    System.out.println((i==1)?2:3);\n  }\n}",
"optionA":"2",
"optionB":"3",
"optionC":"0",
"optionD":"1",
"answer":"B",
"explain":"    本题考查的是运算符。\n    \"?:\"是条件运算符，条件运算符是三元运算符。\n    三元条件表达式的一般形式为：\n    expression1?expression2:expression3\n    其中表达式expression1应该是关系或布尔逻辑表达式，其计算结果为布尔值。如果该值为true，则计算表达式expression2，并将计算结果作为整个条件表达式的结果；如果为false，则计算表达式expression3，并将计算结果作为条件表达式的结果。\n    本题中，变量i被赋值0，条件\"0==1\"不成立，则程序执行结果为3。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":497,
"title":"在一个类中可以定义多个名称相同，但参数不同的方法，这叫做方法的______。",
"optionA":"继承",
"optionB":"覆盖",
"optionC":"改写",
"optionD":"重载",
"answer":"D",
"explain":"    本题考查的是方法的重载。\n    方法的重载是指多个方法可以享用相同的名字，但参数的数量或类型必须不完全相同，即方法体有所不同，它实现了Java编译时的多态性（即静态多态性）。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":498,
"title":"下列用于设置窗口标题的方法是______。",
"optionA":"getSize()",
"optionB":"setTitle()",
"optionC":"setBackground()",
"optionD":"setForeground()",
"answer":"B",
"explain":"    本题考查的是构件的方法。\n    getSize()：获得构件的大小；\n    setTitle()：设置窗口标题；\n    setBackground()：设置背景色；\n    setForeground()：设置构件的前景色。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":499,
"title":"下列有关Java线程的说法中，正确的是______。",
"optionA":"Java中的线程模型包括虚拟的CPU和程序代码两部分",
"optionB":"Java中，一个程序的一次执行对应一个线程",
"optionC":"线程创建后需要通过调用start()方法启动运行",
"optionD":"只有Java能够支持基于多线程的并发程序设计",
"answer":"C",
"explain":"    本题考查的是线程。\n    新建的线程不会自动运行，必须调用线程的start()方法启动。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":500,
"title":"下列程序定义了一个Applet类，在下划线处应填入的是______。 \nimport java.awt.*;\nimport java.______.*;\npublic class Greetings extends ______{\n    public void paint(Graphics g){\n        g.drawString(\"Good morning!\",40,40);\n    }\n}",
"optionA":"swing,Applet",
"optionB":"swing,JApplet",
"optionC":"applet,Japplet",
"optionD":"applet,Applet",
"answer":"D",
"explain":"    本题考查的是Java Applet应用程序。\n    Graphics类和Applet类对Applet都是必须的，import java.awt.*;用于引入java.awt包中的Graphics类；import java.applet.*;用于引入java.applet包中的Applet类。\n    生产Applet必须创建Applet类的子类，本题在类声明时，Greetings类需要继承于Applet类。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":501,
"title":"关于下列代码的描述中，正确的是______。\npublic class Person{\n   int[] arr=new int[9];\n   public static void main(String[] args){\n     System.out.println(arr[10]);\n   }\n}",
"optionA":"编译时将产生错误",
"optionB":"编译时正确，运行时将产生错误",
"optionC":"输出0",
"optionD":"输出null",
"answer":"A",
"explain":"    本题考查的是数组。\n    该程序编译时将产生错误。本题main方法是静态方法，静态方法只可以访问这个类中的静态成员，而数组arr是非静态成员。如果要在静态方法中，访问动态成员，那么首先要在这个方法中进行实例化，然后通过具体的对象来访问。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":502,
"title":"下列关于字符串的定义中，正确的是______。",
"optionA":"String str=null;",
"optionB":"String str='null';",
"optionC":"String str=(String)'Hello';",
"optionD":"String str='Good Morning!';",
"answer":"A",
"explain":"    本题考查的是字符串。\n    \"String str=null;\"是指把这个引用指向了一个空值，即指向一个没有地址没有值的地方。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":503,
"title":"若需读取某文件中不连续的几个记录，需要使用的类是______。",
"optionA":"FilterReader",
"optionB":"ObjectOutputStream",
"optionC":"BufferedOutputStream",
"optionD":"RandomAccessFile",
"answer":"D",
"explain":"    本题考查的是RandomAccessFile类。\n    Java中的RandomAccessFile类提供了随机访问文件的功能，它直接继承了java.lang.Obiect类，同时实现了DataInput和DataOutput接口。接口中定义了从流中读\/写基本数据类型的方法，因此也可以随机读入字节数据文件的记录。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":504,
"title":"下列关于线程优先级与线程调度的描述中，错误的是______。",
"optionA":"Java中的线程是有优先级的",
"optionB":"新建线程将继承创建它的父线程的优先级",
"optionC":"当有比当前线程的优先级高的线程出现时，高优先级线程将抢占CPU并运行",
"optionD":"具有相同优先级的多个线程的调度一定是分时的",
"answer":"D",
"explain":"    本题考查的是线程的调度与控制。\n    Java中的线程是有优先级的，选项A正确。新建线程将继承创建它的父线程的优先级，选项B正确。Java的线程调度策略是一种基于优先级的抢先式调度，这种调度策略的含义是：Java基于线程的优先级选择高优先级的线程进行运行。该线程（当前线程）将持续运行，直到它终止运行，或其他高优先级线程成为可运行的。在后一种情况，低优先级线程被高优先级线程抢占运行。选项C正确。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":505,
"title":"为了使下列程序正常运行，应在下划线处填入的代码是______。 \nimport javax.swing.*;\nimport java.awt.*;\npublic class SwingApplet extends ______{\n   JButton b=new JButton(\"OK\");\n   public void init(){\n     Container contentPane=getContentPane();\n     ______;\n   }\n}",
"optionA":"JApplet\ncontentPane.add(b) ",
"optionB":"JApplet\nadd(b) ",
"optionC":"Applet\nadd(b) ",
"optionD":"Applet\ncontentPane.add(b) ",
"answer":"A",
"explain":"    本题考查的是基于Swing的Applet用户界面。\n    JApplet是顶层的Swing容器，其内部用一个隐含的根面板（JRootPanel）作为惟一的直接后代，而根面板中的内容面板（Content Pane）才是JApplet除菜单条外所有构件的双亲。由于内容面板的存在，通常对JApplet添加构件有两种方式：\n    方式1：用getContentPane()方法获得JApplet的内容面板，再使用add()方法向内容面板中添加构件。\n    方式2：建立一个JPanel之类的中间容器，把构件添加到容器中，再用setContentPane()方法把该容器置为JApplet的内容面板。\n    本程序中采用方式1，故SwingApplet需要继承JApplet类，第一个空应填写\"JApplet\"，第二个空应填写\"contentPane.add(b); \"。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":506,
"title":"下列程序的运行结果是______。\npublic class Test{\n    public static void main(String[] args){\n       int[] m=new int[]{1,2,3,4,5,6,7,8};\n       int sum=0;\n       for(int i=0;i<8;i++){\n          sum+=m[i];\n          if(i==3) break;\n       }\n       System.out.println(sum);\n   }\n}",
"optionA":"3",
"optionB":"6",
"optionC":"10",
"optionD":"36",
"answer":"C",
"explain":"    本题考查的是循环语句与分支语句的嵌套。\n    该程序首先定义了一个int类型的数组，数组中包含8个元素，数组下标为0-7。又定义变量sum，初值为0。程序通过for循环语句，将数组中的元素相加，相加的值存放在变量sum中，但for循环中嵌套了一个if语句，用于判断结束条件，当变量i的值等于3时，执行break语句退出循环。程序运行后，for循环共执行4次，sum=m[0]+m[1]+m[2]+m[3]=1+2+3+4=10。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":507,
"title":"下列关于Object类中定义方法的描述中，正确的是______。",
"optionA":"其他类不能调用",
"optionB":"其他类部分能调用",
"optionC":"其他类大部分不能调用",
"optionD":"其他类全都能调用",
"answer":"D",
"explain":"    本题考查的是Object类。\n    Object类是Java程序中所有类的直接或间接父类，也是类库中所有类的父类，处在类层次的最高点。所有其他的类都是从Object类派生出来的。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":508,
"title":"下列代码的下划线处应填入相同的类，该类是______。\nimport javax.swing.*;\npublic class Test{\n   public static void main(String args[]){\n      JFrame f=new JFrame();\n      f.setTitle(\"Menus\");\n      f.setVisible(true);\n      f.setSize(500,400);\n      ______ mb=new ______();\n      f.setJMenuBar(mb);\n      JMenu m=new JMenu(\"文件\");\n      mb.add(m);\n      JMenuItem mi=new JMenuItem(\"打开\");\n      m.add(mi);\n   }\n}",
"optionA":"JMenuItem ",
"optionB":"JMenu ",
"optionC":"JFrame",
"optionD":"JMenuBar",
"answer":"D",
"explain":"    本题考查的是编写图形用户界面。\n    本题程序定义了一个标题为\"Menus\"，大小为500*400的窗体，并在窗体上插入一个菜单\"文件\"，菜单项为\"打开\"（本题程序中，菜单项为隐藏，在拖动窗口大小后显示）。Swing的菜单结构和AWT的类似，菜单容器是菜单条JMenuBar，菜单是JMenu，菜单项是JMenuItem，还有JCheckBoxMenuItem。Swing的菜单结构使用起来更加灵活，可以通过setJMenuBar将菜单条放置到容器中的任意地方。\n    根据语句\"f.setJMenuBar(mb);\"可知，程序中两处填空应填：JMenuBar。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":509,
"title":"如果要从一个HTML文件中提取名为message的参数的值，需要在Applet类的init()方法中使用的代码行是______。",
"optionA":"String s=getParameter(\"message\")",
"optionB":"String s=getParameter(\"MESSAGE\")",
"optionC":"String s=Parameter(\"message\")",
"optionD":"String s=getParameter(\"message\")或String s=getParameter(\"MESSAGE\")",
"answer":"A",
"explain":"    本题考查的是Applet程序设计。\n    Applet被下载时，在Applet的init()方法中使用getParameter()方法获取参数。getParameter()方法的入口参数是所取参数的名字（必须与<param>标记中的name指示的名字相同），返回值是参数的值。另外，JAVA是严格区分大小写的，所以参数\"MESSAGE\"和参数\"message\"不同。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
},
{
"id":510,
"title":"Java多线程并发控制中，用于在代码中标识临界区的关键字是______。",
"optionA":"start",
"optionB":"wait",
"optionC":"synchronized",
"optionD":"lock",
"answer":"C",
"explain":"    本题考查的是并发控制。\n    Java中对共享数据操作的并发控制是采用传统的封锁技术。一个程序中单独的、并发的线程对同一个对象进行访问的代码段，称为临界区。在Java语言中，临界区可以是一个语句块或是一个方法，并且用\"synchronized\"关键字标识。",
"type":"基于文本的应用",
"num":0,
"mistaken":0,
"collect":0
}
]
}